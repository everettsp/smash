!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!%      This module `mwd_states` encapsulates all SMASH states.
!%      This module is wrapped and differentiated.
!%
!%      StatesDT type:
!%
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``hi``                   Interception state       [-]   (default: 0.01)   ]0, 1[
!%      ``hp``                   Production state         [-]   (default: 0.01)   ]0, 1[
!%      ``hft``                  Fast transfer state      [-]   (default: 0.01)   ]0, 1[
!%      ``hst``                  Slow transfer state      [-]   (default: 0.01)   ]0, 1[
!%
!%      ``husl1``                Upper soil layer 1 state [-]   (default: 0.01)   ]0, 1[
!%      ``husl2``                Upper soil layer 2 state [-]   (default: 0.01)   ]0, 1[
!%      ``hlsl``                 Lower soil layer state   [-]   (default: 0.01)   ]0, 1[
!%
!%      ``hlr``                  Linear routing state     [mm]  (default: 1e-6)   ]0, +Inf[
!%      ======================== =======================================
!%
!%      Hyper_StatesDT type:
!%
!%      It contains same States variables (see above)
!%
!%      contains
!%
!%      [1] StatesDT_initialise
!%      [2] Hyper_StatesDT_initialise
!%      [3] states_to_matrix
!%      [4] matrix_to_states
!%      [5] vector_to_states
!%      [6] set0_states
!%      [7] set1_states
!%      [8]  hyper_states_to_matrix
!%      [10] matrix_to_hyper_states
!%      [11] set0_hyper_states
!%      [12] set1_hyper_states
!%      [13] hyper_states_to_states
MODULE MWD_STATES_DIFF
!% only: sp, ns
  USE MD_CONSTANT
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
  IMPLICIT NONE
!% Notes
!% -----
!% StatesDT Derived Type.
! GR
! VIC
! Routing
  TYPE STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: husl1
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: husl2
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlsl
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE STATESDT
!% Notes
!% -----
!% Hyper_StatesDT Derived Type.
! GR
! VIC
! Routing
  TYPE HYPER_STATESDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hi
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: husl1
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: husl2
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlsl
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: hlr
  END TYPE HYPER_STATESDT

CONTAINS
  SUBROUTINE STATESDT_INITIALISE(this, mesh)
    IMPLICIT NONE
    TYPE(STATESDT), INTENT(INOUT) :: this
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this%hi(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hp(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hft(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hst(mesh%nrow, mesh%ncol))
    ALLOCATE(this%husl1(mesh%nrow, mesh%ncol))
    ALLOCATE(this%husl2(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hlsl(mesh%nrow, mesh%ncol))
    ALLOCATE(this%hlr(mesh%nrow, mesh%ncol))
    this%hi = 0.01_sp
    this%hp = 0.01_sp
    this%hft = 0.01_sp
    this%hst = 0.01_sp
    this%husl1 = 0.01_sp
    this%husl2 = 0.01_sp
    this%hlsl = 0.01_sp
    this%hlr = 0.000001_sp
  END SUBROUTINE STATESDT_INITIALISE

  SUBROUTINE HYPER_STATESDT_INITIALISE(this, setup)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    ALLOCATE(this%hi(setup%optimize%nhyper, 1))
    ALLOCATE(this%hp(setup%optimize%nhyper, 1))
    ALLOCATE(this%hft(setup%optimize%nhyper, 1))
    ALLOCATE(this%hst(setup%optimize%nhyper, 1))
    ALLOCATE(this%husl1(setup%optimize%nhyper, 1))
    ALLOCATE(this%husl2(setup%optimize%nhyper, 1))
    ALLOCATE(this%hlsl(setup%optimize%nhyper, 1))
    ALLOCATE(this%hlr(setup%optimize%nhyper, 1))
  END SUBROUTINE HYPER_STATESDT_INITIALISE

END MODULE MWD_STATES_DIFF

!%      This module `mwd_output` encapsulates all SMASH output.
!%      This module is wrapped and differentiated.
!%
!%      OutputDT type:
!%
!%      </> Public
!%      ========================== =====================================
!%      `Variables`                Description
!%      ========================== =====================================
!%      ``qsim``                   Simulated discharge at gauge               [m3/s]
!%      ``qsim_domain``            Simulated discharge whole domain           [m3/s]
!%      ``sparse_qsim_domain``     Sparse simulated discharge whole domain    [m3/s]
!%      ``net_prcp_domain``        Net precipitaition whole domain            [mm/dt]
!%      ``sparse_net_prcp_domain`` Sparse net precipitation whole domain      [mm/dt]
!%      ``cost``                   Cost value
!%      ``cost_jobs``              Objective function cost value
!%      ``cost_jreg``              Regularization function cost value
!%      ``cost_jobs_initial``      Objective function initial cost value
!%      ``cost_jreg_initial``      Regularization function initial cost value
!%      ``fstates``                Final states (StatesDT)
!%      ========================== =====================================
!%
!%      contains
!%
!%      [1] OutputDT_initialise
MODULE MWD_OUTPUT_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!%only: StatesDT, StatesDT_initialise
  USE MWD_STATES_DIFF
  IMPLICIT NONE
!% Notes
!% -----
!% OutputDT Derived Type.
!>f90w-private
!>f90w-private
  TYPE OUTPUTDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_qsim_domain
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: net_prcp_domain
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: sparse_net_prcp_domain
      REAL(sp) :: cost=0._sp
      REAL(sp) :: cost_jobs=0._sp
      REAL(sp) :: cost_jreg=0._sp
      REAL(sp) :: cost_jobs_initial=0._sp
      REAL(sp) :: cost_jreg_initial=0._sp
      TYPE(STATESDT) :: fstates
  END TYPE OUTPUTDT
  TYPE OUTPUTDT_DIFF
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: qsim
      REAL(sp), DIMENSION(:, :, :), ALLOCATABLE :: qsim_domain
  END TYPE OUTPUTDT_DIFF

CONTAINS
  SUBROUTINE OUTPUTDT_INITIALISE(this, setup, mesh)
    IMPLICIT NONE
    TYPE(OUTPUTDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(INOUT) :: setup
    TYPE(MESHDT), INTENT(INOUT) :: mesh
    IF (mesh%ng .GT. 0) THEN
      ALLOCATE(this%qsim(mesh%ng, setup%ntime_step))
      this%qsim = -99._sp
    END IF
    IF (setup%save_qsim_domain) THEN
      IF (setup%sparse_storage) THEN
        ALLOCATE(this%sparse_qsim_domain(mesh%nac, setup%ntime_step))
        this%sparse_qsim_domain = -99._sp
      ELSE
        ALLOCATE(this%qsim_domain(mesh%nrow, mesh%ncol, setup%ntime_step&
&       ))
        this%qsim_domain = -99._sp
      END IF
    END IF
    IF (setup%save_net_prcp_domain) THEN
      IF (setup%sparse_storage) THEN
        ALLOCATE(this%sparse_net_prcp_domain(mesh%nac, setup%ntime_step)&
&       )
        this%sparse_net_prcp_domain = -99._sp
      ELSE
        ALLOCATE(this%net_prcp_domain(mesh%nrow, mesh%ncol, setup%&
&       ntime_step))
        this%net_prcp_domain = -99._sp
      END IF
    END IF
    CALL STATESDT_INITIALISE(this%fstates, mesh)
  END SUBROUTINE OUTPUTDT_INITIALISE

END MODULE MWD_OUTPUT_DIFF

!%      This module `mwd_parameters` encapsulates all SMASH parameters.
!%      This module is wrapped and differentiated.
!%
!%      ParametersDT type:
!%
!%      </> Public
!%      ======================== =======================================
!%      `Variables`              Description
!%      ======================== =======================================
!%      ``ci``                   GR interception parameter          [mm]    (default: 1)     ]0, +Inf[
!%      ``cp``                   GR production parameter            [mm]    (default: 200)   ]0, +Inf[
!%      ``beta``                 GR percolation parameter           [-]     (default: 1000)  ]0, +Inf[
!%      ``cft``                  GR fast transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``cst``                  GR slow transfer parameter         [mm]    (default: 500)   ]0, +Inf[
!%      ``alpha``                GR transfer partitioning parameter [-]     (default: 0.9)   ]0, 1[
!%      ``exc``                  GR exchange parameter              [mm/dt] (default: 0)     ]-Inf, +Inf[
!%
!%      ``b``                    VIC infiltration parameter         [-]     (default: 0.3)   ]0, +Inf[
!%      ``cusl1``                VIC upper soil layer 1 capacity    [mm]    (default: 100)   ]0, +Inf[
!%      ``cusl2``                VIC upper soil layer 2 capacity    [mm]    (default: 500)   ]0, +Inf[
!%      ``clsl``                 VIC lower soil layer capacity      [mm]    (default: 2000)  ]0, +Inf[
!%      ``ks``                   VIC sat. hydraulic conductivity    [mm/dt] (default: 20)    ]0, +Inf[
!%      ``ds``                   VIC baseflow ds parameter          [-]     (default: 0.02)  ]0, 1[
!%      ``dsm``                  VIC baseflow max discharge         [mm/dt] (default: 0.33)  ]0, +Inf[
!%      ``ws``                   VIC baseflow linear threshold      [-]     (default: 0.8)  ]0, 1[
!%
!%      ``lr``                   Linear routing parameter           [min]   (default: 5)     ]0, +Inf[
!%      ======================== =======================================
!%
!%      Hyper_ParametersDT type:
!%
!%      It contains same Parameters variables (see above)
!%
!%      contains
!%
!%      [1]  ParametersDT_initialise
!%      [2]  Hyper_ParametersDT_initialise
!%      [3]  parameters_to_matrix
!%      [4]  matrix_to_parameters
!%      [5]  vector_to_parameters
!%      [6]  set0_parameters
!%      [7]  set1_parameters
!%      [8]  hyper_parameters_to_matrix
!%      [10] matrix_to_hyper_parameters
!%      [11] set0_hyper_parameters
!%      [12] set1_hyper_parameters
!%      [13] hyper_parameters_to_parameters
MODULE MWD_PARAMETERS_DIFF
!% only: sp, GNP
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
  IMPLICIT NONE
!% Notes
!% -----
!% ParametersDT Derived Type.
! GR
! VIC
! Routing
  TYPE PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: b
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cusl1
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cusl2
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: clsl
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ks
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ds
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: dsm
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ws
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE PARAMETERSDT
!% Notes
!% -----
!% Hyper_ParametersDT Derived Type.
! GR
! VIC
! Routing
  TYPE HYPER_PARAMETERSDT
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ci
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cp
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: beta
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cft
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cst
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: alpha
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: exc
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: b
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cusl1
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: cusl2
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: clsl
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ks
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ds
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: dsm
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: ws
      REAL(sp), DIMENSION(:, :), ALLOCATABLE :: lr
  END TYPE HYPER_PARAMETERSDT

CONTAINS
  SUBROUTINE PARAMETERSDT_INITIALISE(this, mesh)
    IMPLICIT NONE
    TYPE(PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(MESHDT), INTENT(IN) :: mesh
    ALLOCATE(this%ci(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cp(mesh%nrow, mesh%ncol))
    ALLOCATE(this%beta(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cft(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cst(mesh%nrow, mesh%ncol))
    ALLOCATE(this%alpha(mesh%nrow, mesh%ncol))
    ALLOCATE(this%exc(mesh%nrow, mesh%ncol))
    ALLOCATE(this%b(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cusl1(mesh%nrow, mesh%ncol))
    ALLOCATE(this%cusl2(mesh%nrow, mesh%ncol))
    ALLOCATE(this%clsl(mesh%nrow, mesh%ncol))
    ALLOCATE(this%ks(mesh%nrow, mesh%ncol))
    ALLOCATE(this%ds(mesh%nrow, mesh%ncol))
    ALLOCATE(this%dsm(mesh%nrow, mesh%ncol))
    ALLOCATE(this%ws(mesh%nrow, mesh%ncol))
    ALLOCATE(this%lr(mesh%nrow, mesh%ncol))
    this%ci = 1e-6_sp
    this%cp = 200._sp
    this%beta = 1000._sp
    this%cft = 500._sp
    this%cst = 500._sp
    this%alpha = 0.9_sp
    this%exc = 0._sp
    this%b = 0.3_sp
    this%cusl1 = 100._sp
    this%cusl2 = 500._sp
    this%ks = 20._sp
    this%clsl = 2000._sp
    this%ds = 0.02_sp
    this%dsm = 0.33_sp
    this%ws = 0.8_sp
    this%lr = 5._sp
  END SUBROUTINE PARAMETERSDT_INITIALISE

  SUBROUTINE HYPER_PARAMETERSDT_INITIALISE(this, setup)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: this
    TYPE(SETUPDT), INTENT(IN) :: setup
    ALLOCATE(this%ci(setup%optimize%nhyper, 1))
    ALLOCATE(this%cp(setup%optimize%nhyper, 1))
    ALLOCATE(this%beta(setup%optimize%nhyper, 1))
    ALLOCATE(this%cft(setup%optimize%nhyper, 1))
    ALLOCATE(this%cst(setup%optimize%nhyper, 1))
    ALLOCATE(this%alpha(setup%optimize%nhyper, 1))
    ALLOCATE(this%exc(setup%optimize%nhyper, 1))
    ALLOCATE(this%b(setup%optimize%nhyper, 1))
    ALLOCATE(this%cusl1(setup%optimize%nhyper, 1))
    ALLOCATE(this%cusl2(setup%optimize%nhyper, 1))
    ALLOCATE(this%clsl(setup%optimize%nhyper, 1))
    ALLOCATE(this%ks(setup%optimize%nhyper, 1))
    ALLOCATE(this%ds(setup%optimize%nhyper, 1))
    ALLOCATE(this%dsm(setup%optimize%nhyper, 1))
    ALLOCATE(this%ws(setup%optimize%nhyper, 1))
    ALLOCATE(this%lr(setup%optimize%nhyper, 1))
  END SUBROUTINE HYPER_PARAMETERSDT_INITIALISE

END MODULE MWD_PARAMETERS_DIFF

!%      This module `mwd_parameters_manipulation` encapsulates all SMASH parameters manipulation.
!%      This module is wrapped and differentiated.
!%
!%      set_parameters interface:
!%
!%      module procedure set0d_parameters
!%      module procedure set1d_parameters
!%      module procedure set3d_parameters
!%
!%      set_hyper_parameters interface:
!%
!%      module procedure set0d_hyper_parameters
!%      module procedure set1d_hyper_parameters
!%      module procedure set3d_hyper_parameters
!%
!%      contains
!%
!%      [1]   get_parameters
!%      [2]   set0d_parameters
!%      [3]   set1d_parameters
!%      [4]   set3d_parameters
!%      [5]   normalize_parameters
!%      [6]   denormalize_parameters
!%      [7]   get_hyper_parameters
!%      [8]   set0d_hyper_parameters
!%      [9]   set1d_hyper_parameters
!%      [10]  set3d_hyper_parameters
!%      [11]  hyper_parameters_to_parameters
MODULE MWD_PARAMETERS_MANIPULATION_DIFF
  USE MD_CONSTANT
  USE MWD_SETUP
  USE MWD_MESH
  USE MWD_INPUT_DATA
  USE MWD_PARAMETERS_DIFF
  IMPLICIT NONE
  INTERFACE SET_PARAMETERS
      MODULE PROCEDURE SET0D_PARAMETERS
      MODULE PROCEDURE SET1D_PARAMETERS
      MODULE PROCEDURE SET3D_PARAMETERS
  END INTERFACE SET_PARAMETERS

  INTERFACE SET_PARAMETERS_D
      MODULE PROCEDURE SET3D_PARAMETERS_D
  END INTERFACE

  INTERFACE SET_PARAMETERS_B
      MODULE PROCEDURE SET3D_PARAMETERS_B
  END INTERFACE

  INTERFACE SET_HYPER_PARAMETERS
      MODULE PROCEDURE SET0D_HYPER_PARAMETERS
      MODULE PROCEDURE SET1D_HYPER_PARAMETERS
      MODULE PROCEDURE SET3D_HYPER_PARAMETERS
  END INTERFACE SET_HYPER_PARAMETERS


CONTAINS
!  Differentiation of get_parameters in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: a
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
!%      TODO comment
  SUBROUTINE GET_PARAMETERS_D(mesh, parameters, parameters_d, a, a_d)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(INOUT) :: a_d
    a_d = 0.0_4
    a_d(:, :, 1) = parameters_d%ci(:, :)
    a(:, :, 1) = parameters%ci(:, :)
    a_d(:, :, 2) = parameters_d%cp(:, :)
    a(:, :, 2) = parameters%cp(:, :)
    a_d(:, :, 3) = parameters_d%beta(:, :)
    a(:, :, 3) = parameters%beta(:, :)
    a_d(:, :, 4) = parameters_d%cft(:, :)
    a(:, :, 4) = parameters%cft(:, :)
    a_d(:, :, 5) = parameters_d%cst(:, :)
    a(:, :, 5) = parameters%cst(:, :)
    a_d(:, :, 6) = parameters_d%alpha(:, :)
    a(:, :, 6) = parameters%alpha(:, :)
    a_d(:, :, 7) = parameters_d%exc(:, :)
    a(:, :, 7) = parameters%exc(:, :)
    a_d(:, :, 8) = parameters_d%b(:, :)
    a(:, :, 8) = parameters%b(:, :)
    a_d(:, :, 9) = parameters_d%cusl1(:, :)
    a(:, :, 9) = parameters%cusl1(:, :)
    a_d(:, :, 10) = parameters_d%cusl2(:, :)
    a(:, :, 10) = parameters%cusl2(:, :)
    a_d(:, :, 11) = parameters_d%clsl(:, :)
    a(:, :, 11) = parameters%clsl(:, :)
    a_d(:, :, 12) = parameters_d%ks(:, :)
    a(:, :, 12) = parameters%ks(:, :)
    a_d(:, :, 13) = parameters_d%ds(:, :)
    a(:, :, 13) = parameters%ds(:, :)
    a_d(:, :, 14) = parameters_d%dsm(:, :)
    a(:, :, 14) = parameters%dsm(:, :)
    a_d(:, :, 15) = parameters_d%ws(:, :)
    a(:, :, 15) = parameters%ws(:, :)
    a_d(:, :, 16) = parameters_d%lr(:, :)
    a(:, :, 16) = parameters%lr(:, :)
  END SUBROUTINE GET_PARAMETERS_D

!  Differentiation of get_parameters in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) a
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
!%      TODO comment
  SUBROUTINE GET_PARAMETERS_B(mesh, parameters, parameters_b, a, a_b)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(INOUT) :: a_b
    parameters_b%lr = parameters_b%lr + a_b(:, :, 16)
    a_b(:, :, 16) = 0.0_4
    parameters_b%ws = parameters_b%ws + a_b(:, :, 15)
    a_b(:, :, 15) = 0.0_4
    parameters_b%dsm = parameters_b%dsm + a_b(:, :, 14)
    a_b(:, :, 14) = 0.0_4
    parameters_b%ds = parameters_b%ds + a_b(:, :, 13)
    a_b(:, :, 13) = 0.0_4
    parameters_b%ks = parameters_b%ks + a_b(:, :, 12)
    a_b(:, :, 12) = 0.0_4
    parameters_b%clsl = parameters_b%clsl + a_b(:, :, 11)
    a_b(:, :, 11) = 0.0_4
    parameters_b%cusl2 = parameters_b%cusl2 + a_b(:, :, 10)
    a_b(:, :, 10) = 0.0_4
    parameters_b%cusl1 = parameters_b%cusl1 + a_b(:, :, 9)
    a_b(:, :, 9) = 0.0_4
    parameters_b%b = parameters_b%b + a_b(:, :, 8)
    a_b(:, :, 8) = 0.0_4
    parameters_b%exc = parameters_b%exc + a_b(:, :, 7)
    a_b(:, :, 7) = 0.0_4
    parameters_b%alpha = parameters_b%alpha + a_b(:, :, 6)
    a_b(:, :, 6) = 0.0_4
    parameters_b%cst = parameters_b%cst + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    parameters_b%cft = parameters_b%cft + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    parameters_b%beta = parameters_b%beta + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    parameters_b%cp = parameters_b%cp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    parameters_b%ci = parameters_b%ci + a_b(:, :, 1)
  END SUBROUTINE GET_PARAMETERS_B

!%      TODO comment
  SUBROUTINE GET_PARAMETERS(mesh, parameters, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(INOUT) :: a
    a(:, :, 1) = parameters%ci(:, :)
    a(:, :, 2) = parameters%cp(:, :)
    a(:, :, 3) = parameters%beta(:, :)
    a(:, :, 4) = parameters%cft(:, :)
    a(:, :, 5) = parameters%cst(:, :)
    a(:, :, 6) = parameters%alpha(:, :)
    a(:, :, 7) = parameters%exc(:, :)
    a(:, :, 8) = parameters%b(:, :)
    a(:, :, 9) = parameters%cusl1(:, :)
    a(:, :, 10) = parameters%cusl2(:, :)
    a(:, :, 11) = parameters%clsl(:, :)
    a(:, :, 12) = parameters%ks(:, :)
    a(:, :, 13) = parameters%ds(:, :)
    a(:, :, 14) = parameters%dsm(:, :)
    a(:, :, 15) = parameters%ws(:, :)
    a(:, :, 16) = parameters%lr(:, :)
  END SUBROUTINE GET_PARAMETERS

!  Differentiation of set3d_parameters in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) a
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
  SUBROUTINE SET3D_PARAMETERS_D(mesh, parameters, parameters_d, a, a_d)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(IN) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(IN) :: a_d
    parameters_d%ci(:, :) = a_d(:, :, 1)
    parameters%ci(:, :) = a(:, :, 1)
    parameters_d%cp(:, :) = a_d(:, :, 2)
    parameters%cp(:, :) = a(:, :, 2)
    parameters_d%beta(:, :) = a_d(:, :, 3)
    parameters%beta(:, :) = a(:, :, 3)
    parameters_d%cft(:, :) = a_d(:, :, 4)
    parameters%cft(:, :) = a(:, :, 4)
    parameters_d%cst(:, :) = a_d(:, :, 5)
    parameters%cst(:, :) = a(:, :, 5)
    parameters_d%alpha(:, :) = a_d(:, :, 6)
    parameters%alpha(:, :) = a(:, :, 6)
    parameters_d%exc(:, :) = a_d(:, :, 7)
    parameters%exc(:, :) = a(:, :, 7)
    parameters_d%b(:, :) = a_d(:, :, 8)
    parameters%b(:, :) = a(:, :, 8)
    parameters_d%cusl1(:, :) = a_d(:, :, 9)
    parameters%cusl1(:, :) = a(:, :, 9)
    parameters_d%cusl2(:, :) = a_d(:, :, 10)
    parameters%cusl2(:, :) = a(:, :, 10)
    parameters_d%clsl(:, :) = a_d(:, :, 11)
    parameters%clsl(:, :) = a(:, :, 11)
    parameters_d%ks(:, :) = a_d(:, :, 12)
    parameters%ks(:, :) = a(:, :, 12)
    parameters_d%ds(:, :) = a_d(:, :, 13)
    parameters%ds(:, :) = a(:, :, 13)
    parameters_d%dsm(:, :) = a_d(:, :, 14)
    parameters%dsm(:, :) = a(:, :, 14)
    parameters_d%ws(:, :) = a_d(:, :, 15)
    parameters%ws(:, :) = a(:, :, 15)
    parameters_d%lr(:, :) = a_d(:, :, 16)
    parameters%lr(:, :) = a(:, :, 16)
  END SUBROUTINE SET3D_PARAMETERS_D

!  Differentiation of set3d_parameters in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) a
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
  SUBROUTINE SET3D_PARAMETERS_B(mesh, parameters, parameters_b, a, a_b)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(IN) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a_b
    a_b = 0.0_4
    a_b(:, :, 16) = a_b(:, :, 16) + parameters_b%lr
    parameters_b%lr = 0.0_4
    a_b(:, :, 15) = a_b(:, :, 15) + parameters_b%ws
    parameters_b%ws = 0.0_4
    a_b(:, :, 14) = a_b(:, :, 14) + parameters_b%dsm
    parameters_b%dsm = 0.0_4
    a_b(:, :, 13) = a_b(:, :, 13) + parameters_b%ds
    parameters_b%ds = 0.0_4
    a_b(:, :, 12) = a_b(:, :, 12) + parameters_b%ks
    parameters_b%ks = 0.0_4
    a_b(:, :, 11) = a_b(:, :, 11) + parameters_b%clsl
    parameters_b%clsl = 0.0_4
    a_b(:, :, 10) = a_b(:, :, 10) + parameters_b%cusl2
    parameters_b%cusl2 = 0.0_4
    a_b(:, :, 9) = a_b(:, :, 9) + parameters_b%cusl1
    parameters_b%cusl1 = 0.0_4
    a_b(:, :, 8) = a_b(:, :, 8) + parameters_b%b
    parameters_b%b = 0.0_4
    a_b(:, :, 7) = a_b(:, :, 7) + parameters_b%exc
    parameters_b%exc = 0.0_4
    a_b(:, :, 6) = a_b(:, :, 6) + parameters_b%alpha
    parameters_b%alpha = 0.0_4
    a_b(:, :, 5) = a_b(:, :, 5) + parameters_b%cst
    parameters_b%cst = 0.0_4
    a_b(:, :, 4) = a_b(:, :, 4) + parameters_b%cft
    parameters_b%cft = 0.0_4
    a_b(:, :, 3) = a_b(:, :, 3) + parameters_b%beta
    parameters_b%beta = 0.0_4
    a_b(:, :, 2) = a_b(:, :, 2) + parameters_b%cp
    parameters_b%cp = 0.0_4
    a_b(:, :, 1) = a_b(:, :, 1) + parameters_b%ci
    parameters_b%ci = 0.0_4
  END SUBROUTINE SET3D_PARAMETERS_B

  SUBROUTINE SET3D_PARAMETERS(mesh, parameters, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp), INTENT(IN) :: a
    parameters%ci(:, :) = a(:, :, 1)
    parameters%cp(:, :) = a(:, :, 2)
    parameters%beta(:, :) = a(:, :, 3)
    parameters%cft(:, :) = a(:, :, 4)
    parameters%cst(:, :) = a(:, :, 5)
    parameters%alpha(:, :) = a(:, :, 6)
    parameters%exc(:, :) = a(:, :, 7)
    parameters%b(:, :) = a(:, :, 8)
    parameters%cusl1(:, :) = a(:, :, 9)
    parameters%cusl2(:, :) = a(:, :, 10)
    parameters%clsl(:, :) = a(:, :, 11)
    parameters%ks(:, :) = a(:, :, 12)
    parameters%ds(:, :) = a(:, :, 13)
    parameters%dsm(:, :) = a(:, :, 14)
    parameters%ws(:, :) = a(:, :, 15)
    parameters%lr(:, :) = a(:, :, 16)
  END SUBROUTINE SET3D_PARAMETERS

  SUBROUTINE SET1D_PARAMETERS(mesh, parameters, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(gnp), INTENT(IN) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a3d
    INTEGER :: i
    DO i=1,gnp
      a3d(:, :, i) = a(i)
    END DO
    CALL SET3D_PARAMETERS(mesh, parameters, a3d)
  END SUBROUTINE SET1D_PARAMETERS

  SUBROUTINE SET0D_PARAMETERS(mesh, parameters, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(gnp) :: a1d
    a1d(:) = a
    CALL SET1D_PARAMETERS(mesh, parameters, a1d)
  END SUBROUTINE SET0D_PARAMETERS

!  Differentiation of normalize_parameters in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
  SUBROUTINE NORMALIZE_PARAMETERS_D(setup, mesh, parameters, &
&   parameters_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a_d
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_PARAMETERS_D(mesh, parameters, parameters_d, a, a_d)
    DO i=1,gnp
      lb = setup%optimize%lb_parameters(i)
      ub = setup%optimize%ub_parameters(i)
      a_d(:, :, i) = a_d(:, :, i)/(ub-lb)
      a(:, :, i) = (a(:, :, i)-lb)/(ub-lb)
    END DO
    CALL SET_PARAMETERS_D(mesh, parameters, parameters_d, a, a_d)
  END SUBROUTINE NORMALIZE_PARAMETERS_D

!  Differentiation of normalize_parameters in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
  SUBROUTINE NORMALIZE_PARAMETERS_B(setup, mesh, parameters, &
&   parameters_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a_b
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_PARAMETERS(mesh, parameters, a)
    DO i=1,gnp
      lb = setup%optimize%lb_parameters(i)
      ub = setup%optimize%ub_parameters(i)
    END DO
    CALL PUSHREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&                 parameters%ci, 2))
    CALL PUSHREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&                 parameters%cp, 2))
    CALL PUSHREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&                 parameters%cft, 2))
    CALL PUSHREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&                 parameters%cst, 2))
    CALL PUSHREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&                 parameters%exc, 2))
    CALL PUSHREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&                 parameters%b, 2))
    CALL PUSHREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*SIZE&
&                 (parameters%cusl1, 2))
    CALL PUSHREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*SIZE&
&                 (parameters%cusl2, 2))
    CALL PUSHREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&                 parameters%clsl, 2))
    CALL PUSHREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&                 parameters%ks, 2))
    CALL PUSHREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&                 parameters%ds, 2))
    CALL PUSHREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&                 parameters%dsm, 2))
    CALL PUSHREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&                 parameters%ws, 2))
    CALL PUSHREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&                 parameters%lr, 2))
    CALL SET_PARAMETERS(mesh, parameters, a)
    CALL POPREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&                parameters%lr, 2))
    CALL POPREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&                parameters%ws, 2))
    CALL POPREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&                parameters%dsm, 2))
    CALL POPREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&                parameters%ds, 2))
    CALL POPREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&                parameters%ks, 2))
    CALL POPREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&                parameters%clsl, 2))
    CALL POPREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*SIZE(&
&                parameters%cusl2, 2))
    CALL POPREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*SIZE(&
&                parameters%cusl1, 2))
    CALL POPREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&                parameters%b, 2))
    CALL POPREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&                parameters%exc, 2))
    CALL POPREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&                parameters%cst, 2))
    CALL POPREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&                parameters%cft, 2))
    CALL POPREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&                parameters%cp, 2))
    CALL POPREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&                parameters%ci, 2))
    CALL SET_PARAMETERS_B(mesh, parameters, parameters_b, a, a_b)
    DO i=gnp,1,-1
      ub = setup%optimize%ub_parameters(i)
      lb = setup%optimize%lb_parameters(i)
      a_b(:, :, i) = a_b(:, :, i)/(ub-lb)
    END DO
    CALL GET_PARAMETERS_B(mesh, parameters, parameters_b, a, a_b)
  END SUBROUTINE NORMALIZE_PARAMETERS_B

  SUBROUTINE NORMALIZE_PARAMETERS(setup, mesh, parameters)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_PARAMETERS(mesh, parameters, a)
    DO i=1,gnp
      lb = setup%optimize%lb_parameters(i)
      ub = setup%optimize%ub_parameters(i)
      a(:, :, i) = (a(:, :, i)-lb)/(ub-lb)
    END DO
    CALL SET_PARAMETERS(mesh, parameters, a)
  END SUBROUTINE NORMALIZE_PARAMETERS

!  Differentiation of denormalize_parameters in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
  SUBROUTINE DENORMALIZE_PARAMETERS_D(setup, mesh, parameters, &
&   parameters_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a_d
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_PARAMETERS_D(mesh, parameters, parameters_d, a, a_d)
    DO i=1,gnp
      lb = setup%optimize%lb_parameters(i)
      ub = setup%optimize%ub_parameters(i)
      a_d(:, :, i) = (ub-lb)*a_d(:, :, i)
      a(:, :, i) = a(:, :, i)*(ub-lb) + lb
    END DO
    CALL SET_PARAMETERS_D(mesh, parameters, parameters_d, a, a_d)
  END SUBROUTINE DENORMALIZE_PARAMETERS_D

!  Differentiation of denormalize_parameters in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in
  SUBROUTINE DENORMALIZE_PARAMETERS_B(setup, mesh, parameters, &
&   parameters_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a_b
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_PARAMETERS(mesh, parameters, a)
    DO i=1,gnp
      lb = setup%optimize%lb_parameters(i)
      ub = setup%optimize%ub_parameters(i)
    END DO
    CALL PUSHREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&                 parameters%ci, 2))
    CALL PUSHREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&                 parameters%cp, 2))
    CALL PUSHREAL4ARRAY(parameters%beta, SIZE(parameters%beta, 1)*SIZE(&
&                 parameters%beta, 2))
    CALL PUSHREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&                 parameters%cft, 2))
    CALL PUSHREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&                 parameters%cst, 2))
    CALL PUSHREAL4ARRAY(parameters%alpha, SIZE(parameters%alpha, 1)*SIZE&
&                 (parameters%alpha, 2))
    CALL PUSHREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&                 parameters%exc, 2))
    CALL PUSHREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&                 parameters%b, 2))
    CALL PUSHREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*SIZE&
&                 (parameters%cusl1, 2))
    CALL PUSHREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*SIZE&
&                 (parameters%cusl2, 2))
    CALL PUSHREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&                 parameters%clsl, 2))
    CALL PUSHREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&                 parameters%ks, 2))
    CALL PUSHREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&                 parameters%ds, 2))
    CALL PUSHREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&                 parameters%dsm, 2))
    CALL PUSHREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&                 parameters%ws, 2))
    CALL PUSHREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&                 parameters%lr, 2))
    CALL SET_PARAMETERS(mesh, parameters, a)
    CALL POPREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&                parameters%lr, 2))
    CALL POPREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&                parameters%ws, 2))
    CALL POPREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&                parameters%dsm, 2))
    CALL POPREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&                parameters%ds, 2))
    CALL POPREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&                parameters%ks, 2))
    CALL POPREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&                parameters%clsl, 2))
    CALL POPREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*SIZE(&
&                parameters%cusl2, 2))
    CALL POPREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*SIZE(&
&                parameters%cusl1, 2))
    CALL POPREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&                parameters%b, 2))
    CALL POPREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&                parameters%exc, 2))
    CALL POPREAL4ARRAY(parameters%alpha, SIZE(parameters%alpha, 1)*SIZE(&
&                parameters%alpha, 2))
    CALL POPREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&                parameters%cst, 2))
    CALL POPREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&                parameters%cft, 2))
    CALL POPREAL4ARRAY(parameters%beta, SIZE(parameters%beta, 1)*SIZE(&
&                parameters%beta, 2))
    CALL POPREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&                parameters%cp, 2))
    CALL POPREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&                parameters%ci, 2))
    CALL SET_PARAMETERS_B(mesh, parameters, parameters_b, a, a_b)
    DO i=gnp,1,-1
      ub = setup%optimize%ub_parameters(i)
      lb = setup%optimize%lb_parameters(i)
      a_b(:, :, i) = (ub-lb)*a_b(:, :, i)
    END DO
    CALL GET_PARAMETERS_B(mesh, parameters, parameters_b, a, a_b)
  END SUBROUTINE DENORMALIZE_PARAMETERS_B

  SUBROUTINE DENORMALIZE_PARAMETERS(setup, mesh, parameters)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: a
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_PARAMETERS(mesh, parameters, a)
    DO i=1,gnp
      lb = setup%optimize%lb_parameters(i)
      ub = setup%optimize%ub_parameters(i)
      a(:, :, i) = a(:, :, i)*(ub-lb) + lb
    END DO
    CALL SET_PARAMETERS(mesh, parameters, a)
  END SUBROUTINE DENORMALIZE_PARAMETERS

!  Differentiation of get_hyper_parameters in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: a
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.b)
!                *(hyper_parameters.cusl1) *(hyper_parameters.cusl2)
!                *(hyper_parameters.clsl) *(hyper_parameters.ks)
!                *(hyper_parameters.ds) *(hyper_parameters.dsm)
!                *(hyper_parameters.ws) *(hyper_parameters.lr)
!   Plus diff mem management of: hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.b:in
!                hyper_parameters.cusl1:in hyper_parameters.cusl2:in
!                hyper_parameters.clsl:in hyper_parameters.ks:in
!                hyper_parameters.ds:in hyper_parameters.dsm:in
!                hyper_parameters.ws:in hyper_parameters.lr:in
  SUBROUTINE GET_HYPER_PARAMETERS_D(setup, hyper_parameters, &
&   hyper_parameters_d, a, a_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters_d
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp), INTENT(INOUT) ::&
&   a
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp), INTENT(INOUT) ::&
&   a_d
    a_d = 0.0_4
    a_d(:, :, 1) = hyper_parameters_d%ci(:, :)
    a(:, :, 1) = hyper_parameters%ci(:, :)
    a_d(:, :, 2) = hyper_parameters_d%cp(:, :)
    a(:, :, 2) = hyper_parameters%cp(:, :)
    a_d(:, :, 3) = hyper_parameters_d%beta(:, :)
    a(:, :, 3) = hyper_parameters%beta(:, :)
    a_d(:, :, 4) = hyper_parameters_d%cft(:, :)
    a(:, :, 4) = hyper_parameters%cft(:, :)
    a_d(:, :, 5) = hyper_parameters_d%cst(:, :)
    a(:, :, 5) = hyper_parameters%cst(:, :)
    a_d(:, :, 6) = hyper_parameters_d%alpha(:, :)
    a(:, :, 6) = hyper_parameters%alpha(:, :)
    a_d(:, :, 7) = hyper_parameters_d%exc(:, :)
    a(:, :, 7) = hyper_parameters%exc(:, :)
    a_d(:, :, 8) = hyper_parameters_d%b(:, :)
    a(:, :, 8) = hyper_parameters%b(:, :)
    a_d(:, :, 9) = hyper_parameters_d%cusl1(:, :)
    a(:, :, 9) = hyper_parameters%cusl1(:, :)
    a_d(:, :, 10) = hyper_parameters_d%cusl2(:, :)
    a(:, :, 10) = hyper_parameters%cusl2(:, :)
    a_d(:, :, 11) = hyper_parameters_d%clsl(:, :)
    a(:, :, 11) = hyper_parameters%clsl(:, :)
    a_d(:, :, 12) = hyper_parameters_d%ks(:, :)
    a(:, :, 12) = hyper_parameters%ks(:, :)
    a_d(:, :, 13) = hyper_parameters_d%ds(:, :)
    a(:, :, 13) = hyper_parameters%ds(:, :)
    a_d(:, :, 14) = hyper_parameters_d%dsm(:, :)
    a(:, :, 14) = hyper_parameters%dsm(:, :)
    a_d(:, :, 15) = hyper_parameters_d%ws(:, :)
    a(:, :, 15) = hyper_parameters%ws(:, :)
    a_d(:, :, 16) = hyper_parameters_d%lr(:, :)
    a(:, :, 16) = hyper_parameters%lr(:, :)
  END SUBROUTINE GET_HYPER_PARAMETERS_D

!  Differentiation of get_hyper_parameters in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: a
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.b)
!                *(hyper_parameters.cusl1) *(hyper_parameters.cusl2)
!                *(hyper_parameters.clsl) *(hyper_parameters.ks)
!                *(hyper_parameters.ds) *(hyper_parameters.dsm)
!                *(hyper_parameters.ws) *(hyper_parameters.lr)
!   Plus diff mem management of: hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.b:in
!                hyper_parameters.cusl1:in hyper_parameters.cusl2:in
!                hyper_parameters.clsl:in hyper_parameters.ks:in
!                hyper_parameters.ds:in hyper_parameters.dsm:in
!                hyper_parameters.ws:in hyper_parameters.lr:in
  SUBROUTINE GET_HYPER_PARAMETERS_B(setup, hyper_parameters, &
&   hyper_parameters_b, a, a_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT) :: hyper_parameters_b
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp), INTENT(INOUT) ::&
&   a
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp), INTENT(INOUT) ::&
&   a_b
    hyper_parameters_b%lr = 0.0_4
    hyper_parameters_b%lr = hyper_parameters_b%lr + a_b(:, :, 16)
    a_b(:, :, 16) = 0.0_4
    hyper_parameters_b%ws = 0.0_4
    hyper_parameters_b%ws = hyper_parameters_b%ws + a_b(:, :, 15)
    a_b(:, :, 15) = 0.0_4
    hyper_parameters_b%dsm = 0.0_4
    hyper_parameters_b%dsm = hyper_parameters_b%dsm + a_b(:, :, 14)
    a_b(:, :, 14) = 0.0_4
    hyper_parameters_b%ds = 0.0_4
    hyper_parameters_b%ds = hyper_parameters_b%ds + a_b(:, :, 13)
    a_b(:, :, 13) = 0.0_4
    hyper_parameters_b%ks = 0.0_4
    hyper_parameters_b%ks = hyper_parameters_b%ks + a_b(:, :, 12)
    a_b(:, :, 12) = 0.0_4
    hyper_parameters_b%clsl = 0.0_4
    hyper_parameters_b%clsl = hyper_parameters_b%clsl + a_b(:, :, 11)
    a_b(:, :, 11) = 0.0_4
    hyper_parameters_b%cusl2 = 0.0_4
    hyper_parameters_b%cusl2 = hyper_parameters_b%cusl2 + a_b(:, :, 10)
    a_b(:, :, 10) = 0.0_4
    hyper_parameters_b%cusl1 = 0.0_4
    hyper_parameters_b%cusl1 = hyper_parameters_b%cusl1 + a_b(:, :, 9)
    a_b(:, :, 9) = 0.0_4
    hyper_parameters_b%b = 0.0_4
    hyper_parameters_b%b = hyper_parameters_b%b + a_b(:, :, 8)
    a_b(:, :, 8) = 0.0_4
    hyper_parameters_b%exc = 0.0_4
    hyper_parameters_b%exc = hyper_parameters_b%exc + a_b(:, :, 7)
    a_b(:, :, 7) = 0.0_4
    hyper_parameters_b%alpha = 0.0_4
    hyper_parameters_b%alpha = hyper_parameters_b%alpha + a_b(:, :, 6)
    a_b(:, :, 6) = 0.0_4
    hyper_parameters_b%cst = 0.0_4
    hyper_parameters_b%cst = hyper_parameters_b%cst + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    hyper_parameters_b%cft = 0.0_4
    hyper_parameters_b%cft = hyper_parameters_b%cft + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    hyper_parameters_b%beta = 0.0_4
    hyper_parameters_b%beta = hyper_parameters_b%beta + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    hyper_parameters_b%cp = 0.0_4
    hyper_parameters_b%cp = hyper_parameters_b%cp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    hyper_parameters_b%ci = 0.0_4
    hyper_parameters_b%ci = hyper_parameters_b%ci + a_b(:, :, 1)
  END SUBROUTINE GET_HYPER_PARAMETERS_B

  SUBROUTINE GET_HYPER_PARAMETERS(setup, hyper_parameters, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp), INTENT(INOUT) ::&
&   a
    a(:, :, 1) = hyper_parameters%ci(:, :)
    a(:, :, 2) = hyper_parameters%cp(:, :)
    a(:, :, 3) = hyper_parameters%beta(:, :)
    a(:, :, 4) = hyper_parameters%cft(:, :)
    a(:, :, 5) = hyper_parameters%cst(:, :)
    a(:, :, 6) = hyper_parameters%alpha(:, :)
    a(:, :, 7) = hyper_parameters%exc(:, :)
    a(:, :, 8) = hyper_parameters%b(:, :)
    a(:, :, 9) = hyper_parameters%cusl1(:, :)
    a(:, :, 10) = hyper_parameters%cusl2(:, :)
    a(:, :, 11) = hyper_parameters%clsl(:, :)
    a(:, :, 12) = hyper_parameters%ks(:, :)
    a(:, :, 13) = hyper_parameters%ds(:, :)
    a(:, :, 14) = hyper_parameters%dsm(:, :)
    a(:, :, 15) = hyper_parameters%ws(:, :)
    a(:, :, 16) = hyper_parameters%lr(:, :)
  END SUBROUTINE GET_HYPER_PARAMETERS

  SUBROUTINE SET3D_HYPER_PARAMETERS(setup, hyper_parameters, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: hyper_parameters
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp), INTENT(IN) :: a
    hyper_parameters%ci(:, :) = a(:, :, 1)
    hyper_parameters%cp(:, :) = a(:, :, 2)
    hyper_parameters%beta(:, :) = a(:, :, 3)
    hyper_parameters%cft(:, :) = a(:, :, 4)
    hyper_parameters%cst(:, :) = a(:, :, 5)
    hyper_parameters%alpha(:, :) = a(:, :, 6)
    hyper_parameters%exc(:, :) = a(:, :, 7)
    hyper_parameters%b(:, :) = a(:, :, 8)
    hyper_parameters%cusl1(:, :) = a(:, :, 9)
    hyper_parameters%cusl2(:, :) = a(:, :, 10)
    hyper_parameters%clsl(:, :) = a(:, :, 11)
    hyper_parameters%ks(:, :) = a(:, :, 12)
    hyper_parameters%ds(:, :) = a(:, :, 13)
    hyper_parameters%dsm(:, :) = a(:, :, 14)
    hyper_parameters%ws(:, :) = a(:, :, 15)
    hyper_parameters%lr(:, :) = a(:, :, 16)
  END SUBROUTINE SET3D_HYPER_PARAMETERS

  SUBROUTINE SET1D_HYPER_PARAMETERS(setup, hyper_parameters, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: hyper_parameters
    REAL(sp), DIMENSION(gnp), INTENT(IN) :: a
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp) :: a3d
    INTEGER :: i
    DO i=1,gnp
      a3d(:, :, i) = a(i)
    END DO
    CALL SET3D_HYPER_PARAMETERS(setup, hyper_parameters, a3d)
  END SUBROUTINE SET1D_HYPER_PARAMETERS

  SUBROUTINE SET0D_HYPER_PARAMETERS(setup, hyper_parameters, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_PARAMETERSDT), INTENT(INOUT) :: hyper_parameters
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(gnp) :: a1d
    a1d(:) = a
    CALL SET1D_HYPER_PARAMETERS(setup, hyper_parameters, a1d)
  END SUBROUTINE SET0D_HYPER_PARAMETERS

!  Differentiation of hyper_parameters_to_parameters in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.cst) *(parameters.exc)
!                *(parameters.b) *(parameters.cusl1) *(parameters.cusl2)
!                *(parameters.clsl) *(parameters.ks) *(parameters.ds)
!                *(parameters.dsm) *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.b)
!                *(hyper_parameters.cusl1) *(hyper_parameters.cusl2)
!                *(hyper_parameters.clsl) *(hyper_parameters.ks)
!                *(hyper_parameters.ds) *(hyper_parameters.dsm)
!                *(hyper_parameters.ws) *(hyper_parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in hyper_parameters.ci:in
!                hyper_parameters.cp:in hyper_parameters.beta:in
!                hyper_parameters.cft:in hyper_parameters.cst:in
!                hyper_parameters.alpha:in hyper_parameters.exc:in
!                hyper_parameters.b:in hyper_parameters.cusl1:in
!                hyper_parameters.cusl2:in hyper_parameters.clsl:in
!                hyper_parameters.ks:in hyper_parameters.ds:in
!                hyper_parameters.dsm:in hyper_parameters.ws:in
!                hyper_parameters.lr:in
!%      TODO comment
  SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_D(hyper_parameters, &
&   hyper_parameters_d, parameters, parameters_d, setup, mesh, &
&   input_data)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters_d
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp) :: &
&   hyper_parameters_matrix
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp) :: &
&   hyper_parameters_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: &
&   parameters_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: d, dpb
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: dpb_d
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_d, b_d
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: temp
    CALL GET_HYPER_PARAMETERS_D(setup, hyper_parameters, &
&                         hyper_parameters_d, hyper_parameters_matrix, &
&                         hyper_parameters_matrix_d)
    CALL GET_PARAMETERS(mesh, parameters, parameters_matrix)
    parameters_matrix_d = 0.0_4
    a_d = 0.0_4
    b_d = 0.0_4
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,gnp
      parameters_matrix_d(:, :, i) = hyper_parameters_matrix_d(1, 1, i)
      parameters_matrix(:, :, i) = hyper_parameters_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a_d = hyper_parameters_matrix_d(j+1, 1, i)
          a = hyper_parameters_matrix(j+1, 1, i)
          b = 1._sp
          b_d = 0.0_4
        CASE ('hyper-polynomial') 
          a_d = hyper_parameters_matrix_d(2*j, 1, i)
          a = hyper_parameters_matrix(2*j, 1, i)
          b_d = hyper_parameters_matrix_d(2*j+1, 1, i)
          b = hyper_parameters_matrix(2*j+1, 1, i)
        END SELECT
        temp = d**b
        WHERE (d .LE. 0.0) 
          dpb_d = 0.0_4
        ELSEWHERE
          dpb_d = temp*LOG(d)*b_d
        END WHERE
        dpb = temp
        parameters_matrix_d(:, :, i) = parameters_matrix_d(:, :, i) + &
&         dpb*a_d + a*dpb_d
        parameters_matrix(:, :, i) = parameters_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      temp = (setup%optimize%ub_parameters(i)-setup%optimize%&
&       lb_parameters(i))/(EXP(-parameters_matrix(:, :, i))+1._sp)
      parameters_matrix_d(:, :, i) = temp*EXP(-parameters_matrix(:, :, i&
&       ))*parameters_matrix_d(:, :, i)/(EXP(-parameters_matrix(:, :, i)&
&       )+1._sp)
      parameters_matrix(:, :, i) = setup%optimize%lb_parameters(i) + &
&       temp
    END DO
    parameters_d%ci = 0.0_4
    parameters_d%cp = 0.0_4
    parameters_d%beta = 0.0_4
    parameters_d%cft = 0.0_4
    parameters_d%cst = 0.0_4
    parameters_d%alpha = 0.0_4
    parameters_d%exc = 0.0_4
    parameters_d%b = 0.0_4
    parameters_d%cusl1 = 0.0_4
    parameters_d%cusl2 = 0.0_4
    parameters_d%clsl = 0.0_4
    parameters_d%ks = 0.0_4
    parameters_d%ds = 0.0_4
    parameters_d%dsm = 0.0_4
    parameters_d%ws = 0.0_4
    parameters_d%lr = 0.0_4
    CALL SET_PARAMETERS_D(mesh, parameters, parameters_d, &
&                   parameters_matrix, parameters_matrix_d)
  END SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_D

!  Differentiation of hyper_parameters_to_parameters in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.cst) *(parameters.exc)
!                *(parameters.b) *(parameters.cusl1) *(parameters.cusl2)
!                *(parameters.clsl) *(parameters.ks) *(parameters.ds)
!                *(parameters.dsm) *(parameters.ws) *(parameters.lr)
!   with respect to varying inputs: *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.b)
!                *(hyper_parameters.cusl1) *(hyper_parameters.cusl2)
!                *(hyper_parameters.clsl) *(hyper_parameters.ks)
!                *(hyper_parameters.ds) *(hyper_parameters.dsm)
!                *(hyper_parameters.ws) *(hyper_parameters.lr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in hyper_parameters.ci:in
!                hyper_parameters.cp:in hyper_parameters.beta:in
!                hyper_parameters.cft:in hyper_parameters.cst:in
!                hyper_parameters.alpha:in hyper_parameters.exc:in
!                hyper_parameters.b:in hyper_parameters.cusl1:in
!                hyper_parameters.cusl2:in hyper_parameters.clsl:in
!                hyper_parameters.ks:in hyper_parameters.ds:in
!                hyper_parameters.dsm:in hyper_parameters.ws:in
!                hyper_parameters.lr:in
!%      TODO comment
  SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_B(hyper_parameters, &
&   hyper_parameters_b, parameters, parameters_b, setup, mesh, &
&   input_data)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(HYPER_PARAMETERSDT) :: hyper_parameters_b
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp) :: &
&   hyper_parameters_matrix
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp) :: &
&   hyper_parameters_matrix_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: &
&   parameters_matrix_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: d, dpb
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: dpb_b
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_b, b_b
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: temp
    INTEGER :: branch
    CALL GET_HYPER_PARAMETERS(setup, hyper_parameters, &
&                       hyper_parameters_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,gnp
      parameters_matrix(:, :, i) = hyper_parameters_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          CALL PUSHREAL4(a)
          a = hyper_parameters_matrix(j+1, 1, i)
          CALL PUSHREAL4(b)
          b = 1._sp
          CALL PUSHCONTROL2B(1)
        CASE ('hyper-polynomial') 
          CALL PUSHREAL4(a)
          a = hyper_parameters_matrix(2*j, 1, i)
          CALL PUSHREAL4(b)
          b = hyper_parameters_matrix(2*j+1, 1, i)
          CALL PUSHCONTROL2B(2)
        CASE DEFAULT
          CALL PUSHCONTROL2B(0)
        END SELECT
        dpb = d**b
        parameters_matrix(:, :, i) = parameters_matrix(:, :, i) + a*dpb
      END DO
    END DO
    CALL SET_PARAMETERS(mesh, parameters, parameters_matrix)
    parameters_b%beta = 0.0_4
    parameters_b%alpha = 0.0_4
    CALL SET_PARAMETERS_B(mesh, parameters, parameters_b, &
&                   parameters_matrix, parameters_matrix_b)
    hyper_parameters_matrix_b = 0.0_4
    a_b = 0.0_4
    b_b = 0.0_4
    DO i=gnp,1,-1
      temp = EXP(-parameters_matrix(:, :, i)) + 1._sp
      parameters_matrix_b(:, :, i) = EXP(-parameters_matrix(:, :, i))*(&
&       setup%optimize%ub_parameters(i)-setup%optimize%lb_parameters(i))&
&       *parameters_matrix_b(:, :, i)/temp**2
      DO j=setup%nd,1,-1
        d = input_data%descriptor(:, :, j)
        dpb = d**b
        dpb_b = 0.0_4
        a_b = a_b + SUM(dpb*parameters_matrix_b(:, :, i))
        dpb_b = a*parameters_matrix_b(:, :, i)
        b_b = b_b + SUM(d**b*LOG(d)*dpb_b, MASK=.NOT.d.LE.0.0)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            CALL POPREAL4(b)
            CALL POPREAL4(a)
            hyper_parameters_matrix_b(j+1, 1, i) = &
&             hyper_parameters_matrix_b(j+1, 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          ELSE
            CALL POPREAL4(b)
            hyper_parameters_matrix_b(2*j+1, 1, i) = &
&             hyper_parameters_matrix_b(2*j+1, 1, i) + b_b
            CALL POPREAL4(a)
            hyper_parameters_matrix_b(2*j, 1, i) = &
&             hyper_parameters_matrix_b(2*j, 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          END IF
        END IF
      END DO
      hyper_parameters_matrix_b(1, 1, i) = hyper_parameters_matrix_b(1, &
&       1, i) + SUM(parameters_matrix_b(:, :, i))
      parameters_matrix_b(:, :, i) = 0.0_4
    END DO
    CALL GET_HYPER_PARAMETERS_B(setup, hyper_parameters, &
&                         hyper_parameters_b, hyper_parameters_matrix, &
&                         hyper_parameters_matrix_b)
  END SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS_B

!%      TODO comment
  SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS(hyper_parameters, parameters&
&   , setup, mesh, input_data)
    IMPLICIT NONE
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gnp) :: &
&   hyper_parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: d, dpb
    INTEGER :: i, j
    REAL(sp) :: a, b
    INTRINSIC TRIM
    INTRINSIC EXP
    CALL GET_HYPER_PARAMETERS(setup, hyper_parameters, &
&                       hyper_parameters_matrix)
    CALL GET_PARAMETERS(mesh, parameters, parameters_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,gnp
      parameters_matrix(:, :, i) = hyper_parameters_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a = hyper_parameters_matrix(j+1, 1, i)
          b = 1._sp
        CASE ('hyper-polynomial') 
          a = hyper_parameters_matrix(2*j, 1, i)
          b = hyper_parameters_matrix(2*j+1, 1, i)
        END SELECT
        dpb = d**b
        parameters_matrix(:, :, i) = parameters_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      parameters_matrix(:, :, i) = (setup%optimize%ub_parameters(i)-&
&       setup%optimize%lb_parameters(i))*(1._sp/(1._sp+EXP(-&
&       parameters_matrix(:, :, i)))) + setup%optimize%lb_parameters(i)
    END DO
    CALL SET_PARAMETERS(mesh, parameters, parameters_matrix)
  END SUBROUTINE HYPER_PARAMETERS_TO_PARAMETERS

END MODULE MWD_PARAMETERS_MANIPULATION_DIFF

!%      This module `mwd_states_manipulation` encapsulates all SMASH states manipulation.
!%      This module is wrapped and differentiated.
!%
!%      set_states interface:
!%
!%      module procedure set0d_states
!%      module procedure set1d_states
!%      module procedure set3d_states
!%
!%      set_hyper_states interface:
!%
!%      module procedure set0d_hyper_states
!%      module procedure set1d_hyper_states
!%      module procedure set3d_hyper_states
!%
!%      contains
!%
!%      [1]   get_states
!%      [2]   set0d_states
!%      [3]   set1d_states
!%      [4]   set3d_states
!%      [5]   normalize_states
!%      [6]   denormalize_states
!%      [7]   get_hyper_states
!%      [8]   set0d_hyper_states
!%      [9]   set1d_hyper_states
!%      [10]  set3d_hyper_states
!%      [11]  hyper_states_to_states
MODULE MWD_STATES_MANIPULATION_DIFF
  USE MD_CONSTANT
  USE MWD_SETUP
  USE MWD_INPUT_DATA
  USE MWD_STATES_DIFF
  IMPLICIT NONE
  INTERFACE SET_STATES
      MODULE PROCEDURE SET0D_STATES
      MODULE PROCEDURE SET1D_STATES
      MODULE PROCEDURE SET3D_STATES
  END INTERFACE SET_STATES

  INTERFACE SET_STATES_D
      MODULE PROCEDURE SET3D_STATES_D
  END INTERFACE

  INTERFACE SET_STATES_B
      MODULE PROCEDURE SET3D_STATES_B
  END INTERFACE

  INTERFACE SET_HYPER_STATES
      MODULE PROCEDURE SET0D_HYPER_STATES
      MODULE PROCEDURE SET1D_HYPER_STATES
      MODULE PROCEDURE SET3D_HYPER_STATES
  END INTERFACE SET_HYPER_STATES


CONTAINS
!  Differentiation of get_states in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: a
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
!%      TODO comment
  SUBROUTINE GET_STATES_D(mesh, states, states_d, a, a_d)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(STATESDT), INTENT(IN) :: states_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(INOUT) :: a_d
    a_d = 0.0_4
    a_d(:, :, 1) = states_d%hi(:, :)
    a(:, :, 1) = states%hi(:, :)
    a_d(:, :, 2) = states_d%hp(:, :)
    a(:, :, 2) = states%hp(:, :)
    a_d(:, :, 3) = states_d%hft(:, :)
    a(:, :, 3) = states%hft(:, :)
    a_d(:, :, 4) = states_d%hst(:, :)
    a(:, :, 4) = states%hst(:, :)
    a_d(:, :, 5) = states_d%husl1(:, :)
    a(:, :, 5) = states%husl1(:, :)
    a_d(:, :, 6) = states_d%husl2(:, :)
    a(:, :, 6) = states%husl2(:, :)
    a_d(:, :, 7) = states_d%hlsl(:, :)
    a(:, :, 7) = states%hlsl(:, :)
    a_d(:, :, 8) = states_d%hlr(:, :)
    a(:, :, 8) = states%hlr(:, :)
  END SUBROUTINE GET_STATES_D

!  Differentiation of get_states in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr) a
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
!%      TODO comment
  SUBROUTINE GET_STATES_B(mesh, states, states_b, a, a_b)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(IN) :: states
    TYPE(STATESDT) :: states_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(INOUT) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(INOUT) :: a_b
    states_b%hlr = states_b%hlr + a_b(:, :, 8)
    a_b(:, :, 8) = 0.0_4
    states_b%hlsl = states_b%hlsl + a_b(:, :, 7)
    a_b(:, :, 7) = 0.0_4
    states_b%husl2 = states_b%husl2 + a_b(:, :, 6)
    a_b(:, :, 6) = 0.0_4
    states_b%husl1 = states_b%husl1 + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    states_b%hst = states_b%hst + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    states_b%hft = states_b%hft + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    states_b%hp = states_b%hp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    states_b%hi = states_b%hi + a_b(:, :, 1)
  END SUBROUTINE GET_STATES_B

!%      TODO comment
  SUBROUTINE GET_STATES(mesh, states, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(IN) :: states
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(INOUT) :: a
    a(:, :, 1) = states%hi(:, :)
    a(:, :, 2) = states%hp(:, :)
    a(:, :, 3) = states%hft(:, :)
    a(:, :, 4) = states%hst(:, :)
    a(:, :, 5) = states%husl1(:, :)
    a(:, :, 6) = states%husl2(:, :)
    a(:, :, 7) = states%hlsl(:, :)
    a(:, :, 8) = states%hlr(:, :)
  END SUBROUTINE GET_STATES

!  Differentiation of set3d_states in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr) a
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
  SUBROUTINE SET3D_STATES_D(mesh, states, states_d, a, a_d)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(IN) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(IN) :: a_d
    states_d%hi(:, :) = a_d(:, :, 1)
    states%hi(:, :) = a(:, :, 1)
    states_d%hp(:, :) = a_d(:, :, 2)
    states%hp(:, :) = a(:, :, 2)
    states_d%hft(:, :) = a_d(:, :, 3)
    states%hft(:, :) = a(:, :, 3)
    states_d%hst(:, :) = a_d(:, :, 4)
    states%hst(:, :) = a(:, :, 4)
    states_d%husl1(:, :) = a_d(:, :, 5)
    states%husl1(:, :) = a(:, :, 5)
    states_d%husl2(:, :) = a_d(:, :, 6)
    states%husl2(:, :) = a(:, :, 6)
    states_d%hlsl(:, :) = a_d(:, :, 7)
    states%hlsl(:, :) = a(:, :, 7)
    states_d%hlr(:, :) = a_d(:, :, 8)
    states%hlr(:, :) = a(:, :, 8)
  END SUBROUTINE SET3D_STATES_D

!  Differentiation of set3d_states in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr) a
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
  SUBROUTINE SET3D_STATES_B(mesh, states, states_b, a, a_b)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(IN) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a_b
    a_b = 0.0_4
    a_b(:, :, 8) = a_b(:, :, 8) + states_b%hlr
    states_b%hlr = 0.0_4
    a_b(:, :, 7) = a_b(:, :, 7) + states_b%hlsl
    states_b%hlsl = 0.0_4
    a_b(:, :, 6) = a_b(:, :, 6) + states_b%husl2
    states_b%husl2 = 0.0_4
    a_b(:, :, 5) = a_b(:, :, 5) + states_b%husl1
    states_b%husl1 = 0.0_4
    a_b(:, :, 4) = a_b(:, :, 4) + states_b%hst
    states_b%hst = 0.0_4
    a_b(:, :, 3) = a_b(:, :, 3) + states_b%hft
    states_b%hft = 0.0_4
    a_b(:, :, 2) = a_b(:, :, 2) + states_b%hp
    states_b%hp = 0.0_4
    a_b(:, :, 1) = a_b(:, :, 1) + states_b%hi
    states_b%hi = 0.0_4
  END SUBROUTINE SET3D_STATES_B

  SUBROUTINE SET3D_STATES(mesh, states, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns), INTENT(IN) :: a
    states%hi(:, :) = a(:, :, 1)
    states%hp(:, :) = a(:, :, 2)
    states%hft(:, :) = a(:, :, 3)
    states%hst(:, :) = a(:, :, 4)
    states%husl1(:, :) = a(:, :, 5)
    states%husl2(:, :) = a(:, :, 6)
    states%hlsl(:, :) = a(:, :, 7)
    states%hlr(:, :) = a(:, :, 8)
  END SUBROUTINE SET3D_STATES

  SUBROUTINE SET1D_STATES(mesh, states, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(gns), INTENT(IN) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a3d
    INTEGER :: i
    DO i=1,gns
      a3d(:, :, i) = a(i)
    END DO
    CALL SET3D_STATES(mesh, states, a3d)
  END SUBROUTINE SET1D_STATES

  SUBROUTINE SET0D_STATES(mesh, states, a)
    IMPLICIT NONE
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(gns) :: a1d
    a1d(:) = a
    CALL SET1D_STATES(mesh, states, a1d)
  END SUBROUTINE SET0D_STATES

!  Differentiation of normalize_states in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
  SUBROUTINE NORMALIZE_STATES_D(setup, mesh, states, states_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a_d
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_STATES_D(mesh, states, states_d, a, a_d)
    DO i=1,gns
      lb = setup%optimize%lb_states(i)
      ub = setup%optimize%ub_states(i)
      a_d(:, :, i) = a_d(:, :, i)/(ub-lb)
      a(:, :, i) = (a(:, :, i)-lb)/(ub-lb)
    END DO
    CALL SET_STATES_D(mesh, states, states_d, a, a_d)
  END SUBROUTINE NORMALIZE_STATES_D

!  Differentiation of normalize_states in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
  SUBROUTINE NORMALIZE_STATES_B(setup, mesh, states, states_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a_b
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_STATES(mesh, states, a)
    DO i=1,gns
      lb = setup%optimize%lb_states(i)
      ub = setup%optimize%ub_states(i)
    END DO
    CALL SET_STATES(mesh, states, a)
    CALL SET_STATES_B(mesh, states, states_b, a, a_b)
    DO i=gns,1,-1
      ub = setup%optimize%ub_states(i)
      lb = setup%optimize%lb_states(i)
      a_b(:, :, i) = a_b(:, :, i)/(ub-lb)
    END DO
    CALL GET_STATES_B(mesh, states, states_b, a, a_b)
  END SUBROUTINE NORMALIZE_STATES_B

  SUBROUTINE NORMALIZE_STATES(setup, mesh, states)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_STATES(mesh, states, a)
    DO i=1,gns
      lb = setup%optimize%lb_states(i)
      ub = setup%optimize%ub_states(i)
      a(:, :, i) = (a(:, :, i)-lb)/(ub-lb)
    END DO
    CALL SET_STATES(mesh, states, a)
  END SUBROUTINE NORMALIZE_STATES

!  Differentiation of denormalize_states in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
  SUBROUTINE DENORMALIZE_STATES_D(setup, mesh, states, states_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a_d
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_STATES_D(mesh, states, states_d, a, a_d)
    DO i=1,gns
      lb = setup%optimize%lb_states(i)
      ub = setup%optimize%ub_states(i)
      a_d(:, :, i) = (ub-lb)*a_d(:, :, i)
      a(:, :, i) = a(:, :, i)*(ub-lb) + lb
    END DO
    CALL SET_STATES_D(mesh, states, states_d, a, a_d)
  END SUBROUTINE DENORMALIZE_STATES_D

!  Differentiation of denormalize_states in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in
  SUBROUTINE DENORMALIZE_STATES_B(setup, mesh, states, states_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a_b
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_STATES(mesh, states, a)
    DO i=1,gns
      lb = setup%optimize%lb_states(i)
      ub = setup%optimize%ub_states(i)
    END DO
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                 husl1, 2))
    CALL PUSHREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                 husl2, 2))
    CALL PUSHREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                 hlsl, 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL SET_STATES(mesh, states, a)
    CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, &
&                2))
    CALL POPREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                hlsl, 2))
    CALL POPREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                husl2, 2))
    CALL POPREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                husl1, 2))
    CALL POPREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst, &
&                2))
    CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, &
&                2))
    CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
    CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2))
    CALL SET_STATES_B(mesh, states, states_b, a, a_b)
    DO i=gns,1,-1
      ub = setup%optimize%ub_states(i)
      lb = setup%optimize%lb_states(i)
      a_b(:, :, i) = (ub-lb)*a_b(:, :, i)
    END DO
    CALL GET_STATES_B(mesh, states, states_b, a, a_b)
  END SUBROUTINE DENORMALIZE_STATES_B

  SUBROUTINE DENORMALIZE_STATES(setup, mesh, states)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(STATESDT), INTENT(INOUT) :: states
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: a
    REAL(sp) :: lb, ub
    INTEGER :: i
    CALL GET_STATES(mesh, states, a)
    DO i=1,gns
      lb = setup%optimize%lb_states(i)
      ub = setup%optimize%ub_states(i)
      a(:, :, i) = a(:, :, i)*(ub-lb) + lb
    END DO
    CALL SET_STATES(mesh, states, a)
  END SUBROUTINE DENORMALIZE_STATES

!  Differentiation of get_hyper_states in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: a
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.husl1)
!                *(hyper_states.husl2) *(hyper_states.hlsl) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.husl1:in
!                hyper_states.husl2:in hyper_states.hlsl:in hyper_states.hlr:in
  SUBROUTINE GET_HYPER_STATES_D(setup, hyper_states, hyper_states_d, a, &
&   a_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states_d
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns), INTENT(INOUT) ::&
&   a
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns), INTENT(INOUT) ::&
&   a_d
    a_d = 0.0_4
    a_d(:, :, 1) = hyper_states_d%hi(:, :)
    a(:, :, 1) = hyper_states%hi(:, :)
    a_d(:, :, 2) = hyper_states_d%hp(:, :)
    a(:, :, 2) = hyper_states%hp(:, :)
    a_d(:, :, 3) = hyper_states_d%hft(:, :)
    a(:, :, 3) = hyper_states%hft(:, :)
    a_d(:, :, 4) = hyper_states_d%hst(:, :)
    a(:, :, 4) = hyper_states%hst(:, :)
    a_d(:, :, 5) = hyper_states_d%husl1(:, :)
    a(:, :, 5) = hyper_states%husl1(:, :)
    a_d(:, :, 6) = hyper_states_d%husl2(:, :)
    a(:, :, 6) = hyper_states%husl2(:, :)
    a_d(:, :, 7) = hyper_states_d%hlsl(:, :)
    a(:, :, 7) = hyper_states%hlsl(:, :)
    a_d(:, :, 8) = hyper_states_d%hlr(:, :)
    a(:, :, 8) = hyper_states%hlr(:, :)
  END SUBROUTINE GET_HYPER_STATES_D

!  Differentiation of get_hyper_states in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: a
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.husl1)
!                *(hyper_states.husl2) *(hyper_states.hlsl) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.husl1:in
!                hyper_states.husl2:in hyper_states.hlsl:in hyper_states.hlr:in
  SUBROUTINE GET_HYPER_STATES_B(setup, hyper_states, hyper_states_b, a, &
&   a_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT) :: hyper_states_b
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns), INTENT(INOUT) ::&
&   a
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns), INTENT(INOUT) ::&
&   a_b
    hyper_states_b%hlr = 0.0_4
    hyper_states_b%hlr = hyper_states_b%hlr + a_b(:, :, 8)
    a_b(:, :, 8) = 0.0_4
    hyper_states_b%hlsl = 0.0_4
    hyper_states_b%hlsl = hyper_states_b%hlsl + a_b(:, :, 7)
    a_b(:, :, 7) = 0.0_4
    hyper_states_b%husl2 = 0.0_4
    hyper_states_b%husl2 = hyper_states_b%husl2 + a_b(:, :, 6)
    a_b(:, :, 6) = 0.0_4
    hyper_states_b%husl1 = 0.0_4
    hyper_states_b%husl1 = hyper_states_b%husl1 + a_b(:, :, 5)
    a_b(:, :, 5) = 0.0_4
    hyper_states_b%hst = 0.0_4
    hyper_states_b%hst = hyper_states_b%hst + a_b(:, :, 4)
    a_b(:, :, 4) = 0.0_4
    hyper_states_b%hft = 0.0_4
    hyper_states_b%hft = hyper_states_b%hft + a_b(:, :, 3)
    a_b(:, :, 3) = 0.0_4
    hyper_states_b%hp = 0.0_4
    hyper_states_b%hp = hyper_states_b%hp + a_b(:, :, 2)
    a_b(:, :, 2) = 0.0_4
    hyper_states_b%hi = 0.0_4
    hyper_states_b%hi = hyper_states_b%hi + a_b(:, :, 1)
  END SUBROUTINE GET_HYPER_STATES_B

  SUBROUTINE GET_HYPER_STATES(setup, hyper_states, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns), INTENT(INOUT) ::&
&   a
    a(:, :, 1) = hyper_states%hi(:, :)
    a(:, :, 2) = hyper_states%hp(:, :)
    a(:, :, 3) = hyper_states%hft(:, :)
    a(:, :, 4) = hyper_states%hst(:, :)
    a(:, :, 5) = hyper_states%husl1(:, :)
    a(:, :, 6) = hyper_states%husl2(:, :)
    a(:, :, 7) = hyper_states%hlsl(:, :)
    a(:, :, 8) = hyper_states%hlr(:, :)
  END SUBROUTINE GET_HYPER_STATES

  SUBROUTINE SET3D_HYPER_STATES(setup, hyper_states, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns), INTENT(IN) :: a
    hyper_states%hi(:, :) = a(:, :, 1)
    hyper_states%hp(:, :) = a(:, :, 2)
    hyper_states%hft(:, :) = a(:, :, 3)
    hyper_states%hst(:, :) = a(:, :, 4)
    hyper_states%husl1(:, :) = a(:, :, 5)
    hyper_states%husl2(:, :) = a(:, :, 6)
    hyper_states%hlsl(:, :) = a(:, :, 7)
    hyper_states%hlr(:, :) = a(:, :, 8)
  END SUBROUTINE SET3D_HYPER_STATES

  SUBROUTINE SET1D_HYPER_STATES(setup, hyper_states, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states
    REAL(sp), DIMENSION(gns), INTENT(IN) :: a
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns) :: a3d
    INTEGER :: i
    DO i=1,gns
      a3d(:, :, i) = a(i)
    END DO
    CALL SET3D_HYPER_STATES(setup, hyper_states, a3d)
  END SUBROUTINE SET1D_HYPER_STATES

  SUBROUTINE SET0D_HYPER_STATES(setup, hyper_states, a)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(HYPER_STATESDT), INTENT(INOUT) :: hyper_states
    REAL(sp), INTENT(IN) :: a
    REAL(sp), DIMENSION(gns) :: a1d
    a1d(:) = a
    CALL SET1D_HYPER_STATES(setup, hyper_states, a1d)
  END SUBROUTINE SET0D_HYPER_STATES

!  Differentiation of hyper_states_to_states in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.husl1)
!                *(hyper_states.husl2) *(hyper_states.hlsl) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.husl1:in
!                hyper_states.husl2:in hyper_states.hlsl:in hyper_states.hlr:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.husl1:in states.husl2:in states.hlsl:in
!                states.hlr:in
!%      TODO comment
  SUBROUTINE HYPER_STATES_TO_STATES_D(hyper_states, hyper_states_d, &
&   states, states_d, setup, mesh, input_data)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns) :: &
&   hyper_states_matrix
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns) :: &
&   hyper_states_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: d, dpb
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: dpb_d
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_d, b_d
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: temp
    CALL GET_HYPER_STATES_D(setup, hyper_states, hyper_states_d, &
&                     hyper_states_matrix, hyper_states_matrix_d)
    CALL GET_STATES(mesh, states, states_matrix)
    states_matrix_d = 0.0_4
    a_d = 0.0_4
    b_d = 0.0_4
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,gns
      states_matrix_d(:, :, i) = hyper_states_matrix_d(1, 1, i)
      states_matrix(:, :, i) = hyper_states_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a_d = hyper_states_matrix_d(j+1, 1, i)
          a = hyper_states_matrix(j+1, 1, i)
          b = 1._sp
          b_d = 0.0_4
        CASE ('hyper-polynomial') 
          a_d = hyper_states_matrix_d(2*j, 1, i)
          a = hyper_states_matrix(2*j, 1, i)
          b_d = hyper_states_matrix_d(2*j+1, 1, i)
          b = hyper_states_matrix(2*j+1, 1, i)
        END SELECT
        temp = d**b
        WHERE (d .LE. 0.0) 
          dpb_d = 0.0_4
        ELSEWHERE
          dpb_d = temp*LOG(d)*b_d
        END WHERE
        dpb = temp
        states_matrix_d(:, :, i) = states_matrix_d(:, :, i) + dpb*a_d + &
&         a*dpb_d
        states_matrix(:, :, i) = states_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      temp = (setup%optimize%ub_states(i)-setup%optimize%lb_states(i))/(&
&       EXP(-states_matrix(:, :, i))+1._sp)
      states_matrix_d(:, :, i) = temp*EXP(-states_matrix(:, :, i))*&
&       states_matrix_d(:, :, i)/(EXP(-states_matrix(:, :, i))+1._sp)
      states_matrix(:, :, i) = setup%optimize%lb_states(i) + temp
    END DO
    states_d%hi = 0.0_4
    states_d%hp = 0.0_4
    states_d%hft = 0.0_4
    states_d%hst = 0.0_4
    states_d%husl1 = 0.0_4
    states_d%husl2 = 0.0_4
    states_d%hlsl = 0.0_4
    states_d%hlr = 0.0_4
    CALL SET_STATES_D(mesh, states, states_d, states_matrix, &
&               states_matrix_d)
  END SUBROUTINE HYPER_STATES_TO_STATES_D

!  Differentiation of hyper_states_to_states in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.husl1)
!                *(hyper_states.husl2) *(hyper_states.hlsl) *(hyper_states.hlr)
!   Plus diff mem management of: hyper_states.hi:in hyper_states.hp:in
!                hyper_states.hft:in hyper_states.hst:in hyper_states.husl1:in
!                hyper_states.husl2:in hyper_states.hlsl:in hyper_states.hlr:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.husl1:in states.husl2:in states.hlsl:in
!                states.hlr:in
!%      TODO comment
  SUBROUTINE HYPER_STATES_TO_STATES_B(hyper_states, hyper_states_b, &
&   states, states_b, setup, mesh, input_data)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(HYPER_STATESDT) :: hyper_states_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns) :: &
&   hyper_states_matrix
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns) :: &
&   hyper_states_matrix_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: d, dpb
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: dpb_b
    INTEGER :: i, j
    REAL(sp) :: a, b
    REAL(sp) :: a_b, b_b
    INTRINSIC TRIM
    INTRINSIC EXP
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: temp
    INTEGER :: branch
    CALL GET_HYPER_STATES(setup, hyper_states, hyper_states_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,gns
      states_matrix(:, :, i) = hyper_states_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          CALL PUSHREAL4(a)
          a = hyper_states_matrix(j+1, 1, i)
          CALL PUSHREAL4(b)
          b = 1._sp
          CALL PUSHCONTROL2B(1)
        CASE ('hyper-polynomial') 
          CALL PUSHREAL4(a)
          a = hyper_states_matrix(2*j, 1, i)
          CALL PUSHREAL4(b)
          b = hyper_states_matrix(2*j+1, 1, i)
          CALL PUSHCONTROL2B(2)
        CASE DEFAULT
          CALL PUSHCONTROL2B(0)
        END SELECT
        dpb = d**b
        states_matrix(:, :, i) = states_matrix(:, :, i) + a*dpb
      END DO
    END DO
    CALL SET_STATES(mesh, states, states_matrix)
    CALL SET_STATES_B(mesh, states, states_b, states_matrix, &
&               states_matrix_b)
    hyper_states_matrix_b = 0.0_4
    a_b = 0.0_4
    b_b = 0.0_4
    DO i=gns,1,-1
      temp = EXP(-states_matrix(:, :, i)) + 1._sp
      states_matrix_b(:, :, i) = EXP(-states_matrix(:, :, i))*(setup%&
&       optimize%ub_states(i)-setup%optimize%lb_states(i))*&
&       states_matrix_b(:, :, i)/temp**2
      DO j=setup%nd,1,-1
        d = input_data%descriptor(:, :, j)
        dpb = d**b
        dpb_b = 0.0_4
        a_b = a_b + SUM(dpb*states_matrix_b(:, :, i))
        dpb_b = a*states_matrix_b(:, :, i)
        b_b = b_b + SUM(d**b*LOG(d)*dpb_b, MASK=.NOT.d.LE.0.0)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            CALL POPREAL4(b)
            CALL POPREAL4(a)
            hyper_states_matrix_b(j+1, 1, i) = hyper_states_matrix_b(j+1&
&             , 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          ELSE
            CALL POPREAL4(b)
            hyper_states_matrix_b(2*j+1, 1, i) = hyper_states_matrix_b(2&
&             *j+1, 1, i) + b_b
            CALL POPREAL4(a)
            hyper_states_matrix_b(2*j, 1, i) = hyper_states_matrix_b(2*j&
&             , 1, i) + a_b
            a_b = 0.0_4
            b_b = 0.0_4
          END IF
        END IF
      END DO
      hyper_states_matrix_b(1, 1, i) = hyper_states_matrix_b(1, 1, i) + &
&       SUM(states_matrix_b(:, :, i))
      states_matrix_b(:, :, i) = 0.0_4
    END DO
    CALL GET_HYPER_STATES_B(setup, hyper_states, hyper_states_b, &
&                     hyper_states_matrix, hyper_states_matrix_b)
  END SUBROUTINE HYPER_STATES_TO_STATES_B

!%      TODO comment
  SUBROUTINE HYPER_STATES_TO_STATES(hyper_states, states, setup, mesh, &
&   input_data)
    IMPLICIT NONE
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    REAL(sp), DIMENSION(setup%optimize%nhyper, 1, gns) :: &
&   hyper_states_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: d, dpb
    INTEGER :: i, j
    REAL(sp) :: a, b
    INTRINSIC TRIM
    INTRINSIC EXP
    CALL GET_HYPER_STATES(setup, hyper_states, hyper_states_matrix)
    CALL GET_STATES(mesh, states, states_matrix)
!% Add mask later here
!% 1 in dim2 will be replace with k and apply where on Omega
    DO i=1,gns
      states_matrix(:, :, i) = hyper_states_matrix(1, 1, i)
      DO j=1,setup%nd
        d = input_data%descriptor(:, :, j)
        SELECT CASE  (TRIM(setup%optimize%mapping)) 
        CASE ('hyper-linear') 
          a = hyper_states_matrix(j+1, 1, i)
          b = 1._sp
        CASE ('hyper-polynomial') 
          a = hyper_states_matrix(2*j, 1, i)
          b = hyper_states_matrix(2*j+1, 1, i)
        END SELECT
        dpb = d**b
        states_matrix(:, :, i) = states_matrix(:, :, i) + a*dpb
      END DO
!% sigmoid transformation lambda = 1
      states_matrix(:, :, i) = (setup%optimize%ub_states(i)-setup%&
&       optimize%lb_states(i))*(1._sp/(1._sp+EXP(-states_matrix(:, :, i)&
&       ))) + setup%optimize%lb_states(i)
    END DO
    CALL SET_STATES(mesh, states, states_matrix)
  END SUBROUTINE HYPER_STATES_TO_STATES

END MODULE MWD_STATES_MANIPULATION_DIFF

!%    This module `mwd_cost` encapsulates all SMASH cost (type, subroutines, functions)
!%    This module is wrapped and differentiated.
!%
!%      contains
!%
!%      [1]  compute_jobs
!%      [2]  compute_jreg
!%      [3]  compute_cost
!%      [4]  nse
!%      [5]  kge_components
!%      [6]  kge
!%      [7]  se
!%      [8]  rmse
!%      [9]  logarithmic
!%      [10] reg_prior
MODULE MWD_COST_DIFF
!% only: sp, dp, lchar, GNP, GNS
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!%only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT, Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT, Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: get_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!%only: get_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
  PUBLIC :: compute_jobs, compute_jreg, compute_cost
  PUBLIC :: compute_jobs_d, compute_jreg_d, compute_cost_d, &
& compute_jobs_b, compute_jreg_b, compute_cost_b

CONTAINS
!  Differentiation of compute_jobs in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
!% Way to improve: try do one single for loop to compute all cost function
!% ATM, each cost function are computed separately with n for loop
  SUBROUTINE COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, &
&   jobs, jobs_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), INTENT(OUT) :: jobs_d
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%&
&   optimize_start_step+1) :: po, qo, qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%&
&   optimize_start_step+1) :: qs_d
    REAL(sp), DIMENSION(mesh%ng) :: arr_gauge_jobs
    REAL(sp), DIMENSION(mesh%ng) :: arr_gauge_jobs_d
    REAL(sp) :: imd, j_imd, gauge_jobs
    REAL(sp) :: imd_d, j_imd_d, gauge_jobs_d
    INTEGER :: g, row, col, j, arr_size
    INTRINSIC REAL
    INTRINSIC ANY
    arr_gauge_jobs = 0._sp
    arr_size = 0
    jobs_d = 0.0_4
    arr_gauge_jobs_d = 0.0_4
    j_imd_d = 0.0_4
    DO g=1,mesh%ng
      gauge_jobs = 0._sp
      IF (setup%optimize%wgauge(g) .GT. 0._sp .OR. setup%optimize%wgauge&
&         (g) .LT. 0._sp) THEN
        po = input_data%mean_prcp(g, setup%optimize%optimize_start_step:&
&         setup%ntime_step)
        qs_d = setup%dt*1e3_sp*output_d%qsim(g, setup%optimize%&
&         optimize_start_step:setup%ntime_step)/mesh%area(g)
        qs = output%qsim(g, setup%optimize%optimize_start_step:setup%&
&         ntime_step)*setup%dt/mesh%area(g)*1e3_sp
        row = mesh%gauge_pos(g, 1)
        col = mesh%gauge_pos(g, 2)
        qo = input_data%qobs(g, setup%optimize%optimize_start_step:setup&
&         %ntime_step)*setup%dt/(REAL(mesh%flwacc(row, col))*mesh%dx*&
&         mesh%dx)*1e3_sp
        gauge_jobs_d = 0.0_4
        DO j=1,setup%optimize%njf
          IF (ANY(qo .GE. 0._sp)) THEN
            SELECT CASE  (setup%optimize%jobs_fun(j)) 
            CASE ('nse') 
              j_imd_d = NSE_D(qo, qs, qs_d, j_imd)
            CASE ('kge') 
              j_imd_d = KGE_D(qo, qs, qs_d, j_imd)
            CASE ('kge2') 
              imd_d = KGE_D(qo, qs, qs_d, imd)
              j_imd_d = 2*imd*imd_d
              j_imd = imd*imd
            CASE ('se') 
              j_imd_d = SE_D(qo, qs, qs_d, j_imd)
            CASE ('rmse') 
              j_imd_d = RMSE_D(qo, qs, qs_d, j_imd)
            CASE ('logarithmic') 
              j_imd_d = LOGARITHMIC_D(qo, qs, qs_d, j_imd)
            CASE ('Crc', 'Cfp2', 'Cfp10', 'Cfp50', 'Cfp90', 'Erc', 'Elt'&
&           , 'Epf') 
! CASE OF SIGNATURES
              j_imd_d = SIGNATURE_D(po, qo, qs, qs_d, setup%optimize%&
&               mask_event(g, setup%optimize%optimize_start_step:setup%&
&               ntime_step), setup%optimize%jobs_fun(j), j_imd)
            END SELECT
          END IF
          gauge_jobs_d = gauge_jobs_d + setup%optimize%wjobs_fun(j)*&
&           j_imd_d
          gauge_jobs = gauge_jobs + setup%optimize%wjobs_fun(j)*j_imd
        END DO
        IF (setup%optimize%wgauge(g) .GT. 0._sp) THEN
          jobs_d = jobs_d + setup%optimize%wgauge(g)*gauge_jobs_d
        ELSE
          arr_size = arr_size + 1
          arr_gauge_jobs_d(arr_size) = gauge_jobs_d
          arr_gauge_jobs(arr_size) = gauge_jobs
        END IF
      END IF
    END DO
    IF (arr_size .GT. 0) jobs_d = QUANTILE_D(arr_gauge_jobs(1:arr_size)&
&       , arr_gauge_jobs_d(1:arr_size), 0.5, jobs)
  END SUBROUTINE COMPUTE_JOBS_D

!  Differentiation of compute_jobs in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: jobs
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
!% Way to improve: try do one single for loop to compute all cost function
!% ATM, each cost function are computed separately with n for loop
  SUBROUTINE COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, &
&   jobs, jobs_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
    REAL(sp) :: jobs
    REAL(sp) :: jobs_b
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%&
&   optimize_start_step+1) :: po, qo, qs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%&
&   optimize_start_step+1) :: qs_b
    REAL(sp), DIMENSION(mesh%ng) :: arr_gauge_jobs
    REAL(sp), DIMENSION(mesh%ng) :: arr_gauge_jobs_b
    REAL(sp) :: imd, j_imd, gauge_jobs
    REAL(sp) :: imd_b, j_imd_b, gauge_jobs_b
    INTEGER :: g, row, col, j, arr_size
    INTRINSIC REAL
    INTRINSIC ANY
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: branch
    arr_gauge_jobs = 0._sp
    arr_size = 0
    DO g=1,mesh%ng
      gauge_jobs = 0._sp
      IF (setup%optimize%wgauge(g) .GT. 0._sp .OR. setup%optimize%wgauge&
&         (g) .LT. 0._sp) THEN
        po = input_data%mean_prcp(g, setup%optimize%optimize_start_step:&
&         setup%ntime_step)
        qs = output%qsim(g, setup%optimize%optimize_start_step:setup%&
&         ntime_step)*setup%dt/mesh%area(g)*1e3_sp
        row = mesh%gauge_pos(g, 1)
        col = mesh%gauge_pos(g, 2)
        CALL PUSHREAL4ARRAY(qo, setup%ntime_step - setup%optimize%&
&                     optimize_start_step + 1)
        qo = input_data%qobs(g, setup%optimize%optimize_start_step:setup&
&         %ntime_step)*setup%dt/(REAL(mesh%flwacc(row, col))*mesh%dx*&
&         mesh%dx)*1e3_sp
        DO j=1,setup%optimize%njf
          IF (ANY(qo .GE. 0._sp)) THEN
            SELECT CASE  (setup%optimize%jobs_fun(j)) 
            CASE ('nse') 
              j_imd = NSE(qo, qs)
              CALL PUSHCONTROL4B(1)
            CASE ('kge') 
              j_imd = KGE(qo, qs)
              CALL PUSHCONTROL4B(2)
            CASE ('kge2') 
              CALL PUSHREAL4(imd)
              imd = KGE(qo, qs)
              j_imd = imd*imd
              CALL PUSHCONTROL4B(3)
            CASE ('se') 
              j_imd = SE(qo, qs)
              CALL PUSHCONTROL4B(4)
            CASE ('rmse') 
              j_imd = RMSE(qo, qs)
              CALL PUSHCONTROL4B(5)
            CASE ('logarithmic') 
              j_imd = LOGARITHMIC(qo, qs)
              CALL PUSHCONTROL4B(6)
            CASE ('Crc', 'Cfp2', 'Cfp10', 'Cfp50', 'Cfp90', 'Erc', 'Elt'&
&           , 'Epf') 
! CASE OF SIGNATURES
              j_imd = SIGNATURE(po, qo, qs, setup%optimize%mask_event(g&
&               , setup%optimize%optimize_start_step:setup%ntime_step), &
&               setup%optimize%jobs_fun(j))
              CALL PUSHCONTROL4B(7)
            CASE DEFAULT
              CALL PUSHCONTROL4B(0)
            END SELECT
          ELSE
            CALL PUSHCONTROL4B(8)
          END IF
          gauge_jobs = gauge_jobs + setup%optimize%wjobs_fun(j)*j_imd
        END DO
        IF (setup%optimize%wgauge(g) .GT. 0._sp) THEN
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHINTEGER4(arr_size)
          arr_size = arr_size + 1
          arr_gauge_jobs(arr_size) = gauge_jobs
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    IF (arr_size .GT. 0) THEN
      res = QUANTILE(arr_gauge_jobs(1:arr_size), 0.5)
      arr_gauge_jobs_b = 0.0_4
      res_b = jobs_b
      CALL QUANTILE_B(arr_gauge_jobs(1:arr_size), arr_gauge_jobs_b(1:&
&               arr_size), 0.5, res_b)
      jobs_b = 0.0_4
    ELSE
      arr_gauge_jobs_b = 0.0_4
    END IF
    output_b%qsim = 0.0_4
    j_imd_b = 0.0_4
    DO g=mesh%ng,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          gauge_jobs_b = arr_gauge_jobs_b(arr_size)
          arr_gauge_jobs_b(arr_size) = 0.0_4
          CALL POPINTEGER4(arr_size)
        ELSE
          gauge_jobs_b = setup%optimize%wgauge(g)*jobs_b
        END IF
        qs = output%qsim(g, setup%optimize%optimize_start_step:setup%&
&         ntime_step)*setup%dt/mesh%area(g)*1e3_sp
        po = input_data%mean_prcp(g, setup%optimize%optimize_start_step:&
&         setup%ntime_step)
        qs_b = 0.0_4
        DO j=setup%optimize%njf,1,-1
          j_imd_b = j_imd_b + setup%optimize%wjobs_fun(j)*gauge_jobs_b
          CALL POPCONTROL4B(branch)
          IF (branch .LT. 4) THEN
            IF (branch .LT. 2) THEN
              IF (branch .NE. 0) THEN
                CALL NSE_B(qo, qs, qs_b, j_imd_b)
                j_imd_b = 0.0_4
              END IF
            ELSE IF (branch .EQ. 2) THEN
              CALL KGE_B(qo, qs, qs_b, j_imd_b)
              j_imd_b = 0.0_4
            ELSE
              imd_b = 2*imd*j_imd_b
              CALL POPREAL4(imd)
              CALL KGE_B(qo, qs, qs_b, imd_b)
              j_imd_b = 0.0_4
            END IF
          ELSE IF (branch .LT. 6) THEN
            IF (branch .EQ. 4) THEN
              CALL SE_B(qo, qs, qs_b, j_imd_b)
              j_imd_b = 0.0_4
            ELSE
              CALL RMSE_B(qo, qs, qs_b, j_imd_b)
              j_imd_b = 0.0_4
            END IF
          ELSE IF (branch .EQ. 6) THEN
            CALL LOGARITHMIC_B(qo, qs, qs_b, j_imd_b)
            j_imd_b = 0.0_4
          ELSE IF (branch .EQ. 7) THEN
            CALL SIGNATURE_B(po, qo, qs, qs_b, setup%optimize%mask_event&
&                      (g, setup%optimize%optimize_start_step:setup%&
&                      ntime_step), setup%optimize%jobs_fun(j), j_imd_b)
            j_imd_b = 0.0_4
          END IF
        END DO
        CALL POPREAL4ARRAY(qo, setup%ntime_step - setup%optimize%&
&                    optimize_start_step + 1)
        output_b%qsim(g, setup%optimize%optimize_start_step:setup%&
&       ntime_step) = output_b%qsim(g, setup%optimize%&
&         optimize_start_step:setup%ntime_step) + setup%dt*1e3_sp*qs_b/&
&         mesh%area(g)
      END IF
    END DO
  END SUBROUTINE COMPUTE_JOBS_B

!% Way to improve: try do one single for loop to compute all cost function
!% ATM, each cost function are computed separately with n for loop
  SUBROUTINE COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(OUT) :: jobs
    REAL(sp), DIMENSION(setup%ntime_step-setup%optimize%&
&   optimize_start_step+1) :: po, qo, qs
    REAL(sp), DIMENSION(mesh%ng) :: arr_gauge_jobs
    REAL(sp) :: imd, j_imd, gauge_jobs
    INTEGER :: g, row, col, j, arr_size
    INTRINSIC REAL
    INTRINSIC ANY
    jobs = 0._sp
    arr_gauge_jobs = 0._sp
    arr_size = 0
    DO g=1,mesh%ng
      gauge_jobs = 0._sp
      IF (setup%optimize%wgauge(g) .GT. 0._sp .OR. setup%optimize%wgauge&
&         (g) .LT. 0._sp) THEN
        po = input_data%mean_prcp(g, setup%optimize%optimize_start_step:&
&         setup%ntime_step)
        qs = output%qsim(g, setup%optimize%optimize_start_step:setup%&
&         ntime_step)*setup%dt/mesh%area(g)*1e3_sp
        row = mesh%gauge_pos(g, 1)
        col = mesh%gauge_pos(g, 2)
        qo = input_data%qobs(g, setup%optimize%optimize_start_step:setup&
&         %ntime_step)*setup%dt/(REAL(mesh%flwacc(row, col))*mesh%dx*&
&         mesh%dx)*1e3_sp
        DO j=1,setup%optimize%njf
          IF (ANY(qo .GE. 0._sp)) THEN
            SELECT CASE  (setup%optimize%jobs_fun(j)) 
            CASE ('nse') 
              j_imd = NSE(qo, qs)
            CASE ('kge') 
              j_imd = KGE(qo, qs)
            CASE ('kge2') 
              imd = KGE(qo, qs)
              j_imd = imd*imd
            CASE ('se') 
              j_imd = SE(qo, qs)
            CASE ('rmse') 
              j_imd = RMSE(qo, qs)
            CASE ('logarithmic') 
              j_imd = LOGARITHMIC(qo, qs)
            CASE ('Crc', 'Cfp2', 'Cfp10', 'Cfp50', 'Cfp90', 'Erc', 'Elt'&
&           , 'Epf') 
! CASE OF SIGNATURES
              j_imd = SIGNATURE(po, qo, qs, setup%optimize%mask_event(g&
&               , setup%optimize%optimize_start_step:setup%ntime_step), &
&               setup%optimize%jobs_fun(j))
            END SELECT
          END IF
          gauge_jobs = gauge_jobs + setup%optimize%wjobs_fun(j)*j_imd
        END DO
        IF (setup%optimize%wgauge(g) .GT. 0._sp) THEN
          jobs = jobs + setup%optimize%wgauge(g)*gauge_jobs
        ELSE
          arr_size = arr_size + 1
          arr_gauge_jobs(arr_size) = gauge_jobs
        END IF
      END IF
    END DO
    IF (arr_size .GT. 0) jobs = QUANTILE(arr_gauge_jobs(1:arr_size), 0.5&
&       )
  END SUBROUTINE COMPUTE_JOBS

!  Differentiation of compute_jreg in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: jreg
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hst) *(states.husl1)
!                *(states.husl2) *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
!% WIP
  SUBROUTINE COMPUTE_JREG_D(setup, mesh, input_data, parameters, &
&   parameters_d, parameters_bgd, parameters_bgd_d, states, states_d, &
&   states_bgd, states_bgd_d, jreg, jreg_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d, parameters_bgd_d
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT), INTENT(IN) :: states_d, states_bgd_d
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp), INTENT(INOUT) :: jreg_d
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp) :: parameters_jreg_d, states_jreg_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: parameters_matrix&
&   , parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: &
&   parameters_matrix_d
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix, &
&   states_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix_d
    INTEGER :: i
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: temp
    CALL GET_PARAMETERS_D(mesh, parameters, parameters_d, &
&                   parameters_matrix, parameters_matrix_d)
    CALL GET_PARAMETERS(mesh, parameters_bgd, parameters_bgd_matrix)
    CALL GET_STATES_D(mesh, states, states_d, states_matrix, &
&               states_matrix_d)
    CALL GET_STATES(mesh, states_bgd, states_bgd_matrix)
    parameters_jreg_d = 0.0_4
    states_jreg_d = 0.0_4
    DO i=1,setup%optimize%njr
      SELECT CASE  (setup%optimize%jreg_fun(i)) 
      CASE ('prior') 
        result1_d = REG_PRIOR_D(setup, setup%optimize%optim_parameters, &
&         parameters_matrix, parameters_matrix_d, parameters_bgd_matrix&
&         , result1)
        parameters_jreg_d = parameters_jreg_d + setup%optimize%wjreg_fun&
&         (i)*result1_d
        result1_d = REG_PRIOR_D(setup, setup%optimize%optim_states, &
&         states_matrix, states_matrix_d, states_bgd_matrix, result1)
        states_jreg_d = states_jreg_d + setup%optimize%wjreg_fun(i)*&
&         result1_d
      CASE ('smoothing') 
        result1_d = REG_SMOOTHING_D(setup, mesh, setup%optimize%&
&         optim_parameters, parameters_matrix, parameters_matrix_d, &
&         parameters_bgd_matrix, .true., result1)
        temp = setup%optimize%wjreg_fun(i)**2._sp
        parameters_jreg_d = parameters_jreg_d + temp*result1_d
        result1_d = REG_SMOOTHING_D(setup, mesh, setup%optimize%&
&         optim_states, states_matrix, states_matrix_d, &
&         states_bgd_matrix, .true., result1)
        temp = setup%optimize%wjreg_fun(i)**2._sp
        states_jreg_d = states_jreg_d + temp*result1_d
      CASE ('hard_smoothing') 
        result1_d = REG_SMOOTHING_D(setup, mesh, setup%optimize%&
&         optim_parameters, parameters_matrix, parameters_matrix_d, &
&         parameters_bgd_matrix, .false., result1)
        temp = setup%optimize%wjreg_fun(i)**2._sp
        parameters_jreg_d = parameters_jreg_d + temp*result1_d
        result1_d = REG_SMOOTHING_D(setup, mesh, setup%optimize%&
&         optim_states, states_matrix, states_matrix_d, &
&         states_bgd_matrix, .false., result1)
        temp = setup%optimize%wjreg_fun(i)**2._sp
        states_jreg_d = states_jreg_d + temp*result1_d
      CASE ('distance_correlation') 
        result1_d = DISTANCE_CORRELATION_DESCRIPTORS_D(setup, mesh, &
&         input_data, 'params', gnp, parameters_matrix, &
&         parameters_matrix_d, result1)
        parameters_jreg_d = parameters_jreg_d + setup%optimize%wjreg_fun&
&         (i)*result1_d
        result1_d = DISTANCE_CORRELATION_DESCRIPTORS_D(setup, mesh, &
&         input_data, 'states', gns, states_matrix, states_matrix_d, &
&         result1)
        states_jreg_d = states_jreg_d + setup%optimize%wjreg_fun(i)*&
&         result1_d
      END SELECT
    END DO
    jreg_d = parameters_jreg_d + states_jreg_d
  END SUBROUTINE COMPUTE_JREG_D

!  Differentiation of compute_jreg in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: jreg
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hst) *(states.husl1)
!                *(states.husl2) *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in states.hi:in states.hp:in states.hft:in
!                states.hst:in states.husl1:in states.husl2:in
!                states.hlsl:in states.hlr:in parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
!% WIP
  SUBROUTINE COMPUTE_JREG_B(setup, mesh, input_data, parameters, &
&   parameters_b, parameters_bgd, parameters_bgd_b, states, states_b, &
&   states_bgd, states_bgd_b, jreg, jreg_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(PARAMETERSDT) :: parameters_b, parameters_bgd_b
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    TYPE(STATESDT) :: states_b, states_bgd_b
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp), INTENT(INOUT) :: jreg_b
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp) :: parameters_jreg_b, states_jreg_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: parameters_matrix&
&   , parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: &
&   parameters_matrix_b
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix, &
&   states_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix_b
    INTEGER :: i
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: res0
    REAL(sp) :: res_b0
    REAL(sp) :: res1
    REAL(sp) :: res_b1
    REAL(sp) :: res2
    REAL(sp) :: res_b2
    REAL(sp) :: res3
    REAL(sp) :: res_b3
    REAL(sp) :: res4
    REAL(sp) :: res_b4
    REAL(sp) :: res5
    REAL(sp) :: res_b5
    REAL(sp) :: res6
    REAL(sp) :: res_b6
    INTEGER :: branch
    CALL GET_PARAMETERS(mesh, parameters, parameters_matrix)
    CALL GET_PARAMETERS(mesh, parameters_bgd, parameters_bgd_matrix)
    CALL GET_STATES(mesh, states, states_matrix)
    CALL GET_STATES(mesh, states_bgd, states_bgd_matrix)
    DO i=1,setup%optimize%njr
      SELECT CASE  (setup%optimize%jreg_fun(i)) 
      CASE ('prior') 
        res = REG_PRIOR(setup, setup%optimize%optim_parameters, &
&         parameters_matrix, parameters_bgd_matrix)
        res0 = REG_PRIOR(setup, setup%optimize%optim_states, &
&         states_matrix, states_bgd_matrix)
        CALL PUSHCONTROL3B(3)
      CASE ('smoothing') 
        res1 = REG_SMOOTHING(setup, mesh, setup%optimize%&
&         optim_parameters, parameters_matrix, parameters_bgd_matrix, &
&         .true.)
        res2 = REG_SMOOTHING(setup, mesh, setup%optimize%optim_states, &
&         states_matrix, states_bgd_matrix, .true.)
        CALL PUSHCONTROL3B(2)
      CASE ('hard_smoothing') 
        res3 = REG_SMOOTHING(setup, mesh, setup%optimize%&
&         optim_parameters, parameters_matrix, parameters_bgd_matrix, &
&         .false.)
        res4 = REG_SMOOTHING(setup, mesh, setup%optimize%optim_states, &
&         states_matrix, states_bgd_matrix, .false.)
        CALL PUSHCONTROL3B(1)
      CASE ('distance_correlation') 
        res5 = DISTANCE_CORRELATION_DESCRIPTORS(setup, mesh, input_data&
&         , 'params', gnp, parameters_matrix)
        res6 = DISTANCE_CORRELATION_DESCRIPTORS(setup, mesh, input_data&
&         , 'states', gns, states_matrix)
        CALL PUSHCONTROL3B(0)
      CASE DEFAULT
        CALL PUSHCONTROL3B(4)
      END SELECT
    END DO
    parameters_jreg_b = jreg_b
    states_jreg_b = jreg_b
    states_matrix_b = 0.0_4
    parameters_matrix_b = 0.0_4
    DO i=setup%optimize%njr,1,-1
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          result1_b = setup%optimize%wjreg_fun(i)*states_jreg_b
          res_b6 = result1_b
          CALL DISTANCE_CORRELATION_DESCRIPTORS_B(setup, mesh, &
&                                           input_data, 'states', gns, &
&                                           states_matrix, &
&                                           states_matrix_b, res_b6)
          result1_b = setup%optimize%wjreg_fun(i)*parameters_jreg_b
          res_b5 = result1_b
          CALL DISTANCE_CORRELATION_DESCRIPTORS_B(setup, mesh, &
&                                           input_data, 'params', gnp, &
&                                           parameters_matrix, &
&                                           parameters_matrix_b, res_b5)
        ELSE
          result1_b = setup%optimize%wjreg_fun(i)**2._sp*states_jreg_b
          res_b4 = result1_b
          CALL REG_SMOOTHING_B(setup, mesh, setup%optimize%optim_states&
&                        , states_matrix, states_matrix_b, &
&                        states_bgd_matrix, .false., res_b4)
          result1_b = setup%optimize%wjreg_fun(i)**2._sp*&
&           parameters_jreg_b
          res_b3 = result1_b
          CALL REG_SMOOTHING_B(setup, mesh, setup%optimize%&
&                        optim_parameters, parameters_matrix, &
&                        parameters_matrix_b, parameters_bgd_matrix, &
&                        .false., res_b3)
        END IF
      ELSE IF (branch .EQ. 2) THEN
        result1_b = setup%optimize%wjreg_fun(i)**2._sp*states_jreg_b
        res_b2 = result1_b
        CALL REG_SMOOTHING_B(setup, mesh, setup%optimize%optim_states, &
&                      states_matrix, states_matrix_b, states_bgd_matrix&
&                      , .true., res_b2)
        result1_b = setup%optimize%wjreg_fun(i)**2._sp*parameters_jreg_b
        res_b1 = result1_b
        CALL REG_SMOOTHING_B(setup, mesh, setup%optimize%&
&                      optim_parameters, parameters_matrix, &
&                      parameters_matrix_b, parameters_bgd_matrix, &
&                      .true., res_b1)
      ELSE IF (branch .EQ. 3) THEN
        result1_b = setup%optimize%wjreg_fun(i)*states_jreg_b
        res_b0 = result1_b
        CALL REG_PRIOR_B(setup, setup%optimize%optim_states, &
&                  states_matrix, states_matrix_b, states_bgd_matrix, &
&                  res_b0)
        result1_b = setup%optimize%wjreg_fun(i)*parameters_jreg_b
        res_b = result1_b
        CALL REG_PRIOR_B(setup, setup%optimize%optim_parameters, &
&                  parameters_matrix, parameters_matrix_b, &
&                  parameters_bgd_matrix, res_b)
      END IF
    END DO
    states_b%hi = 0.0_4
    states_b%hp = 0.0_4
    states_b%hft = 0.0_4
    states_b%hst = 0.0_4
    states_b%husl1 = 0.0_4
    states_b%husl2 = 0.0_4
    states_b%hlsl = 0.0_4
    states_b%hlr = 0.0_4
    CALL GET_STATES_B(mesh, states, states_b, states_matrix, &
&               states_matrix_b)
    parameters_b%ci = 0.0_4
    parameters_b%cp = 0.0_4
    parameters_b%beta = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%cst = 0.0_4
    parameters_b%alpha = 0.0_4
    parameters_b%exc = 0.0_4
    parameters_b%b = 0.0_4
    parameters_b%cusl1 = 0.0_4
    parameters_b%cusl2 = 0.0_4
    parameters_b%clsl = 0.0_4
    parameters_b%ks = 0.0_4
    parameters_b%ds = 0.0_4
    parameters_b%dsm = 0.0_4
    parameters_b%ws = 0.0_4
    parameters_b%lr = 0.0_4
    CALL GET_PARAMETERS_B(mesh, parameters, parameters_b, &
&                   parameters_matrix, parameters_matrix_b)
  END SUBROUTINE COMPUTE_JREG_B

!% WIP
  SUBROUTINE COMPUTE_JREG(setup, mesh, input_data, parameters, &
&   parameters_bgd, states, states_bgd, jreg)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters, parameters_bgd
    TYPE(STATESDT), INTENT(IN) :: states, states_bgd
    REAL(sp), INTENT(INOUT) :: jreg
    REAL(sp) :: parameters_jreg, states_jreg
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gnp) :: parameters_matrix&
&   , parameters_bgd_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, gns) :: states_matrix, &
&   states_bgd_matrix
    INTEGER :: i
    REAL(sp) :: result1
    CALL GET_PARAMETERS(mesh, parameters, parameters_matrix)
    CALL GET_PARAMETERS(mesh, parameters_bgd, parameters_bgd_matrix)
    CALL GET_STATES(mesh, states, states_matrix)
    CALL GET_STATES(mesh, states_bgd, states_bgd_matrix)
    jreg = 0._sp
    parameters_jreg = 0._sp
    states_jreg = 0._sp
    DO i=1,setup%optimize%njr
      SELECT CASE  (setup%optimize%jreg_fun(i)) 
      CASE ('prior') 
        result1 = REG_PRIOR(setup, setup%optimize%optim_parameters, &
&         parameters_matrix, parameters_bgd_matrix)
        parameters_jreg = parameters_jreg + setup%optimize%wjreg_fun(i)*&
&         result1
        result1 = REG_PRIOR(setup, setup%optimize%optim_states, &
&         states_matrix, states_bgd_matrix)
        states_jreg = states_jreg + setup%optimize%wjreg_fun(i)*result1
      CASE ('smoothing') 
        result1 = REG_SMOOTHING(setup, mesh, setup%optimize%&
&         optim_parameters, parameters_matrix, parameters_bgd_matrix, &
&         .true.)
        parameters_jreg = parameters_jreg + setup%optimize%wjreg_fun(i)&
&         **2._sp*result1
        result1 = REG_SMOOTHING(setup, mesh, setup%optimize%optim_states&
&         , states_matrix, states_bgd_matrix, .true.)
        states_jreg = states_jreg + setup%optimize%wjreg_fun(i)**2._sp*&
&         result1
      CASE ('hard_smoothing') 
        result1 = REG_SMOOTHING(setup, mesh, setup%optimize%&
&         optim_parameters, parameters_matrix, parameters_bgd_matrix, &
&         .false.)
        parameters_jreg = parameters_jreg + setup%optimize%wjreg_fun(i)&
&         **2._sp*result1
        result1 = REG_SMOOTHING(setup, mesh, setup%optimize%optim_states&
&         , states_matrix, states_bgd_matrix, .false.)
        states_jreg = states_jreg + setup%optimize%wjreg_fun(i)**2._sp*&
&         result1
      CASE ('distance_correlation') 
        result1 = DISTANCE_CORRELATION_DESCRIPTORS(setup, mesh, &
&         input_data, 'params', gnp, parameters_matrix)
        parameters_jreg = parameters_jreg + setup%optimize%wjreg_fun(i)*&
&         result1
        result1 = DISTANCE_CORRELATION_DESCRIPTORS(setup, mesh, &
&         input_data, 'states', gns, states_matrix)
        states_jreg = states_jreg + setup%optimize%wjreg_fun(i)*result1
      END SELECT
    END DO
    jreg = parameters_jreg + states_jreg
  END SUBROUTINE COMPUTE_JREG

!  Differentiation of compute_cost in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(output.qsim)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.husl1) *(states.husl2) *(states.hlsl)
!                *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in output.qsim:in states.hi:in
!                states.hp:in states.hft:in states.hst:in states.husl1:in
!                states.husl2:in states.hlsl:in states.hlr:in parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
  SUBROUTINE COMPUTE_COST_D(setup, mesh, input_data, parameters, &
&   parameters_d, parameters_bgd, parameters_bgd_d, states, states_d, &
&   states_bgd, states_bgd_d, output, output_d, cost, cost_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(STATESDT), INTENT(IN) :: states_bgd
    TYPE(STATESDT), INTENT(IN) :: states_bgd_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_d
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_d, jreg_d
    CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, jobs&
&                 , jobs_d)
    IF (setup%optimize%denormalize_forward) THEN
      CALL NORMALIZE_PARAMETERS_D(setup, mesh, parameters, parameters_d)
      CALL NORMALIZE_STATES_D(setup, mesh, states, states_d)
    END IF
    CALL COMPUTE_JREG_D(setup, mesh, input_data, parameters, &
&                 parameters_d, parameters_bgd, parameters_bgd_d, states&
&                 , states_d, states_bgd, states_bgd_d, jreg, jreg_d)
    CALL DENORMALIZE_PARAMETERS(setup, mesh, parameters)
    CALL DENORMALIZE_STATES(setup, mesh, states)
    cost_d = jobs_d + setup%optimize%wjreg*jreg_d
  END SUBROUTINE COMPUTE_COST_D

!  Differentiation of compute_cost in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(output.qsim)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.husl1) *(states.husl2) *(states.hlsl)
!                *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in output.qsim:in states.hi:in
!                states.hp:in states.hft:in states.hst:in states.husl1:in
!                states.husl2:in states.hlsl:in states.hlr:in parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
  SUBROUTINE COMPUTE_COST_B(setup, mesh, input_data, parameters, &
&   parameters_b, parameters_bgd, parameters_bgd_b, states, states_b, &
&   states_bgd, states_bgd_b, output, output_b, cost, cost_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
    TYPE(PARAMETERSDT) :: parameters_bgd_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(STATESDT), INTENT(IN) :: states_bgd
    TYPE(STATESDT) :: states_bgd_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_b
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_b, jreg_b
    INTEGER :: branch
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    IF (setup%optimize%denormalize_forward) THEN
      CALL PUSHREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&                   parameters%ci, 2))
      CALL PUSHREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&                   parameters%cp, 2))
      CALL PUSHREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&                   parameters%cft, 2))
      CALL PUSHREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&                   parameters%cst, 2))
      CALL PUSHREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&                   parameters%exc, 2))
      CALL PUSHREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&                   parameters%b, 2))
      CALL PUSHREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*&
&                   SIZE(parameters%cusl1, 2))
      CALL PUSHREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*&
&                   SIZE(parameters%cusl2, 2))
      CALL PUSHREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE&
&                   (parameters%clsl, 2))
      CALL PUSHREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&                   parameters%ks, 2))
      CALL PUSHREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&                   parameters%ds, 2))
      CALL PUSHREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&                   parameters%dsm, 2))
      CALL PUSHREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&                   parameters%ws, 2))
      CALL PUSHREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&                   parameters%lr, 2))
      CALL NORMALIZE_PARAMETERS(setup, mesh, parameters)
      CALL NORMALIZE_STATES(setup, mesh, states)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL COMPUTE_JREG(setup, mesh, input_data, parameters, &
&               parameters_bgd, states, states_bgd, jreg)
    jobs_b = cost_b
    jreg_b = setup%optimize%wjreg*cost_b
    CALL COMPUTE_JREG_B(setup, mesh, input_data, parameters, &
&                 parameters_b, parameters_bgd, parameters_bgd_b, states&
&                 , states_b, states_bgd, states_bgd_b, jreg, jreg_b)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL NORMALIZE_STATES_B(setup, mesh, states, states_b)
      CALL POPREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&                  parameters%lr, 2))
      CALL POPREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&                  parameters%ws, 2))
      CALL POPREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&                  parameters%dsm, 2))
      CALL POPREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&                  parameters%ds, 2))
      CALL POPREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&                  parameters%ks, 2))
      CALL POPREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&                  parameters%clsl, 2))
      CALL POPREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*&
&                  SIZE(parameters%cusl2, 2))
      CALL POPREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*&
&                  SIZE(parameters%cusl1, 2))
      CALL POPREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&                  parameters%b, 2))
      CALL POPREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&                  parameters%exc, 2))
      CALL POPREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&                  parameters%cst, 2))
      CALL POPREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&                  parameters%cft, 2))
      CALL POPREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&                  parameters%cp, 2))
      CALL POPREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&                  parameters%ci, 2))
      CALL NORMALIZE_PARAMETERS_B(setup, mesh, parameters, parameters_b)
    END IF
    CALL COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, jobs&
&                 , jobs_b)
  END SUBROUTINE COMPUTE_COST_B

  SUBROUTINE COMPUTE_COST(setup, mesh, input_data, parameters, &
&   parameters_bgd, states, states_bgd, output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(IN) :: states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp) :: jobs, jreg
    jobs = 0._sp
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    jreg = 0._sp
    IF (setup%optimize%denormalize_forward) THEN
      CALL NORMALIZE_PARAMETERS(setup, mesh, parameters)
      CALL NORMALIZE_STATES(setup, mesh, states)
    END IF
    CALL COMPUTE_JREG(setup, mesh, input_data, parameters, &
&               parameters_bgd, states, states_bgd, jreg)
    IF (setup%optimize%denormalize_forward) THEN
      CALL DENORMALIZE_PARAMETERS(setup, mesh, parameters)
      CALL DENORMALIZE_STATES(setup, mesh, states)
    END IF
    cost = jobs + setup%optimize%wjreg*jreg
    output%cost = cost
    output%cost_jobs = jobs
    output%cost_jreg = jreg
  END SUBROUTINE COMPUTE_COST

!  Differentiation of hyper_compute_cost in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: cost
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
!% TODO comment and refactorize
  SUBROUTINE HYPER_COMPUTE_COST_D(setup, mesh, input_data, &
&   hyper_parameters, hyper_parameters_bgd, hyper_states, &
&   hyper_states_bgd, output, output_d, cost, cost_d)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
&   hyper_parameters_bgd
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_d
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_d
    CALL COMPUTE_JOBS_D(setup, mesh, input_data, output, output_d, jobs&
&                 , jobs_d)
    cost_d = jobs_d
  END SUBROUTINE HYPER_COMPUTE_COST_D

!  Differentiation of hyper_compute_cost in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(output.qsim)
!   Plus diff mem management of: output.qsim:in
!% TODO comment and refactorize
  SUBROUTINE HYPER_COMPUTE_COST_B(setup, mesh, input_data, &
&   hyper_parameters, hyper_parameters_bgd, hyper_states, &
&   hyper_states_bgd, output, output_b, cost, cost_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
&   hyper_parameters_bgd
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp), INTENT(INOUT) :: cost_b
    REAL(sp) :: jobs, jreg
    REAL(sp) :: jobs_b
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    jobs_b = cost_b
    CALL COMPUTE_JOBS_B(setup, mesh, input_data, output, output_b, jobs&
&                 , jobs_b)
  END SUBROUTINE HYPER_COMPUTE_COST_B

!% TODO comment and refactorize
  SUBROUTINE HYPER_COMPUTE_COST(setup, mesh, input_data, &
&   hyper_parameters, hyper_parameters_bgd, hyper_states, &
&   hyper_states_bgd, output, cost)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
&   hyper_parameters_bgd
    TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    REAL(sp), INTENT(INOUT) :: cost
    REAL(sp) :: jobs, jreg
    CALL COMPUTE_JOBS(setup, mesh, input_data, output, jobs)
    jreg = 0._sp
    cost = jobs + setup%optimize%wjreg*jreg
    output%cost = cost
    output%cost_jobs = jobs
  END SUBROUTINE HYPER_COMPUTE_COST

!  Differentiation of nse in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION NSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_d, sum_xy_d, num_d
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    sum_yy_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num_d = sum_yy_d - 2*sum_xy_d
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res_d = num_d/den
    res = num/den
  END FUNCTION NSE_D

!  Differentiation of nse in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE NSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    REAL(sp) :: sum_yy_b, sum_xy_b, num_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
!% NSE numerator / denominator
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    num_b = res_b/den
    sum_yy_b = num_b
    sum_xy_b = -(2*num_b)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b
    END DO
  END SUBROUTINE NSE_B

  FUNCTION NSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: sum_x, sum_xx, sum_yy, sum_xy, mean_x, num, den
    INTEGER :: i, n
    INTRINSIC SIZE
!% Metric computation
    n = 0
    sum_x = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
!% NSE numerator / denominator
    num = sum_xx - 2*sum_xy + sum_yy
    den = sum_xx - n*mean_x*mean_x
!% NSE criterion
    res = num/den
  END FUNCTION NSE

!  Differentiation of kge_components in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: r a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp), INTENT(INOUT) :: r, a, b
    REAL(sp), INTENT(INOUT) :: r_d, a_d, b_d
    REAL(sp) :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, &
&   var_x, var_y, cov
    REAL(sp) :: sum_y_d, sum_yy_d, sum_xy_d, mean_y_d, var_y_d, cov_d
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: result2
    REAL(sp) :: result2_d
    REAL(sp) :: temp
! Metric computation
    n = 0
    sum_x = 0._sp
    sum_y = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    sum_yy_d = 0.0_4
    sum_y_d = 0.0_4
    sum_xy_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y_d = sum_y_d + y_d(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy_d = sum_yy_d + 2*y(i)*y_d(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy_d = sum_xy_d + x(i)*y_d(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y_d = sum_y_d/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y_d = sum_yy_d/n - 2*mean_y*mean_y_d
    var_y = sum_yy/n - mean_y*mean_y
    cov_d = sum_xy_d/n - mean_x*mean_y_d
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result2_d = 0.0_4
    ELSE
      result2_d = var_y_d/(2.0*temp)
    END IF
    result2 = temp
    temp = cov/(result1*result2)
    r_d = (cov_d-temp*result1*result2_d)/(result1*result2)
    r = temp
    temp = SQRT(var_y)
    IF (var_y .EQ. 0.0) THEN
      result1_d = 0.0_4
    ELSE
      result1_d = var_y_d/(2.0*temp)
    END IF
    result1 = temp
    result2 = SQRT(var_x)
    a_d = result1_d/result2
    a = result1/result2
    b_d = mean_y_d/mean_x
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS_D

!  Differentiation of kge_components in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: r y a b
!   with respect to varying inputs: y
  SUBROUTINE KGE_COMPONENTS_B(x, y, y_b, r, r_b, a, a_b, b, b_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp), INTENT(INOUT) :: r, a, b
    REAL(sp), INTENT(INOUT) :: r_b, a_b, b_b
    REAL(sp) :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, &
&   var_x, var_y, cov
    REAL(sp) :: sum_y_b, sum_yy_b, sum_xy_b, mean_y_b, var_y_b, cov_b
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    REAL(sp) :: result2
    REAL(sp) :: result2_b
    REAL(sp) :: temp_b
    INTEGER :: ad_to
    INTEGER :: branch
! Metric computation
    n = 0
    sum_x = 0._sp
    sum_y = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    CALL PUSHREAL4(result2)
    result2 = SQRT(var_x)
    result1_b = a_b/result2
    CALL POPREAL4(result2)
    IF (var_y .EQ. 0.0) THEN
      var_y_b = 0.0_4
    ELSE
      var_y_b = result1_b/(2.0*SQRT(var_y))
    END IF
    temp_b = r_b/(result1*result2)
    cov_b = temp_b
    result2_b = -(cov*temp_b/result2)
    IF (.NOT.var_y .EQ. 0.0) var_y_b = var_y_b + result2_b/(2.0*SQRT(&
&       var_y))
    mean_y_b = b_b/mean_x - mean_x*cov_b - 2*mean_y*var_y_b
    sum_xy_b = cov_b/n
    sum_yy_b = var_y_b/n
    sum_y_b = mean_y_b/n
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) + x(i)*sum_xy_b + 2*y(i)*&
&         sum_yy_b + sum_y_b
    END DO
  END SUBROUTINE KGE_COMPONENTS_B

  SUBROUTINE KGE_COMPONENTS(x, y, r, a, b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), INTENT(INOUT) :: r, a, b
    REAL(sp) :: sum_x, sum_y, sum_xx, sum_yy, sum_xy, mean_x, mean_y, &
&   var_x, var_y, cov
    INTEGER :: n, i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result2
! Metric computation
    n = 0
    sum_x = 0._sp
    sum_y = 0._sp
    sum_xx = 0._sp
    sum_yy = 0._sp
    sum_xy = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        n = n + 1
        sum_x = sum_x + x(i)
        sum_y = sum_y + y(i)
        sum_xx = sum_xx + x(i)*x(i)
        sum_yy = sum_yy + y(i)*y(i)
        sum_xy = sum_xy + x(i)*y(i)
      END IF
    END DO
    mean_x = sum_x/n
    mean_y = sum_y/n
    var_x = sum_xx/n - mean_x*mean_x
    var_y = sum_yy/n - mean_y*mean_y
    cov = sum_xy/n - mean_x*mean_y
! KGE components (r, alpha, beta)
    result1 = SQRT(var_x)
    result2 = SQRT(var_y)
    r = cov/result1/result2
    result1 = SQRT(var_y)
    result2 = SQRT(var_x)
    a = result1/result2
    b = mean_y/mean_x
  END SUBROUTINE KGE_COMPONENTS

!  Differentiation of kge in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION KGE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    REAL(sp) :: r, a, b
    REAL(sp) :: r_d, a_d, b_d
    INTRINSIC SQRT
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    CALL KGE_COMPONENTS_D(x, y, y_d, r, r_d, a, a_d, b, b_d)
! KGE criterion
    arg1_d = 2*(r-1)*r_d + 2*(b-1)*b_d + 2*(a-1)*a_d
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      res_d = 0.0_4
    ELSE
      res_d = arg1_d/(2.0*temp)
    END IF
    res = temp
  END FUNCTION KGE_D

!  Differentiation of kge in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE KGE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    REAL(sp) :: r, a, b
    REAL(sp) :: r_b, a_b, b_b
    INTRINSIC SQRT
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    IF (arg1 .EQ. 0.0) THEN
      arg1_b = 0.0_4
    ELSE
      arg1_b = res_b/(2.0*SQRT(arg1))
    END IF
    r_b = 2*(r-1)*arg1_b
    b_b = 2*(b-1)*arg1_b
    a_b = 2*(a-1)*arg1_b
    CALL KGE_COMPONENTS_B(x, y, y_b, r, r_b, a, a_b, b, b_b)
  END SUBROUTINE KGE_B

  FUNCTION KGE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    REAL(sp) :: r, a, b
    INTRINSIC SQRT
    REAL(sp) :: arg1
    CALL KGE_COMPONENTS(x, y, r, a, b)
! KGE criterion
    arg1 = (r-1)*(r-1) + (b-1)*(b-1) + (a-1)*(a-1)
    res = SQRT(arg1)
  END FUNCTION KGE

!  Differentiation of se in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION SE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    res = 0._sp
    res_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        res_d = res_d - 2*(x(i)-y(i))*y_d(i)
        res = res + (x(i)-y(i))*(x(i)-y(i))
      END IF
    END DO
  END FUNCTION SE_D

!  Differentiation of se in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE SE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) y_b(i) = y_b(i) - 2*(x(i)-y(i))*res_b
    END DO
  END SUBROUTINE SE_B

  FUNCTION SE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i
    INTRINSIC SIZE
    res = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) res = res + (x(i)-y(i))*(x(i)-y(i))
    END DO
  END FUNCTION SE

!  Differentiation of rmse in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION RMSE_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_d
    REAL(sp) :: temp
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) n = n + 1
    END DO
    result1_d = SE_D(x, y, y_d, result1)
    temp = SQRT(result1/n)
    IF (result1/n .EQ. 0.0) THEN
      res_d = 0.0_4
    ELSE
      res_d = result1_d/(2.0*temp*n)
    END IF
    res = temp
  END FUNCTION RMSE_D

!  Differentiation of rmse in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE RMSE_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    REAL(sp) :: result1_b
    INTEGER :: ad_to
    INTEGER :: branch
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) THEN
        CALL PUSHCONTROL1B(1)
        n = n + 1
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHINTEGER4(i - 1)
    result1 = SE(x, y)
    IF (result1/n .EQ. 0.0) THEN
      result1_b = 0.0_4
    ELSE
      result1_b = res_b/(n*2.0*SQRT(result1/n))
    END IF
    CALL SE_B(x, y, y_b, result1_b)
    CALL POPINTEGER4(ad_to)
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
    END DO
  END SUBROUTINE RMSE_B

  FUNCTION RMSE(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i, n
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(sp) :: result1
    n = 0
    DO i=1,SIZE(x)
      IF (x(i) .GE. 0._sp) n = n + 1
    END DO
    result1 = SE(x, y)
    res = SQRT(result1/n)
  END FUNCTION RMSE

!  Differentiation of logarithmic in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: y
  FUNCTION LOGARITHMIC_D(x, y, y_d, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:), INTENT(IN) :: y_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: arg2
    REAL(sp) :: arg2_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    res = 0._sp
    res_d = 0.0_4
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0._sp .AND. y(i) .GT. 0._sp) THEN
        arg1_d = y_d(i)/x(i)
        arg1 = y(i)/x(i)
        arg2_d = y_d(i)/x(i)
        arg2 = y(i)/x(i)
        temp = LOG(arg2)
        temp0 = LOG(arg1)
        res_d = res_d + x(i)*(temp*arg1_d/arg1+temp0*arg2_d/arg2)
        res = res + x(i)*(temp0*temp)
      END IF
    END DO
  END FUNCTION LOGARITHMIC_D

!  Differentiation of logarithmic in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res y
!   with respect to varying inputs: y
  SUBROUTINE LOGARITHMIC_B(x, y, y_b, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp), DIMENSION(:) :: y_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    REAL(sp) :: arg2
    REAL(sp) :: arg2_b
    INTEGER :: ad_to
    INTEGER :: branch
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0._sp .AND. y(i) .GT. 0._sp) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to = i - 1
    DO i=ad_to,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        arg1_b = LOG(arg2)*x(i)*res_b/arg1
        arg2_b = LOG(arg1)*x(i)*res_b/arg2
        y_b(i) = y_b(i) + arg2_b/x(i) + arg1_b/x(i)
      END IF
    END DO
  END SUBROUTINE LOGARITHMIC_B

  FUNCTION LOGARITHMIC(x, y) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: x, y
    REAL(sp) :: res
    INTEGER :: i
    INTRINSIC SIZE
    INTRINSIC LOG
    REAL(sp) :: arg1
    REAL(sp) :: arg2
    res = 0._sp
    DO i=1,SIZE(x)
      IF (x(i) .GT. 0._sp .AND. y(i) .GT. 0._sp) THEN
        arg1 = y(i)/x(i)
        arg2 = y(i)/x(i)
        res = res + x(i)*LOG(arg1)*LOG(arg2)
      END IF
    END DO
  END FUNCTION LOGARITHMIC

!  Differentiation of heap_sort in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: arr
!   with respect to varying inputs: arr
  SUBROUTINE HEAP_SORT_D(n, arr, arr_d)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr_d
    INTEGER :: l, ir, i, j
    REAL(sp) :: arr_l
    REAL(sp) :: arr_l_d
    l = n/2 + 1
    ir = n
 10 IF (l .GT. 1) THEN
      l = l - 1
      arr_l_d = arr_d(l)
      arr_l = arr(l)
    ELSE
      arr_l_d = arr_d(ir)
      arr_l = arr(ir)
      arr_d(ir) = arr_d(1)
      arr(ir) = arr(1)
      ir = ir - 1
      IF (ir .EQ. 1) GOTO 100
    END IF
    i = l
    j = l + l
 20 IF (j .LE. ir) THEN
      IF (j .LT. ir) THEN
        IF (arr(j) .LT. arr(j+1)) j = j + 1
      END IF
      IF (arr_l .LT. arr(j)) THEN
        arr_d(i) = arr_d(j)
        arr(i) = arr(j)
        i = j
        j = j + j
      ELSE
        j = ir + 1
      END IF
      GOTO 20
    END IF
    arr_d(i) = arr_l_d
    arr(i) = arr_l
    GOTO 10
 100 arr_d(1) = arr_l_d
    arr(1) = arr_l
  END SUBROUTINE HEAP_SORT_D

!  Differentiation of heap_sort in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: arr
!   with respect to varying inputs: arr
  SUBROUTINE HEAP_SORT_B(n, arr, arr_b)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr_b
    INTEGER :: l, ir, i, j
    REAL(sp) :: arr_l
    REAL(sp) :: arr_l_b
    REAL(sp) :: tmp
    REAL(sp) :: tmp_b
    REAL(sp) :: tmp0
    REAL(sp) :: tmp_b0
    INTEGER :: branch
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: ad_count0
    INTEGER :: i1
    l = n/2 + 1
    ir = n
    ad_count0 = 1
 10 IF (l .GT. 1) THEN
      CALL PUSHINTEGER4(l)
      l = l - 1
      arr_l = arr(l)
      CALL PUSHCONTROL1B(0)
    ELSE
      arr_l = arr(ir)
      tmp = arr(1)
      arr(ir) = tmp
      CALL PUSHINTEGER4(ir)
      ir = ir - 1
      IF (ir .EQ. 1) THEN
        GOTO 100
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END IF
    CALL PUSHINTEGER4(i)
    i = l
    j = l + l
    ad_count = 1
 20 IF (j .LE. ir) THEN
      IF (j .LT. ir) THEN
        IF (arr(j) .LT. arr(j+1)) THEN
          CALL PUSHCONTROL1B(0)
          j = j + 1
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (arr_l .LT. arr(j)) THEN
        tmp0 = arr(j)
        arr(i) = tmp0
        CALL PUSHINTEGER4(i)
        i = j
        CALL PUSHINTEGER4(j)
        j = j + j
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
        j = ir + 1
      END IF
      ad_count = ad_count + 1
      GOTO 20
    END IF
    CALL PUSHINTEGER4(ad_count)
    arr(i) = arr_l
    ad_count0 = ad_count0 + 1
    GOTO 10
 100 CALL PUSHINTEGER4(ad_count0)
    arr_l_b = arr_b(1)
    arr_b(1) = 0.0_4
    CALL POPINTEGER4(ad_count0)
    DO 110 i1=1,ad_count0
      IF (i1 .NE. 1) THEN
        arr_l_b = arr_b(i)
        arr_b(i) = 0.0_4
        CALL POPINTEGER4(ad_count)
        DO i0=1,ad_count
          IF (i0 .NE. 1) THEN
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              CALL POPINTEGER4(j)
              CALL POPINTEGER4(i)
              tmp_b0 = arr_b(i)
              arr_b(i) = 0.0_4
              arr_b(j) = arr_b(j) + tmp_b0
            END IF
            CALL POPCONTROL1B(branch)
          END IF
        END DO
        CALL POPINTEGER4(i)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          arr_b(l) = arr_b(l) + arr_l_b
          CALL POPINTEGER4(l)
          GOTO 110
        END IF
      END IF
      CALL POPINTEGER4(ir)
      tmp_b = arr_b(ir)
      arr_b(ir) = 0.0_4
      arr_b(1) = arr_b(1) + tmp_b
      arr_b(ir) = arr_b(ir) + arr_l_b
 110 CONTINUE
  END SUBROUTINE HEAP_SORT_B

  SUBROUTINE HEAP_SORT(n, arr)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(sp), DIMENSION(n), INTENT(INOUT) :: arr
    INTEGER :: l, ir, i, j
    REAL(sp) :: arr_l
    l = n/2 + 1
    ir = n
 10 IF (l .GT. 1) THEN
      l = l - 1
      arr_l = arr(l)
    ELSE
      arr_l = arr(ir)
      arr(ir) = arr(1)
      ir = ir - 1
      IF (ir .EQ. 1) THEN
        arr(1) = arr_l
        RETURN
      END IF
    END IF
    i = l
    j = l + l
 20 IF (j .LE. ir) THEN
      IF (j .LT. ir) THEN
        IF (arr(j) .LT. arr(j+1)) j = j + 1
      END IF
      IF (arr_l .LT. arr(j)) THEN
        arr(i) = arr(j)
        i = j
        j = j + j
      ELSE
        j = ir + 1
      END IF
      GOTO 20
    ELSE
      arr(i) = arr_l
      GOTO 10
    END IF
  END SUBROUTINE HEAP_SORT

!  Differentiation of quantile in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: dat
  FUNCTION QUANTILE_D(dat, dat_d, p, res) RESULT (RES_D)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: p
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat_d
    INTEGER :: n
    REAL(sp) :: res, q1, q2, frac
    REAL(sp) :: res_d, q1_d, q2_d
    INTRINSIC INT
    REAL(sp) :: temp
    res_d = dat_d(1)
    res = dat(1)
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat_d = dat_d
      sorted_dat = dat
      CALL HEAP_SORT_D(n, sorted_dat, sorted_dat_d)
      frac = (n-1)*p + 1
      IF (frac .LE. 1) THEN
        res_d = sorted_dat_d(1)
        res = sorted_dat(1)
      ELSE IF (frac .GE. n) THEN
        res_d = sorted_dat_d(n)
        res = sorted_dat(n)
      ELSE
        q1_d = sorted_dat_d(INT(frac))
        q1 = sorted_dat(INT(frac))
        q2_d = sorted_dat_d(INT(frac)+1)
        q2 = sorted_dat(INT(frac)+1)
! linear interpolation
        temp = frac - INT(frac)
        res_d = q1_d + temp*(q2_d-q1_d)
        res = q1 + temp*(q2-q1)
      END IF
    END IF
  END FUNCTION QUANTILE_D

!  Differentiation of quantile in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res
!   with respect to varying inputs: dat
  SUBROUTINE QUANTILE_B(dat, dat_b, p, res_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: p
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    REAL(sp), DIMENSION(:) :: dat_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat_b
    INTEGER :: n
    REAL(sp) :: res, q1, q2, frac
    REAL(sp) :: res_b, q1_b, q2_b
    INTRINSIC INT
    REAL(sp) :: temp_b
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat = dat
      CALL PUSHREAL4ARRAY(sorted_dat, SIZE(dat))
      CALL HEAP_SORT(n, sorted_dat)
      frac = (n-1)*p + 1
      IF (frac .LE. 1) THEN
        sorted_dat_b = 0.0_4
        sorted_dat_b(1) = sorted_dat_b(1) + res_b
      ELSE IF (frac .GE. n) THEN
        sorted_dat_b = 0.0_4
        sorted_dat_b(n) = sorted_dat_b(n) + res_b
      ELSE
        frac = (n-1)*p + 1
        temp_b = (frac-INT(frac))*res_b
        q1_b = res_b - temp_b
        q2_b = temp_b
        sorted_dat_b = 0.0_4
        sorted_dat_b(INT(frac)+1) = sorted_dat_b(INT(frac)+1) + q2_b
        sorted_dat_b(INT(frac)) = sorted_dat_b(INT(frac)) + q1_b
      END IF
      CALL POPREAL4ARRAY(sorted_dat, SIZE(dat))
      CALL HEAP_SORT_B(n, sorted_dat, sorted_dat_b)
      dat_b = 0.0_4
      dat_b = sorted_dat_b
      res_b = 0.0_4
    ELSE
      dat_b = 0.0_4
    END IF
    dat_b(1) = dat_b(1) + res_b
  END SUBROUTINE QUANTILE_B

  FUNCTION QUANTILE(dat, p) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: p
    REAL(sp), DIMENSION(:), INTENT(IN) :: dat
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(dat)) :: sorted_dat
    INTEGER :: n
    REAL(sp) :: res, q1, q2, frac
    INTRINSIC INT
    res = dat(1)
    n = SIZE(dat)
    IF (n .GT. 1) THEN
      sorted_dat = dat
      CALL HEAP_SORT(n, sorted_dat)
      frac = (n-1)*p + 1
      IF (frac .LE. 1) THEN
        res = sorted_dat(1)
      ELSE IF (frac .GE. n) THEN
        res = sorted_dat(n)
      ELSE
        q1 = sorted_dat(INT(frac))
        q2 = sorted_dat(INT(frac)+1)
! linear interpolation
        res = q1 + (q2-q1)*(frac-INT(frac))
      END IF
    END IF
  END FUNCTION QUANTILE

!  Differentiation of flow_percentile in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: num
!   with respect to varying inputs: qs
  SUBROUTINE FLOW_PERCENTILE_D(qo, qs, qs_d, p, num, num_d, den)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: qo, qs
    REAL(sp), DIMENSION(:), INTENT(IN) :: qs_d
    REAL(sp), INTENT(IN) :: p
    REAL(sp), INTENT(INOUT) :: num, den
    REAL(sp), INTENT(INOUT) :: num_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(qo)) :: pos_qo, pos_qs
    REAL(sp), DIMENSION(SIZE(qo)) :: pos_qs_d
    INTEGER :: i, j, n
    n = SIZE(qo)
    pos_qo = 0._sp
    pos_qs = 0._sp
    j = 0
    pos_qs_d = 0.0_4
    DO i=1,n
      IF (qo(i) .GE. 0._sp .AND. qs(i) .GE. 0._sp) THEN
        j = j + 1
        pos_qo(j) = qo(i)
        pos_qs_d(j) = qs_d(i)
        pos_qs(j) = qs(i)
      END IF
    END DO
    num_d = QUANTILE_D(pos_qs(1:j), pos_qs_d(1:j), p, num)
    den = QUANTILE(pos_qo(1:j), p)
  END SUBROUTINE FLOW_PERCENTILE_D

!  Differentiation of flow_percentile in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: qs num
!   with respect to varying inputs: qs
  SUBROUTINE FLOW_PERCENTILE_B(qo, qs, qs_b, p, num, num_b, den)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: qo, qs
    REAL(sp), DIMENSION(:) :: qs_b
    REAL(sp), INTENT(IN) :: p
    REAL(sp), INTENT(INOUT) :: num, den
    REAL(sp), INTENT(INOUT) :: num_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(qo)) :: pos_qo, pos_qs
    REAL(sp), DIMENSION(SIZE(qo)) :: pos_qs_b
    INTEGER :: i, j, n
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: branch
    n = SIZE(qo)
    pos_qs = 0._sp
    j = 0
    DO i=1,n
      IF (qo(i) .GE. 0._sp .AND. qs(i) .GE. 0._sp) THEN
        CALL PUSHINTEGER4(j)
        j = j + 1
        pos_qs(j) = qs(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    res = QUANTILE(pos_qs(1:j), p)
    pos_qs_b = 0.0_4
    res_b = num_b
    CALL QUANTILE_B(pos_qs(1:j), pos_qs_b(1:j), p, res_b)
    DO i=n,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        qs_b(i) = qs_b(i) + pos_qs_b(j)
        pos_qs_b(j) = 0.0_4
        CALL POPINTEGER4(j)
      END IF
    END DO
  END SUBROUTINE FLOW_PERCENTILE_B

  SUBROUTINE FLOW_PERCENTILE(qo, qs, p, num, den)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: qo, qs
    REAL(sp), INTENT(IN) :: p
    REAL(sp), INTENT(INOUT) :: num, den
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(qo)) :: pos_qo, pos_qs
    INTEGER :: i, j, n
    n = SIZE(qo)
    pos_qo = 0._sp
    pos_qs = 0._sp
    j = 0
    DO i=1,n
      IF (qo(i) .GE. 0._sp .AND. qs(i) .GE. 0._sp) THEN
        j = j + 1
        pos_qo(j) = qo(i)
        pos_qs(j) = qs(i)
      END IF
    END DO
    num = QUANTILE(pos_qs(1:j), p)
    den = QUANTILE(pos_qo(1:j), p)
  END SUBROUTINE FLOW_PERCENTILE

!  Differentiation of signature in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: qs
  FUNCTION SIGNATURE_D(po, qo, qs, qs_d, mask_event, stype, res) RESULT &
& (RES_D)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: po, qo, qs
    REAL(sp), DIMENSION(:), INTENT(IN) :: qs_d
    INTEGER, DIMENSION(:), INTENT(IN) :: mask_event
    CHARACTER(len=*), INTENT(IN) :: stype
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(mask_event)) :: lgc_mask_event
    INTEGER :: n_event, i, j, start_event, ntime_step_event
    REAL(sp) :: sum_qo, sum_qs, sum_po, max_qo, max_qs, max_po, num, den
    REAL(sp) :: sum_qs_d, max_qs_d, num_d
    INTEGER :: imax_qo, imax_qs, imax_po
    INTRINSIC COUNT
    INTRINSIC ABS
    REAL(sp) :: abs0
    REAL(sp) :: abs0_d
    res = 0._sp
    n_event = 0
    IF (stype(:1) .EQ. 'E') THEN
! Reverse loop on mask_event to find number of event (array sorted filled with 0)
      DO i=SIZE(mask_event),1,-1
        IF (mask_event(i) .GT. 0) GOTO 100
      END DO
      res_d = 0.0_4
      num_d = 0.0_4
      GOTO 130
 100  n_event = mask_event(i)
      res_d = 0.0_4
      num_d = 0.0_4
 130  DO i=1,n_event
        lgc_mask_event = mask_event .EQ. i
        DO j=1,SIZE(mask_event)
          IF (lgc_mask_event(j)) GOTO 110
        END DO
        GOTO 120
 110    start_event = j
 120    ntime_step_event = COUNT(lgc_mask_event)
        sum_qo = 0._sp
        sum_qs = 0._sp
        sum_po = 0._sp
        max_qo = 0._sp
        max_qs = 0._sp
        max_po = 0._sp
        imax_qo = 0
        imax_qs = 0
        imax_po = 0
        max_qs_d = 0.0_4
        sum_qs_d = 0.0_4
        DO j=start_event,start_event+ntime_step_event-1
          IF (qo(j) .GE. 0._sp .AND. po(j) .GE. 0._sp) THEN
            sum_qo = sum_qo + qo(j)
            sum_qs_d = sum_qs_d + qs_d(j)
            sum_qs = sum_qs + qs(j)
            sum_po = sum_po + po(j)
            IF (qo(j) .GT. max_qo) THEN
              max_qo = qo(j)
              imax_qo = j
            END IF
            IF (qs(j) .GT. max_qs) THEN
              max_qs_d = qs_d(j)
              max_qs = qs(j)
              imax_qs = j
            END IF
            IF (po(j) .GT. max_po) THEN
              max_po = po(j)
              imax_po = j
            END IF
          END IF
        END DO
        SELECT CASE  (stype) 
        CASE ('Epf') 
          num_d = max_qs_d
          num = max_qs
          den = max_qo
        CASE ('Elt') 
          num = imax_qs - imax_po
          den = imax_qo - imax_po
          num_d = 0.0_4
        CASE ('Erc') 
          IF (sum_po .GT. 0._sp) THEN
            num_d = sum_qs_d/sum_po
            num = sum_qs/sum_po
            den = sum_qo/sum_po
          END IF
        END SELECT
        IF (den .GT. 0._sp) THEN
          IF (num/den - 1._sp .GE. 0.) THEN
            abs0_d = num_d/den
            abs0 = num/den - 1._sp
          ELSE
            abs0_d = -(num_d/den)
            abs0 = -(num/den-1._sp)
          END IF
          res_d = res_d + abs0_d
          res = res + abs0
        END IF
      END DO
      IF (n_event .GT. 0) THEN
        res_d = res_d/n_event
        res = res/n_event
      END IF
    ELSE
      SELECT CASE  (stype) 
      CASE ('Crc') 
        sum_qo = 0._sp
        sum_qs = 0._sp
        sum_po = 0._sp
        sum_qs_d = 0.0_4
        DO i=1,SIZE(qo)
          IF (qo(i) .GE. 0._sp .AND. po(i) .GE. 0._sp) THEN
            sum_qo = sum_qo + qo(i)
            sum_qs_d = sum_qs_d + qs_d(i)
            sum_qs = sum_qs + qs(i)
            sum_po = sum_po + po(i)
          END IF
        END DO
        IF (sum_po .GT. 0._sp) THEN
          num_d = sum_qs_d/sum_po
          num = sum_qs/sum_po
          den = sum_qo/sum_po
        ELSE
          num_d = 0.0_4
        END IF
      CASE ('Cfp2') 
        CALL FLOW_PERCENTILE_D(qo, qs, qs_d, 0.02_sp, num, num_d, den)
      CASE ('Cfp10') 
        CALL FLOW_PERCENTILE_D(qo, qs, qs_d, 0.1_sp, num, num_d, den)
      CASE ('Cfp50') 
        CALL FLOW_PERCENTILE_D(qo, qs, qs_d, 0.5_sp, num, num_d, den)
      CASE ('Cfp90') 
        CALL FLOW_PERCENTILE_D(qo, qs, qs_d, 0.9_sp, num, num_d, den)
      CASE DEFAULT
        num_d = 0.0_4
      END SELECT
      IF (den .GT. 0._sp) THEN
        IF (num/den - 1._sp .GE. 0.) THEN
          res_d = num_d/den
          res = num/den - 1._sp
        ELSE
          res_d = -(num_d/den)
          res = -(num/den-1._sp)
        END IF
      ELSE
        res_d = 0.0_4
      END IF
    END IF
  END FUNCTION SIGNATURE_D

!  Differentiation of signature in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res qs
!   with respect to varying inputs: qs
  SUBROUTINE SIGNATURE_B(po, qo, qs, qs_b, mask_event, stype, res_b)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: po, qo, qs
    REAL(sp), DIMENSION(:) :: qs_b
    INTEGER, DIMENSION(:), INTENT(IN) :: mask_event
    CHARACTER(len=*), INTENT(IN) :: stype
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(mask_event)) :: lgc_mask_event
    INTEGER :: n_event, i, j, start_event, ntime_step_event
    REAL(sp) :: sum_qo, sum_qs, sum_po, max_qo, max_qs, max_po, num, den
    REAL(sp) :: sum_qs_b, max_qs_b, num_b
    INTEGER :: imax_qo, imax_qs, imax_po
    INTRINSIC COUNT
    INTRINSIC ABS
    REAL(sp) :: abs0
    REAL(sp) :: abs0_b
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    INTEGER :: ad_count0
    INTEGER :: i1
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_to0
    n_event = 0
    IF (stype(:1) .EQ. 'E') THEN
      ad_count = 1
! Reverse loop on mask_event to find number of event (array sorted filled with 0)
      DO i=SIZE(mask_event),1,-1
        IF (mask_event(i) .GT. 0) THEN
          GOTO 100
        ELSE
          ad_count = ad_count + 1
        END IF
      END DO
      CALL PUSHCONTROL1B(0)
      CALL PUSHINTEGER4(ad_count)
      GOTO 130
 100  CALL PUSHCONTROL1B(1)
      CALL PUSHINTEGER4(ad_count)
      n_event = mask_event(i)
 130  DO i=1,n_event
        lgc_mask_event = mask_event .EQ. i
        ad_count0 = 1
        DO j=1,SIZE(mask_event)
          IF (lgc_mask_event(j)) THEN
            GOTO 110
          ELSE
            ad_count0 = ad_count0 + 1
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
        CALL PUSHINTEGER4(ad_count0)
        GOTO 120
 110    CALL PUSHCONTROL1B(1)
        CALL PUSHINTEGER4(ad_count0)
        start_event = j
 120    ntime_step_event = COUNT(lgc_mask_event)
        sum_qo = 0._sp
        sum_qs = 0._sp
        CALL PUSHREAL4(sum_po)
        sum_po = 0._sp
        max_qo = 0._sp
        max_qs = 0._sp
        max_po = 0._sp
        imax_qo = 0
        imax_qs = 0
        imax_po = 0
        ad_from = start_event
        DO j=ad_from,start_event+ntime_step_event-1
          IF (qo(j) .GE. 0._sp .AND. po(j) .GE. 0._sp) THEN
            sum_qo = sum_qo + qo(j)
            sum_qs = sum_qs + qs(j)
            sum_po = sum_po + po(j)
            IF (qo(j) .GT. max_qo) THEN
              max_qo = qo(j)
              imax_qo = j
            END IF
            IF (qs(j) .GT. max_qs) THEN
              max_qs = qs(j)
              imax_qs = j
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (po(j) .GT. max_po) THEN
              CALL PUSHCONTROL2B(2)
              max_po = po(j)
              imax_po = j
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from)
        SELECT CASE  (stype) 
        CASE ('Epf') 
          num = max_qs
          CALL PUSHREAL4(den)
          den = max_qo
          CALL PUSHCONTROL3B(1)
        CASE ('Elt') 
          num = imax_qs - imax_po
          CALL PUSHREAL4(den)
          den = imax_qo - imax_po
          CALL PUSHCONTROL3B(2)
        CASE ('Erc') 
          IF (sum_po .GT. 0._sp) THEN
            num = sum_qs/sum_po
            CALL PUSHREAL4(den)
            den = sum_qo/sum_po
            CALL PUSHCONTROL3B(3)
          ELSE
            CALL PUSHCONTROL3B(4)
          END IF
        CASE DEFAULT
          CALL PUSHCONTROL3B(0)
        END SELECT
        IF (den .GT. 0._sp) THEN
          IF (num/den - 1._sp .GE. 0.) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      IF (n_event .GT. 0) res_b = res_b/n_event
      num_b = 0.0_4
      DO i=n_event,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          abs0_b = res_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            num_b = num_b + abs0_b/den
          ELSE
            num_b = num_b - abs0_b/den
          END IF
        END IF
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            max_qs_b = 0.0_4
            sum_qs_b = 0.0_4
          ELSE
            CALL POPREAL4(den)
            max_qs_b = num_b
            num_b = 0.0_4
            sum_qs_b = 0.0_4
          END IF
        ELSE IF (branch .EQ. 2) THEN
          CALL POPREAL4(den)
          max_qs_b = 0.0_4
          num_b = 0.0_4
          sum_qs_b = 0.0_4
        ELSE
          IF (branch .EQ. 3) THEN
            CALL POPREAL4(den)
            sum_qs_b = num_b/sum_po
            num_b = 0.0_4
          ELSE
            sum_qs_b = 0.0_4
          END IF
          max_qs_b = 0.0_4
        END IF
        CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to)
        DO 140 j=ad_to,ad_from,-1
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) GOTO 140
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            qs_b(j) = qs_b(j) + max_qs_b
            max_qs_b = 0.0_4
          END IF
          qs_b(j) = qs_b(j) + sum_qs_b
 140    CONTINUE
        CALL POPREAL4(sum_po)
        CALL POPINTEGER4(ad_count0)
        DO i1=1,ad_count0
          IF (i1 .EQ. 1) CALL POPCONTROL1B(branch)
        END DO
      END DO
      CALL POPINTEGER4(ad_count)
      DO i0=1,ad_count
        IF (i0 .EQ. 1) CALL POPCONTROL1B(branch)
      END DO
    ELSE
      SELECT CASE  (stype) 
      CASE ('Crc') 
        sum_qo = 0._sp
        sum_qs = 0._sp
        sum_po = 0._sp
        DO i=1,SIZE(qo)
          IF (qo(i) .GE. 0._sp .AND. po(i) .GE. 0._sp) THEN
            sum_qo = sum_qo + qo(i)
            sum_qs = sum_qs + qs(i)
            sum_po = sum_po + po(i)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHINTEGER4(i - 1)
        IF (sum_po .GT. 0._sp) THEN
          num = sum_qs/sum_po
          den = sum_qo/sum_po
          CALL PUSHCONTROL3B(1)
        ELSE
          CALL PUSHCONTROL3B(2)
        END IF
      CASE ('Cfp2') 
        CALL FLOW_PERCENTILE(qo, qs, 0.02_sp, num, den)
        CALL PUSHCONTROL3B(3)
      CASE ('Cfp10') 
        CALL FLOW_PERCENTILE(qo, qs, 0.1_sp, num, den)
        CALL PUSHCONTROL3B(4)
      CASE ('Cfp50') 
        CALL FLOW_PERCENTILE(qo, qs, 0.5_sp, num, den)
        CALL PUSHCONTROL3B(5)
      CASE ('Cfp90') 
        CALL FLOW_PERCENTILE(qo, qs, 0.9_sp, num, den)
        CALL PUSHCONTROL3B(6)
      CASE DEFAULT
        CALL PUSHCONTROL3B(0)
      END SELECT
      IF (den .GT. 0._sp) THEN
        IF (num/den - 1._sp .GE. 0.) THEN
          num_b = res_b/den
        ELSE
          num_b = -(res_b/den)
        END IF
      ELSE
        num_b = 0.0_4
      END IF
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 3) THEN
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            sum_qs_b = num_b/sum_po
          ELSE
            sum_qs_b = 0.0_4
          END IF
          CALL POPINTEGER4(ad_to0)
          DO i=ad_to0,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) qs_b(i) = qs_b(i) + sum_qs_b
          END DO
        END IF
      ELSE IF (branch .LT. 5) THEN
        IF (branch .EQ. 3) THEN
          CALL FLOW_PERCENTILE_B(qo, qs, qs_b, 0.02_sp, num, num_b, den)
        ELSE
          CALL FLOW_PERCENTILE_B(qo, qs, qs_b, 0.1_sp, num, num_b, den)
        END IF
      ELSE IF (branch .EQ. 5) THEN
        CALL FLOW_PERCENTILE_B(qo, qs, qs_b, 0.5_sp, num, num_b, den)
      ELSE
        CALL FLOW_PERCENTILE_B(qo, qs, qs_b, 0.9_sp, num, num_b, den)
      END IF
    END IF
  END SUBROUTINE SIGNATURE_B

  FUNCTION SIGNATURE(po, qo, qs, mask_event, stype) RESULT (RES)
    IMPLICIT NONE
    REAL(sp), DIMENSION(:), INTENT(IN) :: po, qo, qs
    INTEGER, DIMENSION(:), INTENT(IN) :: mask_event
    CHARACTER(len=*), INTENT(IN) :: stype
    REAL(sp) :: res
    INTRINSIC SIZE
    LOGICAL, DIMENSION(SIZE(mask_event)) :: lgc_mask_event
    INTEGER :: n_event, i, j, start_event, ntime_step_event
    REAL(sp) :: sum_qo, sum_qs, sum_po, max_qo, max_qs, max_po, num, den
    INTEGER :: imax_qo, imax_qs, imax_po
    INTRINSIC COUNT
    INTRINSIC ABS
    REAL(sp) :: abs0
    res = 0._sp
    n_event = 0
    IF (stype(:1) .EQ. 'E') THEN
! Reverse loop on mask_event to find number of event (array sorted filled with 0)
      DO i=SIZE(mask_event),1,-1
        IF (mask_event(i) .GT. 0) THEN
          n_event = mask_event(i)
          GOTO 110
        END IF
      END DO
 110  DO i=1,n_event
        lgc_mask_event = mask_event .EQ. i
        DO j=1,SIZE(mask_event)
          IF (lgc_mask_event(j)) THEN
            start_event = j
            GOTO 100
          END IF
        END DO
 100    ntime_step_event = COUNT(lgc_mask_event)
        sum_qo = 0._sp
        sum_qs = 0._sp
        sum_po = 0._sp
        max_qo = 0._sp
        max_qs = 0._sp
        max_po = 0._sp
        imax_qo = 0
        imax_qs = 0
        imax_po = 0
        DO j=start_event,start_event+ntime_step_event-1
          IF (qo(j) .GE. 0._sp .AND. po(j) .GE. 0._sp) THEN
            sum_qo = sum_qo + qo(j)
            sum_qs = sum_qs + qs(j)
            sum_po = sum_po + po(j)
            IF (qo(j) .GT. max_qo) THEN
              max_qo = qo(j)
              imax_qo = j
            END IF
            IF (qs(j) .GT. max_qs) THEN
              max_qs = qs(j)
              imax_qs = j
            END IF
            IF (po(j) .GT. max_po) THEN
              max_po = po(j)
              imax_po = j
            END IF
          END IF
        END DO
        SELECT CASE  (stype) 
        CASE ('Epf') 
          num = max_qs
          den = max_qo
        CASE ('Elt') 
          num = imax_qs - imax_po
          den = imax_qo - imax_po
        CASE ('Erc') 
          IF (sum_po .GT. 0._sp) THEN
            num = sum_qs/sum_po
            den = sum_qo/sum_po
          END IF
        END SELECT
        IF (den .GT. 0._sp) THEN
          IF (num/den - 1._sp .GE. 0.) THEN
            abs0 = num/den - 1._sp
          ELSE
            abs0 = -(num/den-1._sp)
          END IF
          res = res + abs0
        END IF
      END DO
      IF (n_event .GT. 0) res = res/n_event
    ELSE
      SELECT CASE  (stype) 
      CASE ('Crc') 
        sum_qo = 0._sp
        sum_qs = 0._sp
        sum_po = 0._sp
        DO i=1,SIZE(qo)
          IF (qo(i) .GE. 0._sp .AND. po(i) .GE. 0._sp) THEN
            sum_qo = sum_qo + qo(i)
            sum_qs = sum_qs + qs(i)
            sum_po = sum_po + po(i)
          END IF
        END DO
        IF (sum_po .GT. 0._sp) THEN
          num = sum_qs/sum_po
          den = sum_qo/sum_po
        END IF
      CASE ('Cfp2') 
        CALL FLOW_PERCENTILE(qo, qs, 0.02_sp, num, den)
      CASE ('Cfp10') 
        CALL FLOW_PERCENTILE(qo, qs, 0.1_sp, num, den)
      CASE ('Cfp50') 
        CALL FLOW_PERCENTILE(qo, qs, 0.5_sp, num, den)
      CASE ('Cfp90') 
        CALL FLOW_PERCENTILE(qo, qs, 0.9_sp, num, den)
      END SELECT
      IF (den .GT. 0._sp) THEN
        IF (num/den - 1._sp .GE. 0.) THEN
          res = num/den - 1._sp
        ELSE
          res = -(num/den-1._sp)
        END IF
      END IF
    END IF
  END FUNCTION SIGNATURE

!  Differentiation of distance_correlation_descriptors in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: penalty_total
!   with respect to varying inputs: parameters_matrix
!%TODO: Add "distance_correlation" once clearly verified
  FUNCTION DISTANCE_CORRELATION_DESCRIPTORS_D(setup, mesh, input_data, &
&   target_control, nbz, parameters_matrix, parameters_matrix_d, &
&   penalty_total) RESULT (PENALTY_TOTAL_D)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    CHARACTER(len=6), INTENT(IN) :: target_control
    INTEGER, INTENT(IN) :: nbz
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, nbz), INTENT(IN) :: &
&   parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, nbz), INTENT(IN) :: &
&   parameters_matrix_d
    REAL(sp) :: penalty_total
    REAL(sp) :: penalty_total_d
    REAL :: penalty, penalty_class, distance
    REAL :: penalty_d, penalty_class_d
    INTEGER :: i, j, ii, jj, p, label, minmask, maxmask, indice, &
&   nbpixbyclass
    INTEGER :: jj_start, ii_start
    INTEGER, DIMENSION(setup%nd) :: descriptor_indexes
    INTEGER :: desc
    INTEGER, DIMENSION(nbz) :: optim
    INTRINSIC MAXVAL
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC REAL
    REAL(sp) :: result1
    REAL :: arg1
    REAL :: temp
    IF (target_control .EQ. 'params') optim = setup%optimize%&
&       optim_parameters
    IF (target_control .EQ. 'states') optim = setup%optimize%&
&       optim_states
    penalty_total_d = 0.0_4
! loop on all parameters
    DO p=1,nbz
      IF (optim(p) .GT. 0) THEN
!#TODO seklect approriate descriptor for parameter
        IF (target_control .EQ. 'params') descriptor_indexes = setup%&
&           optimize%reg_descriptors_for_params(p, :)
        IF (target_control .EQ. 'states') THEN
          descriptor_indexes = setup%optimize%reg_descriptors_for_states&
&           (p, :)
          penalty_d = 0.0
        ELSE
          penalty_d = 0.0
        END IF
        DO desc=1,setup%nd
          IF (descriptor_indexes(desc) .GT. 0) THEN
            minmask = 0
            result1 = MAXVAL(input_data%descriptor(:, :, desc))
            maxmask = INT(result1)
!Boucle sur les différents indices du masque
            DO indice=minmask,maxmask
              label = indice
              nbpixbyclass = 0
              penalty_class_d = 0.0
              DO i=1,mesh%nrow
                DO j=1,mesh%ncol
                  IF (INT(input_data%descriptor(i, j, p)) .EQ. label) &
&                 THEN
                    nbpixbyclass = nbpixbyclass + 1
                    jj_start = j + 1
                    ii_start = i
                    IF (j .EQ. mesh%ncol .AND. i .LT. mesh%nrow) THEN
                      jj_start = 1
                      ii_start = i + 1
                    END IF
                    IF (i .EQ. mesh%nrow .AND. j .EQ. mesh%ncol) THEN
                      jj_start = j
                      ii_start = i
                    END IF
                    DO ii=ii_start,mesh%nrow
                      DO jj=jj_start,mesh%ncol
                        IF (INT(input_data%descriptor(ii, jj, desc)) &
&                           .EQ. label) THEN
                          arg1 = (ii-i)**2. + (jj-j)**2.
                          distance = SQRT(arg1)
                          IF (distance .LT. 1.) distance = 1.
                          temp = distance**2.
                          penalty_class_d = penalty_class_d + 2.*(&
&                           parameters_matrix(i, j, p)-parameters_matrix&
&                           (ii, jj, p))*(parameters_matrix_d(i, j, p)-&
&                           parameters_matrix_d(ii, jj, p))/temp
                        END IF
                      END DO
                      jj_start = 1
                    END DO
                  END IF
                END DO
              END DO
              IF (nbpixbyclass .GE. 1) THEN
                temp = REAL(nbpixbyclass)
                penalty_d = penalty_d + penalty_class_d/temp
              ELSE
                penalty_d = penalty_d + penalty_class_d
              END IF
            END DO
          END IF
        END DO
        penalty_total_d = penalty_total_d + penalty_d
      END IF
    END DO
  END FUNCTION DISTANCE_CORRELATION_DESCRIPTORS_D

!  Differentiation of distance_correlation_descriptors in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: parameters_matrix penalty_total
!   with respect to varying inputs: parameters_matrix
!%TODO: Add "distance_correlation" once clearly verified
  SUBROUTINE DISTANCE_CORRELATION_DESCRIPTORS_B(setup, mesh, input_data&
&   , target_control, nbz, parameters_matrix, parameters_matrix_b, &
&   penalty_total_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    CHARACTER(len=6), INTENT(IN) :: target_control
    INTEGER, INTENT(IN) :: nbz
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, nbz), INTENT(IN) :: &
&   parameters_matrix
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, nbz) :: &
&   parameters_matrix_b
    REAL(sp) :: penalty_total
    REAL(sp) :: penalty_total_b
    REAL :: penalty, penalty_class, distance
    REAL :: penalty_b, penalty_class_b
    INTEGER :: i, j, ii, jj, p, label, minmask, maxmask, indice, &
&   nbpixbyclass
    INTEGER :: jj_start, ii_start
    INTEGER, DIMENSION(setup%nd) :: descriptor_indexes
    INTEGER :: desc
    INTEGER, DIMENSION(nbz) :: optim
    INTRINSIC MAXVAL
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC REAL
    REAL(sp) :: result1
    REAL :: arg1
    REAL(sp) :: temp_b
    INTEGER :: ad_from
    INTEGER :: branch
    INTEGER :: ad_from0
    INTEGER :: ad_from1
    INTEGER :: ad_to
    IF (target_control .EQ. 'params') optim = setup%optimize%&
&       optim_parameters
    IF (target_control .EQ. 'states') optim = setup%optimize%&
&       optim_states
! loop on all parameters
    DO p=1,nbz
      IF (optim(p) .GT. 0) THEN
!#TODO seklect approriate descriptor for parameter
        IF (target_control .EQ. 'params') descriptor_indexes = setup%&
&           optimize%reg_descriptors_for_params(p, :)
        IF (target_control .EQ. 'states') descriptor_indexes = setup%&
&           optimize%reg_descriptors_for_states(p, :)
        DO desc=1,setup%nd
          IF (descriptor_indexes(desc) .GT. 0) THEN
            minmask = 0
            result1 = MAXVAL(input_data%descriptor(:, :, desc))
            maxmask = INT(result1)
            ad_from1 = minmask
!Boucle sur les différents indices du masque
            DO indice=ad_from1,maxmask
              label = indice
              CALL PUSHINTEGER4(nbpixbyclass)
              nbpixbyclass = 0
              DO i=1,mesh%nrow
                DO j=1,mesh%ncol
                  IF (INT(input_data%descriptor(i, j, p)) .EQ. label) &
&                 THEN
                    nbpixbyclass = nbpixbyclass + 1
                    jj_start = j + 1
                    ii_start = i
                    IF (j .EQ. mesh%ncol .AND. i .LT. mesh%nrow) THEN
                      jj_start = 1
                      ii_start = i + 1
                    END IF
                    IF (i .EQ. mesh%nrow .AND. j .EQ. mesh%ncol) THEN
                      jj_start = j
                      ii_start = i
                    END IF
                    ad_from0 = ii_start
                    DO ii=ad_from0,mesh%nrow
                      ad_from = jj_start
                      DO jj=ad_from,mesh%ncol
                        IF (INT(input_data%descriptor(ii, jj, desc)) &
&                           .EQ. label) THEN
                          arg1 = (ii-i)**2. + (jj-j)**2.
                          CALL PUSHREAL4(distance)
                          distance = SQRT(arg1)
                          IF (distance .LT. 1.) distance = 1.
                          CALL PUSHCONTROL1B(1)
                        ELSE
                          CALL PUSHCONTROL1B(0)
                        END IF
                      END DO
                      CALL PUSHINTEGER4(ad_from)
                      jj_start = 1
                    END DO
                    CALL PUSHINTEGER4(ad_from0)
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    CALL PUSHCONTROL1B(0)
                  END IF
                END DO
              END DO
              IF (nbpixbyclass .GE. 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
            CALL PUSHINTEGER4(indice - 1)
            CALL PUSHINTEGER4(ad_from1)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO p=nbz,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        penalty_b = penalty_total_b
        DO desc=setup%nd,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPINTEGER4(ad_from1)
            CALL POPINTEGER4(ad_to)
            DO indice=ad_to,ad_from1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                penalty_class_b = penalty_b
              ELSE
                penalty_class_b = penalty_b/REAL(nbpixbyclass)
              END IF
              DO i=mesh%nrow,1,-1
                DO j=mesh%ncol,1,-1
                  CALL POPCONTROL1B(branch)
                  IF (branch .NE. 0) THEN
                    CALL POPINTEGER4(ad_from0)
                    DO ii=mesh%nrow,ad_from0,-1
                      CALL POPINTEGER4(ad_from)
                      DO jj=mesh%ncol,ad_from,-1
                        CALL POPCONTROL1B(branch)
                        IF (branch .NE. 0) THEN
                          temp_b = 2.*(parameters_matrix(i, j, p)-&
&                           parameters_matrix(ii, jj, p))*&
&                           penalty_class_b/distance**2.
                          parameters_matrix_b(i, j, p) = &
&                           parameters_matrix_b(i, j, p) + temp_b
                          parameters_matrix_b(ii, jj, p) = &
&                           parameters_matrix_b(ii, jj, p) - temp_b
                          CALL POPREAL4(distance)
                        END IF
                      END DO
                    END DO
                  END IF
                END DO
              END DO
              CALL POPINTEGER4(nbpixbyclass)
            END DO
          END IF
        END DO
      END IF
    END DO
  END SUBROUTINE DISTANCE_CORRELATION_DESCRIPTORS_B

!%TODO: Add "distance_correlation" once clearly verified
  FUNCTION DISTANCE_CORRELATION_DESCRIPTORS(setup, mesh, input_data, &
&   target_control, nbz, parameters_matrix) RESULT (PENALTY_TOTAL)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    CHARACTER(len=6), INTENT(IN) :: target_control
    INTEGER, INTENT(IN) :: nbz
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol, nbz), INTENT(IN) :: &
&   parameters_matrix
    REAL(sp) :: penalty_total
    REAL :: penalty, penalty_class, distance
    INTEGER :: i, j, ii, jj, p, label, minmask, maxmask, indice, &
&   nbpixbyclass
    INTEGER :: jj_start, ii_start
    INTEGER, DIMENSION(setup%nd) :: descriptor_indexes
    INTEGER :: desc
    INTEGER, DIMENSION(nbz) :: optim
    INTRINSIC MAXVAL
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC REAL
    REAL(sp) :: result1
    REAL :: arg1
    IF (target_control .EQ. 'params') optim = setup%optimize%&
&       optim_parameters
    IF (target_control .EQ. 'states') optim = setup%optimize%&
&       optim_states
! penality term
    penalty_total = 0.0
! loop on all parameters
    DO p=1,nbz
      IF (optim(p) .GT. 0) THEN
        penalty = 0.0
!#TODO seklect approriate descriptor for parameter
        IF (target_control .EQ. 'params') descriptor_indexes = setup%&
&           optimize%reg_descriptors_for_params(p, :)
        IF (target_control .EQ. 'states') descriptor_indexes = setup%&
&           optimize%reg_descriptors_for_states(p, :)
        DO desc=1,setup%nd
          IF (descriptor_indexes(desc) .GT. 0) THEN
            minmask = 0
            result1 = MAXVAL(input_data%descriptor(:, :, desc))
            maxmask = INT(result1)
!Boucle sur les différents indices du masque
            DO indice=minmask,maxmask
              label = indice
              nbpixbyclass = 0
              penalty_class = 0.
              DO i=1,mesh%nrow
                DO j=1,mesh%ncol
                  IF (INT(input_data%descriptor(i, j, p)) .EQ. label) &
&                 THEN
                    nbpixbyclass = nbpixbyclass + 1
                    jj_start = j + 1
                    ii_start = i
                    IF (j .EQ. mesh%ncol .AND. i .LT. mesh%nrow) THEN
                      jj_start = 1
                      ii_start = i + 1
                    END IF
                    IF (i .EQ. mesh%nrow .AND. j .EQ. mesh%ncol) THEN
                      jj_start = j
                      ii_start = i
                    END IF
                    DO ii=ii_start,mesh%nrow
                      DO jj=jj_start,mesh%ncol
                        IF (INT(input_data%descriptor(ii, jj, desc)) &
&                           .EQ. label) THEN
                          arg1 = (ii-i)**2. + (jj-j)**2.
                          distance = SQRT(arg1)
                          IF (distance .LT. 1.) distance = 1.
                          penalty_class = penalty_class + 1./distance**&
&                           2.*(parameters_matrix(i, j, p)-&
&                           parameters_matrix(ii, jj, p))**2.
                        END IF
                      END DO
                      jj_start = 1
                    END DO
                  END IF
                END DO
              END DO
              IF (nbpixbyclass .GE. 1) THEN
                penalty = penalty + penalty_class/REAL(nbpixbyclass)
              ELSE
                penalty = penalty + penalty_class
              END IF
            END DO
          END IF
        END DO
        penalty_total = penalty_total + penalty
      END IF
    END DO
  END FUNCTION DISTANCE_CORRELATION_DESCRIPTORS

!  Differentiation of reg_smoothing in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: matrix
  FUNCTION REG_SMOOTHING_D(setup, mesh, optim_arr, matrix, matrix_d, &
&   matrix_bgd, rel_to_bgd, res) RESULT (RES_D)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, DIMENSION(:), INTENT(IN) :: optim_arr
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix, matrix_bgd
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix_d
    LOGICAL, INTENT(IN) :: rel_to_bgd
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(matrix, 1), SIZE(matrix, 2), SIZE(matrix, 3&
&   )) :: mat
    REAL(sp), DIMENSION(SIZE(matrix, 1), SIZE(matrix, 2), SIZE(matrix, 3&
&   )) :: mat_d
    INTEGER :: i, col, row, min_col, max_col, min_row, max_row
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: x1
    INTEGER :: x2
! matrix relative to the bgd. We don't want to penalize initial spatial variation.
    IF (rel_to_bgd) THEN
      mat_d = matrix_d
      mat = matrix - matrix_bgd
      res_d = 0.0_4
    ELSE
      mat_d = matrix_d
      mat = matrix
      res_d = 0.0_4
    END IF
    DO i=1,SIZE(matrix, 3)
      IF (optim_arr(i) .GT. 0) THEN
        DO col=1,SIZE(matrix, 2)
          DO row=1,SIZE(matrix, 1)
            IF (mesh%active_cell(row, col) .EQ. 1) THEN
              IF (1 .LT. col - 1) THEN
                min_col = col - 1
              ELSE
                min_col = 1
              END IF
              x1 = SIZE(matrix, 2)
              IF (x1 .GT. col + 1) THEN
                max_col = col + 1
              ELSE
                max_col = x1
              END IF
              IF (1 .LT. row - 1) THEN
                min_row = row - 1
              ELSE
                min_row = 1
              END IF
              x2 = SIZE(matrix, 1)
              IF (x2 .GT. row + 1) THEN
                max_row = row + 1
              ELSE
                max_row = x2
              END IF
! if active_cell, do not take into account the cells outside the catchment
! since only cells in active_cell are included in the control vector
              IF (mesh%active_cell(row, min_col) .EQ. 0) min_col = col
              IF (mesh%active_cell(row, max_col) .EQ. 0) max_col = col
              IF (mesh%active_cell(min_row, col) .EQ. 0) min_row = row
              IF (mesh%active_cell(max_row, col) .EQ. 0) max_row = row
              res_d = res_d + 2._sp*(mat(max_row, col, i)-2._sp*mat(row&
&               , col, i)+mat(min_row, col, i))*(mat_d(max_row, col, i)-&
&               2._sp*mat_d(row, col, i)+mat_d(min_row, col, i)) + 2._sp&
&               *(mat(row, max_col, i)-2._sp*mat(row, col, i)+mat(row, &
&               min_col, i))*(mat_d(row, max_col, i)-2._sp*mat_d(row, &
&               col, i)+mat_d(row, min_col, i))
            END IF
          END DO
        END DO
      END IF
    END DO
  END FUNCTION REG_SMOOTHING_D

!  Differentiation of reg_smoothing in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res matrix
!   with respect to varying inputs: matrix
  SUBROUTINE REG_SMOOTHING_B(setup, mesh, optim_arr, matrix, matrix_b, &
&   matrix_bgd, rel_to_bgd, res_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, DIMENSION(:), INTENT(IN) :: optim_arr
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix, matrix_bgd
    REAL(sp), DIMENSION(:, :, :) :: matrix_b
    LOGICAL, INTENT(IN) :: rel_to_bgd
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(matrix, 1), SIZE(matrix, 2), SIZE(matrix, 3&
&   )) :: mat
    REAL(sp), DIMENSION(SIZE(matrix, 1), SIZE(matrix, 2), SIZE(matrix, 3&
&   )) :: mat_b
    INTEGER :: i, col, row, min_col, max_col, min_row, max_row
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: x1
    INTEGER :: x2
    REAL(sp) :: temp_b
    REAL(sp) :: temp_b0
    INTEGER :: branch
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
! matrix relative to the bgd. We don't want to penalize initial spatial variation.
    IF (rel_to_bgd) THEN
      mat = matrix - matrix_bgd
      CALL PUSHCONTROL1B(1)
    ELSE
      mat = matrix
      CALL PUSHCONTROL1B(0)
    END IF
    DO i=1,SIZE(matrix, 3)
      IF (optim_arr(i) .GT. 0) THEN
        DO col=1,SIZE(matrix, 2)
          DO row=1,SIZE(matrix, 1)
            IF (mesh%active_cell(row, col) .EQ. 1) THEN
              IF (1 .LT. col - 1) THEN
                CALL PUSHINTEGER4(min_col)
                min_col = col - 1
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHINTEGER4(min_col)
                min_col = 1
                CALL PUSHCONTROL1B(1)
              END IF
              x1 = SIZE(matrix, 2)
              IF (x1 .GT. col + 1) THEN
                CALL PUSHINTEGER4(max_col)
                max_col = col + 1
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHINTEGER4(max_col)
                max_col = x1
                CALL PUSHCONTROL1B(1)
              END IF
              IF (1 .LT. row - 1) THEN
                CALL PUSHINTEGER4(min_row)
                min_row = row - 1
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHINTEGER4(min_row)
                min_row = 1
                CALL PUSHCONTROL1B(1)
              END IF
              x2 = SIZE(matrix, 1)
              IF (x2 .GT. row + 1) THEN
                CALL PUSHINTEGER4(max_row)
                max_row = row + 1
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHINTEGER4(max_row)
                max_row = x2
                CALL PUSHCONTROL1B(1)
              END IF
! if active_cell, do not take into account the cells outside the catchment
! since only cells in active_cell are included in the control vector
              IF (mesh%active_cell(row, min_col) .EQ. 0) min_col = col
              IF (mesh%active_cell(row, max_col) .EQ. 0) max_col = col
              IF (mesh%active_cell(min_row, col) .EQ. 0) min_row = row
              IF (mesh%active_cell(max_row, col) .EQ. 0) max_row = row
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
          END DO
          CALL PUSHINTEGER4(row - 1)
        END DO
        CALL PUSHINTEGER4(col - 1)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to1 = i - 1
    mat_b = 0.0_4
    DO i=ad_to1,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPINTEGER4(ad_to0)
        DO col=ad_to0,1,-1
          CALL POPINTEGER4(ad_to)
          DO row=ad_to,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              temp_b = 2._sp*(mat(max_row, col, i)-2._sp*mat(row, col, i&
&               )+mat(min_row, col, i))*res_b
              temp_b0 = 2._sp*(mat(row, max_col, i)-2._sp*mat(row, col, &
&               i)+mat(row, min_col, i))*res_b
              mat_b(row, max_col, i) = mat_b(row, max_col, i) + temp_b0
              mat_b(row, col, i) = mat_b(row, col, i) - 2._sp*temp_b0
              mat_b(row, min_col, i) = mat_b(row, min_col, i) + temp_b0
              mat_b(max_row, col, i) = mat_b(max_row, col, i) + temp_b
              mat_b(row, col, i) = mat_b(row, col, i) - 2._sp*temp_b
              mat_b(min_row, col, i) = mat_b(min_row, col, i) + temp_b
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(max_row)
              ELSE
                CALL POPINTEGER4(max_row)
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(min_row)
              ELSE
                CALL POPINTEGER4(min_row)
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(max_col)
              ELSE
                CALL POPINTEGER4(max_col)
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(min_col)
              ELSE
                CALL POPINTEGER4(min_col)
              END IF
            END IF
          END DO
        END DO
      END IF
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      matrix_b = matrix_b + mat_b
    ELSE
      matrix_b = matrix_b + mat_b
    END IF
  END SUBROUTINE REG_SMOOTHING_B

  FUNCTION REG_SMOOTHING(setup, mesh, optim_arr, matrix, matrix_bgd, &
&   rel_to_bgd) RESULT (RES)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    INTEGER, DIMENSION(:), INTENT(IN) :: optim_arr
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix, matrix_bgd
    LOGICAL, INTENT(IN) :: rel_to_bgd
    REAL(sp) :: res
    INTRINSIC SIZE
    REAL(sp), DIMENSION(SIZE(matrix, 1), SIZE(matrix, 2), SIZE(matrix, 3&
&   )) :: mat
    INTEGER :: i, col, row, min_col, max_col, min_row, max_row
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: x1
    INTEGER :: x2
    res = 0._sp
! matrix relative to the bgd. We don't want to penalize initial spatial variation.
    IF (rel_to_bgd) THEN
      mat = matrix - matrix_bgd
    ELSE
      mat = matrix
    END IF
    DO i=1,SIZE(matrix, 3)
      IF (optim_arr(i) .GT. 0) THEN
        DO col=1,SIZE(matrix, 2)
          DO row=1,SIZE(matrix, 1)
            IF (mesh%active_cell(row, col) .EQ. 1) THEN
              IF (1 .LT. col - 1) THEN
                min_col = col - 1
              ELSE
                min_col = 1
              END IF
              x1 = SIZE(matrix, 2)
              IF (x1 .GT. col + 1) THEN
                max_col = col + 1
              ELSE
                max_col = x1
              END IF
              IF (1 .LT. row - 1) THEN
                min_row = row - 1
              ELSE
                min_row = 1
              END IF
              x2 = SIZE(matrix, 1)
              IF (x2 .GT. row + 1) THEN
                max_row = row + 1
              ELSE
                max_row = x2
              END IF
! if active_cell, do not take into account the cells outside the catchment
! since only cells in active_cell are included in the control vector
              IF (mesh%active_cell(row, min_col) .EQ. 0) min_col = col
              IF (mesh%active_cell(row, max_col) .EQ. 0) max_col = col
              IF (mesh%active_cell(min_row, col) .EQ. 0) min_row = row
              IF (mesh%active_cell(max_row, col) .EQ. 0) max_row = row
              res = res + ((mat(max_row, col, i)-2._sp*mat(row, col, i)+&
&               mat(min_row, col, i))**2._sp+(mat(row, max_col, i)-2._sp&
&               *mat(row, col, i)+mat(row, min_col, i))**2._sp)
            END IF
          END DO
        END DO
      END IF
    END DO
  END FUNCTION REG_SMOOTHING

!  Differentiation of reg_prior in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: res
!   with respect to varying inputs: matrix
  FUNCTION REG_PRIOR_D(setup, optim_arr, matrix, matrix_d, matrix_bgd, &
&   res) RESULT (RES_D)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    INTEGER, DIMENSION(:), INTENT(IN) :: optim_arr
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix, matrix_bgd
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix_d
    REAL(sp) :: res
    REAL(sp) :: res_d
    INTEGER :: i, col, row
    INTRINSIC SIZE
    res_d = 0.0_4
    DO i=1,SIZE(matrix, 3)
      IF (optim_arr(i) .GT. 0) THEN
        DO col=1,SIZE(matrix, 2)
          DO row=1,SIZE(matrix, 1)
            res_d = res_d + 2._sp*(matrix(row, col, i)-matrix_bgd(row, &
&             col, i))*matrix_d(row, col, i)
          END DO
        END DO
      END IF
    END DO
  END FUNCTION REG_PRIOR_D

!  Differentiation of reg_prior in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: res matrix
!   with respect to varying inputs: matrix
  SUBROUTINE REG_PRIOR_B(setup, optim_arr, matrix, matrix_b, matrix_bgd&
&   , res_b)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    INTEGER, DIMENSION(:), INTENT(IN) :: optim_arr
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix, matrix_bgd
    REAL(sp), DIMENSION(:, :, :) :: matrix_b
    REAL(sp) :: res
    REAL(sp) :: res_b
    INTEGER :: i, col, row
    INTRINSIC SIZE
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    INTEGER :: branch
    DO i=1,SIZE(matrix, 3)
      IF (optim_arr(i) .GT. 0) THEN
        DO col=1,SIZE(matrix, 2)
          DO row=1,SIZE(matrix, 1)

          END DO
          CALL PUSHINTEGER4(row - 1)
        END DO
        CALL PUSHINTEGER4(col - 1)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    ad_to1 = i - 1
    DO i=ad_to1,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPINTEGER4(ad_to0)
        DO col=ad_to0,1,-1
          CALL POPINTEGER4(ad_to)
          DO row=ad_to,1,-1
            matrix_b(row, col, i) = matrix_b(row, col, i) + 2._sp*(&
&             matrix(row, col, i)-matrix_bgd(row, col, i))*res_b
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE REG_PRIOR_B

  FUNCTION REG_PRIOR(setup, optim_arr, matrix, matrix_bgd) RESULT (RES)
    IMPLICIT NONE
    TYPE(SETUPDT), INTENT(IN) :: setup
    INTEGER, DIMENSION(:), INTENT(IN) :: optim_arr
    REAL(sp), DIMENSION(:, :, :), INTENT(IN) :: matrix, matrix_bgd
    REAL(sp) :: res
    INTEGER :: i, col, row
    INTRINSIC SIZE
    res = 0._sp
    DO i=1,SIZE(matrix, 3)
      IF (optim_arr(i) .GT. 0) THEN
        DO col=1,SIZE(matrix, 2)
          DO row=1,SIZE(matrix, 1)
            res = res + (matrix(row, col, i)-matrix_bgd(row, col, i))**&
&             2._sp
          END DO
        END DO
      END IF
    END DO
  END FUNCTION REG_PRIOR

END MODULE MWD_COST_DIFF

!%      This module `md_gr_operator` encapsulates all SMASH GR operators.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] gr_interception
!%      [2] gr_production
!%      [3] gr_exchange
!%      [4] gr_transfer
MODULE MD_GR_OPERATOR_DIFF
!% only : sp
  USE MD_CONSTANT
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_interception in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: hi ei pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_D(prcp, pet, ci, ci_d, hi, hi_d, pn, pn_d, &
&   ei, ei_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(IN) :: ci_d
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_d
    REAL(sp), INTENT(OUT) :: pn, ei
    REAL(sp), INTENT(OUT) :: pn_d, ei_d
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp
    IF (pet .GT. prcp + hi*ci) THEN
      ei_d = ci*hi_d + hi*ci_d
      ei = prcp + hi*ci
    ELSE
      ei = pet
      ei_d = 0.0_4
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn_d = ci*hi_d - (1._sp-hi)*ci_d - ei_d
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
      pn_d = 0.0_4
    END IF
    temp = (prcp-ei-pn)/ci
    hi_d = hi_d + (-ei_d-pn_d-temp*ci_d)/ci
    hi = hi + temp
  END SUBROUTINE GR_INTERCEPTION_D

!  Differentiation of gr_interception in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: hi ei ci pn
!   with respect to varying inputs: hi ci
!% TODO comment
  SUBROUTINE GR_INTERCEPTION_B(prcp, pet, ci, ci_b, hi, hi_b, pn, pn_b, &
&   ei, ei_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp) :: ci_b
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(INOUT) :: hi_b
    REAL(sp) :: pn, ei
    REAL(sp) :: pn_b, ei_b
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(sp) :: temp_b
    INTEGER :: branch
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      CALL PUSHREAL4(pn)
      pn = prcp - ci*(1._sp-hi) - ei
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL4(pn)
      pn = 0._sp
      CALL PUSHCONTROL1B(1)
    END IF
    temp_b = hi_b/ci
    ei_b = ei_b - temp_b
    pn_b = pn_b - temp_b
    ci_b = ci_b - (prcp-ei-pn)*temp_b/ci
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(pn)
      ci_b = ci_b - (1._sp-hi)*pn_b
      hi_b = hi_b + ci*pn_b
      ei_b = ei_b - pn_b
    ELSE
      CALL POPREAL4(pn)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      hi_b = hi_b + ci*ei_b
      ci_b = ci_b + hi*ei_b
    END IF
  END SUBROUTINE GR_INTERCEPTION_B

!% TODO comment
  SUBROUTINE GR_INTERCEPTION(prcp, pet, ci, hi, pn, ei)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, pet, ci
    REAL(sp), INTENT(INOUT) :: hi
    REAL(sp), INTENT(OUT) :: pn, ei
    INTRINSIC MIN
    INTRINSIC MAX
    IF (pet .GT. prcp + hi*ci) THEN
      ei = prcp + hi*ci
    ELSE
      ei = pet
    END IF
    IF (0._sp .LT. prcp - ci*(1._sp-hi) - ei) THEN
      pn = prcp - ci*(1._sp-hi) - ei
    ELSE
      pn = 0._sp
    END IF
    hi = hi + (prcp-ei-pn)/ci
  END SUBROUTINE GR_INTERCEPTION

!  Differentiation of gr_production in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: hp perc pr
!   with respect to varying inputs: hp en cp pn
  SUBROUTINE GR_PRODUCTION_D(pn, pn_d, en, en_d, cp, cp_d, beta, hp, &
&   hp_d, pr, pr_d, perc, perc_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(IN) :: pn_d, en_d, cp_d
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_d
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp), INTENT(OUT) :: pr_d, perc_d
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_d, ps_d, es_d, hp_imd_d
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    inv_cp_d = -(cp_d/cp**2)
    inv_cp = 1._sp/cp
    pr = 0._sp
    temp = TANH(pn*inv_cp)
    temp0 = TANH(pn*inv_cp)
    temp1 = cp*(-(hp*hp)+1._sp)
    temp2 = temp1*temp0/(hp*temp+1._sp)
    ps_d = (temp0*((1._sp-hp**2)*cp_d-cp*2*hp*hp_d)+temp1*(1.0-TANH(pn*&
&     inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)-temp2*(temp*hp_d+hp*(1.0-&
&     TANH(pn*inv_cp)**2)*(inv_cp*pn_d+pn*inv_cp_d)))/(hp*temp+1._sp)
    ps = temp2
    temp2 = TANH(en*inv_cp)
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp = temp0*temp1/((-hp+1._sp)*temp2+1._sp)
    es_d = (temp1*((2._sp-hp)*(cp*hp_d+hp*cp_d)-hp*cp*hp_d)+temp0*(1.0-&
&     TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp*((1._sp-hp)*(&
&     1.0-TANH(en*inv_cp)**2)*(inv_cp*en_d+en*inv_cp_d)-temp2*hp_d))/((&
&     1._sp-hp)*temp2+1._sp)
    es = temp
    hp_imd_d = hp_d + inv_cp*(ps_d-es_d) + (ps-es)*inv_cp_d
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      pr_d = pn_d - cp*(hp_imd_d-hp_d) - (hp_imd-hp)*cp_d
      pr = pn - (hp_imd-hp)*cp
    ELSE
      pr_d = 0.0_4
    END IF
    pwx1_d = 4*hp_imd**3*hp_imd_d/beta**4
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1_d = -(0.25_sp*pwx1**(-1.25)*pwx1_d)
    pwr1 = pwx1**(-0.25_sp)
    perc_d = (1._sp-pwr1)*(cp*hp_imd_d+hp_imd*cp_d) - hp_imd*cp*pwr1_d
    perc = hp_imd*cp*(1._sp-pwr1)
    hp_d = hp_imd_d - inv_cp*perc_d - perc*inv_cp_d
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION_D

!  Differentiation of gr_production in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: hp cp perc pr
!   with respect to varying inputs: hp en cp pn
  SUBROUTINE GR_PRODUCTION_B(pn, pn_b, en, en_b, cp, cp_b, beta, hp, &
&   hp_b, pr, pr_b, perc, perc_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp) :: pn_b, en_b, cp_b
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(INOUT) :: hp_b
    REAL(sp) :: pr, perc
    REAL(sp) :: pr_b, perc_b
    REAL(sp) :: inv_cp, ps, es, hp_imd
    REAL(sp) :: inv_cp_b, ps_b, es_b, hp_imd_b
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: temp
    REAL(sp) :: temp0
    REAL(sp) :: temp_b
    REAL(sp) :: temp1
    REAL(sp) :: temp2
    REAL(sp) :: temp3
    REAL(sp) :: temp_b0
    REAL(sp) :: temp_b1
    REAL(sp) :: temp4
    REAL(sp) :: temp_b2
    REAL(sp) :: temp_b3
    REAL(sp) :: temp_b4
    REAL(sp) :: temp_b5
    INTEGER :: branch
    inv_cp = 1._sp/cp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    inv_cp = 1._sp/cp
    perc_b = perc_b - inv_cp*hp_b
    inv_cp_b = -(perc*hp_b)
    cp_b = cp_b + hp_imd*(1._sp-pwr1)*perc_b
    pwr1_b = -(hp_imd*cp*perc_b)
    pwx1_b = -(0.25_sp*pwx1**(-1.25)*pwr1_b)
    hp_imd_b = hp_b + cp*(1._sp-pwr1)*perc_b + 4*hp_imd**3*pwx1_b/beta**&
&     4
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pn_b = pr_b
      hp_imd_b = hp_imd_b - cp*pr_b
      hp_b = cp*pr_b
      cp_b = cp_b - (hp_imd-hp)*pr_b
    ELSE
      hp_b = 0.0_4
      pn_b = 0.0_4
    END IF
    es_b = -(inv_cp*hp_imd_b)
    temp4 = TANH(en*inv_cp)
    temp3 = (-hp+1._sp)*temp4 + 1._sp
    temp1 = TANH(en*inv_cp)
    temp0 = hp*cp*(-hp+2._sp)
    temp_b3 = es_b/temp3
    temp_b = (2._sp-hp)*temp1*temp_b3
    temp_b0 = -(temp0*temp1*temp_b3/temp3)
    hp_b = hp_b + hp_imd_b + cp*temp_b - hp*cp*temp1*temp_b3 - temp4*&
&     temp_b0
    ps_b = inv_cp*hp_imd_b
    temp_b4 = (1.0-TANH(en*inv_cp)**2)*temp0*temp_b3
    temp_b5 = (1.0-TANH(en*inv_cp)**2)*(1._sp-hp)*temp_b0
    en_b = inv_cp*temp_b5 + inv_cp*temp_b4
    cp_b = cp_b + hp*temp_b
    temp = TANH(pn*inv_cp)
    temp0 = hp*temp + 1._sp
    temp1 = TANH(pn*inv_cp)
    temp2 = cp*(-(hp*hp)+1._sp)
    temp_b = ps_b/temp0
    temp_b0 = (1.0-TANH(pn*inv_cp)**2)*temp2*temp_b
    temp_b1 = -(temp2*temp1*temp_b/temp0)
    hp_b = hp_b + temp*temp_b1 - 2*hp*cp*temp1*temp_b
    temp_b2 = (1.0-TANH(pn*inv_cp)**2)*hp*temp_b1
    inv_cp_b = inv_cp_b + (ps-es)*hp_imd_b + en*temp_b5 + en*temp_b4 + &
&     pn*temp_b2 + pn*temp_b0
    cp_b = cp_b + (1._sp-hp**2)*temp1*temp_b - inv_cp_b/cp**2
    pn_b = pn_b + inv_cp*temp_b2 + inv_cp*temp_b0
  END SUBROUTINE GR_PRODUCTION_B

  SUBROUTINE GR_PRODUCTION(pn, en, cp, beta, hp, pr, perc)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pn, en, cp, beta
    REAL(sp), INTENT(INOUT) :: hp
    REAL(sp), INTENT(OUT) :: pr, perc
    REAL(sp) :: inv_cp, ps, es, hp_imd
    INTRINSIC TANH
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    inv_cp = 1._sp/cp
    pr = 0._sp
    ps = cp*(1._sp-hp*hp)*TANH(pn*inv_cp)/(1._sp+hp*TANH(pn*inv_cp))
    es = hp*cp*(2._sp-hp)*TANH(en*inv_cp)/(1._sp+(1._sp-hp)*TANH(en*&
&     inv_cp))
    hp_imd = hp + (ps-es)*inv_cp
    IF (pn .GT. 0) pr = pn - (hp_imd-hp)*cp
    pwx1 = 1._sp + (hp_imd/beta)**4
    pwr1 = pwx1**(-0.25_sp)
    perc = hp_imd*cp*(1._sp-pwr1)
    hp = hp_imd - perc*inv_cp
  END SUBROUTINE GR_PRODUCTION

!  Differentiation of gr_exchange in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: l
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_D(exc, exc_d, hft, hft_d, l, l_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(IN) :: exc_d
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_d
    REAL(sp), INTENT(OUT) :: l
    REAL(sp), INTENT(OUT) :: l_d
    REAL(sp) :: temp
    temp = hft**3.5_sp
    l_d = temp*exc_d + exc*3.5_sp*hft**2.5*hft_d
    l = exc*temp
  END SUBROUTINE GR_EXCHANGE_D

!  Differentiation of gr_exchange in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: l hft exc
!   with respect to varying inputs: hft exc
  SUBROUTINE GR_EXCHANGE_B(exc, exc_b, hft, hft_b, l, l_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp) :: exc_b
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(INOUT) :: hft_b
    REAL(sp) :: l
    REAL(sp) :: l_b
    exc_b = exc_b + hft**3.5_sp*l_b
    hft_b = hft_b + 3.5_sp*hft**2.5*exc*l_b
  END SUBROUTINE GR_EXCHANGE_B

  SUBROUTINE GR_EXCHANGE(exc, hft, l)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: exc
    REAL(sp), INTENT(INOUT) :: hft
    REAL(sp), INTENT(OUT) :: l
    l = exc*hft**3.5_sp
  END SUBROUTINE GR_EXCHANGE

!  Differentiation of gr_transfer in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: q ht
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFER_D(n, prcp, pr, pr_d, ct, ct_d, ht, ht_d, q, q_d&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(IN) :: pr_d, ct_d
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_d
    REAL(sp), INTENT(OUT) :: q
    REAL(sp), INTENT(OUT) :: q_d
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_d, ht_imd_d
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1_d = ct*ht_d + ht*ct_d
      pwx1 = ht*ct
      pwy1 = -nm1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      END IF
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        pwr2_d = 0.0_4
      ELSE
        pwr2_d = pwy2*ct**(pwy2-1)*ct_d
      END IF
      pwr2 = ct**pwy2
      pwx3_d = pwr1_d - pwr2_d
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwr3_d = 0.0_4
      ELSE
        pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
      END IF
      pwr3 = pwx3**pwy3
      pr_imd_d = pwr3_d - ct*ht_d - ht*ct_d
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd_d = pr_d
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd_d = ht_d + (pr_imd_d-pr_imd*ct_d/ct)/ct
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
      ht_imd_d = 0.0_4
    END IF
    pwx1_d = ct*ht_imd_d + ht_imd*ct_d
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*ct**(pwy2-1)*ct_d
    END IF
    pwr2 = ct**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    ht_d = (pwr3_d-pwr3*ct_d/ct)/ct
    ht = pwr3/ct
    q_d = ct*(ht_imd_d-ht_d) + (ht_imd-ht)*ct_d
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFER_D

!  Differentiation of gr_transfer in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: q ht ct
!   with respect to varying inputs: ht ct pr
  SUBROUTINE GR_TRANSFER_B(n, prcp, pr, pr_b, ct, ct_b, ht, ht_b, q, q_b&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp) :: pr_b, ct_b
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(INOUT) :: ht_b
    REAL(sp) :: q
    REAL(sp) :: q_b
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    REAL(sp) :: pr_imd_b, ht_imd_b
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_b
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_b
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_b
    INTEGER :: branch
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
      CALL PUSHCONTROL1B(1)
    ELSE
      pr_imd = pr
      CALL PUSHCONTROL1B(0)
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
      CALL PUSHCONTROL1B(0)
    ELSE
      ht_imd = 1.e-6_sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(pwx1)
    pwx1 = ht_imd*ct
    CALL PUSHREAL4(pwy1)
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    CALL PUSHREAL4(pwy2)
    pwy2 = -nm1
    pwr2 = ct**pwy2
    CALL PUSHREAL4(pwx3)
    pwx3 = pwr1 + pwr2
    CALL PUSHREAL4(pwy3)
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    CALL PUSHREAL4(ht)
    ht = pwr3/ct
    pwx1 = ht_imd*ct
    nm1 = n - 1._sp
    pwy1 = -nm1
    pwy2 = -nm1
    d1pnm1 = 1._sp/nm1
    pwy3 = -d1pnm1
    ht_b = ht_b - ct*q_b
    pwr3_b = ht_b/ct
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwx3_b = 0.0_4
    ELSE
      pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
    END IF
    pwr1_b = pwx3_b
    pwr2_b = pwx3_b
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwx1_b = 0.0_4
    ELSE
      pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
    END IF
    ht_imd_b = ct*q_b + ct*pwx1_b
    IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) THEN
      ct_b = ct_b + (ht_imd-ht)*q_b + ht_imd*pwx1_b - pwr3*ht_b/ct**2
    ELSE
      ct_b = ct_b + (ht_imd-ht)*q_b + pwy2*ct**(pwy2-1)*pwr2_b - pwr3*&
&       ht_b/ct**2 + ht_imd*pwx1_b
    END IF
    CALL POPREAL4(ht)
    CALL POPREAL4(pwy3)
    CALL POPREAL4(pwx3)
    CALL POPREAL4(pwy2)
    CALL POPREAL4(pwy1)
    CALL POPREAL4(pwx1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ht_b = ht_imd_b
      pr_imd_b = ht_imd_b/ct
      ct_b = ct_b - pr_imd*ht_imd_b/ct**2
    ELSE
      ht_b = 0.0_4
      pr_imd_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      pr_b = pr_imd_b
    ELSE
      pwr3_b = pr_imd_b
      IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&     THEN
        pwx3_b = 0.0_4
      ELSE
        pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
      END IF
      pwr1_b = pwx3_b
      pwr2_b = -pwx3_b
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwx1_b = 0.0_4
      ELSE
        pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
      END IF
      ht_b = ht_b + ct*pwx1_b - ct*pr_imd_b
      IF (ct .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&     THEN
        ct_b = ct_b + ht*pwx1_b - ht*pr_imd_b
      ELSE
        ct_b = ct_b + pwy2*ct**(pwy2-1)*pwr2_b - ht*pr_imd_b + ht*pwx1_b
      END IF
      pr_b = 0.0_4
    END IF
  END SUBROUTINE GR_TRANSFER_B

  SUBROUTINE GR_TRANSFER(n, prcp, pr, ct, ht, q)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, prcp, pr, ct
    REAL(sp), INTENT(INOUT) :: ht
    REAL(sp), INTENT(OUT) :: q
    REAL(sp) :: pr_imd, ht_imd, nm1, d1pnm1
    INTRINSIC MAX
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    IF (prcp .LT. 0._sp) THEN
      pwx1 = ht*ct
      pwy1 = -nm1
      pwr1 = pwx1**pwy1
      pwy2 = -nm1
      pwr2 = ct**pwy2
      pwx3 = pwr1 - pwr2
      pwy3 = -d1pnm1
      pwr3 = pwx3**pwy3
      pr_imd = pwr3 - ht*ct
    ELSE
      pr_imd = pr
    END IF
    IF (1.e-6_sp .LT. ht + pr_imd/ct) THEN
      ht_imd = ht + pr_imd/ct
    ELSE
      ht_imd = 1.e-6_sp
    END IF
    pwx1 = ht_imd*ct
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = ct**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    ht = pwr3/ct
    q = (ht_imd-ht)*ct
  END SUBROUTINE GR_TRANSFER

END MODULE MD_GR_OPERATOR_DIFF

!%      This module `md_routing_operator` encapsulates all SMASH routing operator.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] upstream_discharge
!%      [2] linear_routing
MODULE MD_ROUTING_OPERATOR_DIFF
!% only : sp
  USE MD_CONSTANT
  IMPLICIT NONE

CONTAINS
!  Differentiation of upstream_discharge in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_D(dt, dx, nrow, ncol, flwdir, flwacc, &
&   row, col, q, q_d, qup, qup_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, flwacc
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q_d
    REAL(sp), INTENT(OUT) :: qup
    REAL(sp), INTENT(OUT) :: qup_d
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    REAL*4 :: temp
    qup = 0._sp
    IF (flwacc(row, col) .GT. 1) THEN
      qup_d = 0.0_4
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            qup_d = qup_d + q_d(row_imd, col_imd)
            qup = qup + q(row_imd, col_imd)
          END IF
        END IF
      END DO
      temp = 0.001_sp*(dx*dx)*REAL(flwacc(row, col)-1)
      qup_d = dt*qup_d/temp
      qup = dt*(qup/temp)
    ELSE
      qup_d = 0.0_4
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_D

!  Differentiation of upstream_discharge in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: q qup
!   with respect to varying inputs: q
  SUBROUTINE UPSTREAM_DISCHARGE_B(dt, dx, nrow, ncol, flwdir, flwacc, &
&   row, col, q, q_b, qup, qup_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, flwacc
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), DIMENSION(nrow, ncol) :: q_b
    REAL(sp) :: qup
    REAL(sp) :: qup_b
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    INTEGER :: branch
    IF (flwacc(row, col) .GT. 1) THEN
      DO i=1,8
        CALL PUSHINTEGER4(col_imd)
        col_imd = col + dcol(i)
        CALL PUSHINTEGER4(row_imd)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      qup_b = dt*qup_b/(0.001_sp*dx**2*REAL(flwacc(row, col)-1))
      DO i=8,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) q_b(row_imd, col_imd) = q_b(row_imd, &
&             col_imd) + qup_b
        END IF
        CALL POPINTEGER4(row_imd)
        CALL POPINTEGER4(col_imd)
      END DO
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE_B

  SUBROUTINE UPSTREAM_DISCHARGE(dt, dx, nrow, ncol, flwdir, flwacc, row&
&   , col, q, qup)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt, dx
    INTEGER, INTENT(IN) :: nrow, ncol, row, col
    INTEGER, DIMENSION(nrow, ncol), INTENT(IN) :: flwdir, flwacc
    REAL(sp), DIMENSION(nrow, ncol), INTENT(IN) :: q
    REAL(sp), INTENT(OUT) :: qup
    INTEGER :: i, row_imd, col_imd
    INTEGER, DIMENSION(8), SAVE :: dcol=(/0, -1, -1, -1, 0, 1, 1, 1/)
    INTEGER, DIMENSION(8), SAVE :: drow=(/1, 1, 0, -1, -1, -1, 0, 1/)
    INTEGER, DIMENSION(8), SAVE :: dkind=(/1, 2, 3, 4, 5, 6, 7, 8/)
    INTRINSIC REAL
    qup = 0._sp
    IF (flwacc(row, col) .GT. 1) THEN
      DO i=1,8
        col_imd = col + dcol(i)
        row_imd = row + drow(i)
        IF (col_imd .GT. 0 .AND. col_imd .LE. ncol .AND. row_imd .GT. 0 &
&           .AND. row_imd .LE. nrow) THEN
          IF (flwdir(row_imd, col_imd) .EQ. dkind(i)) qup = qup + q(&
&             row_imd, col_imd)
        END IF
      END DO
      qup = qup*dt/(0.001_sp*dx*dx*REAL(flwacc(row, col)-1))
    END IF
  END SUBROUTINE UPSTREAM_DISCHARGE

!  Differentiation of linear_routing in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: hr qrout
!   with respect to varying inputs: qup hr lr
  SUBROUTINE LINEAR_ROUTING_D(dt, qup, qup_d, lr, lr_d, hr, hr_d, qrout&
&   , qrout_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(IN) :: qup_d, lr_d
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_d
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp), INTENT(OUT) :: qrout_d
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_d
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_d
    REAL(sp) :: temp
    hr_imd_d = hr_d + qup_d
    hr_imd = hr + qup
    temp = dt/(60._sp*lr)
    arg1_d = temp*lr_d/lr
    arg1 = -temp
    temp = EXP(arg1)
    hr_d = temp*hr_imd_d + hr_imd*EXP(arg1)*arg1_d
    hr = hr_imd*temp
    qrout_d = hr_imd_d - hr_d
    qrout = hr_imd - hr
  END SUBROUTINE LINEAR_ROUTING_D

!  Differentiation of linear_routing in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: hr qrout lr
!   with respect to varying inputs: qup hr lr
  SUBROUTINE LINEAR_ROUTING_B(dt, qup, qup_b, lr, lr_b, hr, hr_b, qrout&
&   , qrout_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp) :: qup_b, lr_b
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(INOUT) :: hr_b
    REAL(sp) :: qrout
    REAL(sp) :: qrout_b
    REAL(sp) :: hr_imd
    REAL(sp) :: hr_imd_b
    INTRINSIC EXP
    REAL(sp) :: arg1
    REAL(sp) :: arg1_b
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    arg1 = -(dt/(lr*60._sp))
    hr_b = hr_b - qrout_b
    hr_imd_b = qrout_b + EXP(arg1)*hr_b
    arg1_b = EXP(arg1)*hr_imd*hr_b
    lr_b = lr_b + dt*arg1_b/(lr**2*60._sp)
    hr_b = hr_imd_b
    qup_b = hr_imd_b
  END SUBROUTINE LINEAR_ROUTING_B

  SUBROUTINE LINEAR_ROUTING(dt, qup, lr, hr, qrout)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: dt
    REAL(sp), INTENT(IN) :: qup, lr
    REAL(sp), INTENT(INOUT) :: hr
    REAL(sp), INTENT(OUT) :: qrout
    REAL(sp) :: hr_imd
    INTRINSIC EXP
    REAL(sp) :: arg1
    hr_imd = hr + qup
    arg1 = -(dt/(lr*60._sp))
    hr = hr_imd*EXP(arg1)
    qrout = hr_imd - hr
  END SUBROUTINE LINEAR_ROUTING

END MODULE MD_ROUTING_OPERATOR_DIFF

!%      This module `md_vic_operator` encapsulates all SMASH VIC operators.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] vic_infiltration
!%      [2] vic_vertical_transfer
!%      [3] vic_interflow
!%      [4] vic_baseflow
!%      [5] brooks_and_corey_flow
!%      [6] linear_evapotranspiration
MODULE MD_VIC_OPERATOR_DIFF
!% only : sp
  USE MD_CONSTANT
  IMPLICIT NONE

CONTAINS
!  Differentiation of vic_infiltration in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: runoff husl1 husl2
!   with respect to varying inputs: cusl1 cusl2 husl1 husl2 b
  SUBROUTINE VIC_INFILTRATION_D(prcp, cusl1, cusl1_d, cusl2, cusl2_d, b&
&   , b_d, husl1, husl1_d, husl2, husl2_d, runoff, runoff_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, cusl1, cusl2, b
    REAL(sp), INTENT(IN) :: cusl1_d, cusl2_d, b_d
    REAL(sp), INTENT(INOUT) :: husl1, husl2
    REAL(sp), INTENT(INOUT) :: husl1_d, husl2_d
    REAL(sp), INTENT(OUT) :: runoff
    REAL(sp), INTENT(OUT) :: runoff_d
    REAL(sp) :: bp1, ifl, cusl, wusl, iflm, iflc, ifl_usl1, ifl_usl2
    REAL(sp) :: bp1_d, ifl_d, cusl_d, wusl_d, iflm_d, iflc_d, ifl_usl1_d&
&   , ifl_usl2_d
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwy1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: temp
    bp1_d = b_d
    bp1 = b + 1._sp
    IF (prcp .LE. 0._sp) THEN
      ifl = 0._sp
      ifl_d = 0.0_4
    ELSE
      cusl_d = cusl1_d + cusl2_d
      cusl = cusl1 + cusl2
      wusl_d = cusl1*husl1_d + husl1*cusl1_d + cusl2*husl2_d + husl2*&
&       cusl2_d
      wusl = husl1*cusl1 + husl2*cusl2
      IF (1.e-6 .LT. wusl) THEN
        wusl = wusl
      ELSE
        wusl = 1.e-6
        wusl_d = 0.0_4
      END IF
      IF (cusl - 1e-6 .GT. wusl) THEN
        wusl = wusl
      ELSE
        wusl_d = cusl_d
        wusl = cusl - 1e-6
      END IF
      iflm_d = bp1*cusl_d + cusl*bp1_d
      iflm = cusl*bp1
      pwx1_d = -((wusl_d-wusl*cusl_d/cusl)/cusl)
      pwx1 = 1._sp - wusl/cusl
      pwy1_d = -(bp1_d/bp1**2)
      pwy1 = 1._sp/bp1
      temp = pwx1**pwy1
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwr1_d = 0.0_4
      ELSE IF (pwx1 .LE. 0.0) THEN
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
      ELSE
        pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d + temp*LOG(pwx1)*pwy1_d
      END IF
      pwr1 = temp
      iflc_d = (1._sp-pwr1)*iflm_d - iflm*pwr1_d
      iflc = iflm*(1._sp-pwr1)
      IF (iflc + prcp .GE. iflm) THEN
        ifl_d = cusl_d - wusl_d
        ifl = cusl - wusl
      ELSE
        temp = (prcp+iflc)/iflm
        pwx1_d = -((iflc_d-temp*iflm_d)/iflm)
        pwx1 = 1._sp - temp
        temp = pwx1**bp1
        IF (pwx1 .LE. 0.0 .AND. (bp1 .EQ. 0.0 .OR. bp1 .NE. INT(bp1))) &
&       THEN
          pwr1_d = 0.0_4
        ELSE IF (pwx1 .LE. 0.0) THEN
          pwr1_d = bp1*pwx1**(bp1-1)*pwx1_d
        ELSE
          pwr1_d = bp1*pwx1**(bp1-1)*pwx1_d + temp*LOG(pwx1)*bp1_d
        END IF
        pwr1 = temp
        ifl_d = (1.0-pwr1)*cusl_d - wusl_d - cusl*pwr1_d
        ifl = cusl - wusl - cusl*pwr1
      END IF
      IF (prcp .GT. ifl) THEN
        ifl = ifl
      ELSE
        ifl = prcp
        ifl_d = 0.0_4
      END IF
    END IF
    IF ((1._sp-husl1)*cusl1 .GT. ifl) THEN
      ifl_usl1_d = ifl_d
      ifl_usl1 = ifl
    ELSE
      ifl_usl1_d = (1._sp-husl1)*cusl1_d - cusl1*husl1_d
      ifl_usl1 = (1._sp-husl1)*cusl1
    END IF
    ifl_d = ifl_d - ifl_usl1_d
    ifl = ifl - ifl_usl1
    IF ((1._sp-husl2)*cusl2 .GT. ifl) THEN
      ifl_usl2_d = ifl_d
      ifl_usl2 = ifl
    ELSE
      ifl_usl2_d = (1._sp-husl2)*cusl2_d - cusl2*husl2_d
      ifl_usl2 = (1._sp-husl2)*cusl2
    END IF
    husl1_d = husl1_d + (ifl_usl1_d-ifl_usl1*cusl1_d/cusl1)/cusl1
    husl1 = husl1 + ifl_usl1/cusl1
    husl2_d = husl2_d + (ifl_usl2_d-ifl_usl2*cusl2_d/cusl2)/cusl2
    husl2 = husl2 + ifl_usl2/cusl2
    runoff_d = -ifl_usl1_d - ifl_usl2_d
    runoff = prcp - (ifl_usl1+ifl_usl2)
  END SUBROUTINE VIC_INFILTRATION_D

!  Differentiation of vic_infiltration in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: runoff cusl1 cusl2 husl1 husl2
!                b
!   with respect to varying inputs: cusl1 cusl2 husl1 husl2 b
  SUBROUTINE VIC_INFILTRATION_B(prcp, cusl1, cusl1_b, cusl2, cusl2_b, b&
&   , b_b, husl1, husl1_b, husl2, husl2_b, runoff, runoff_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, cusl1, cusl2, b
    REAL(sp) :: cusl1_b, cusl2_b, b_b
    REAL(sp), INTENT(INOUT) :: husl1, husl2
    REAL(sp), INTENT(INOUT) :: husl1_b, husl2_b
    REAL(sp) :: runoff
    REAL(sp) :: runoff_b
    REAL(sp) :: bp1, ifl, cusl, wusl, iflm, iflc, ifl_usl1, ifl_usl2
    REAL(sp) :: bp1_b, ifl_b, cusl_b, wusl_b, iflm_b, iflc_b, ifl_usl1_b&
&   , ifl_usl2_b
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwy1
    REAL(sp) :: pwy1_b
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    INTEGER :: branch
    bp1 = b + 1._sp
    IF (prcp .LE. 0._sp) THEN
      ifl = 0._sp
      CALL PUSHCONTROL2B(0)
    ELSE
      cusl = cusl1 + cusl2
      wusl = husl1*cusl1 + husl2*cusl2
      IF (1.e-6 .LT. wusl) THEN
        CALL PUSHCONTROL1B(0)
        wusl = wusl
      ELSE
        wusl = 1.e-6
        CALL PUSHCONTROL1B(1)
      END IF
      IF (cusl - 1e-6 .GT. wusl) THEN
        CALL PUSHCONTROL1B(0)
        wusl = wusl
      ELSE
        wusl = cusl - 1e-6
        CALL PUSHCONTROL1B(1)
      END IF
      iflm = cusl*bp1
      pwx1 = 1._sp - wusl/cusl
      pwy1 = 1._sp/bp1
      pwr1 = pwx1**pwy1
      iflc = iflm*(1._sp-pwr1)
      IF (iflc + prcp .GE. iflm) THEN
        ifl = cusl - wusl
        CALL PUSHCONTROL1B(1)
      ELSE
        pwx1 = 1._sp - (iflc+prcp)/iflm
        CALL PUSHREAL4(pwr1)
        pwr1 = pwx1**bp1
        ifl = cusl - wusl - cusl*pwr1
        CALL PUSHCONTROL1B(0)
      END IF
      IF (prcp .GT. ifl) THEN
        CALL PUSHCONTROL2B(2)
        ifl = ifl
      ELSE
        ifl = prcp
        CALL PUSHCONTROL2B(1)
      END IF
    END IF
    IF ((1._sp-husl1)*cusl1 .GT. ifl) THEN
      ifl_usl1 = ifl
      CALL PUSHCONTROL1B(0)
    ELSE
      ifl_usl1 = (1._sp-husl1)*cusl1
      CALL PUSHCONTROL1B(1)
    END IF
    ifl = ifl - ifl_usl1
    IF ((1._sp-husl2)*cusl2 .GT. ifl) THEN
      ifl_usl2 = ifl
      CALL PUSHCONTROL1B(0)
    ELSE
      ifl_usl2 = (1._sp-husl2)*cusl2
      CALL PUSHCONTROL1B(1)
    END IF
    ifl_usl1_b = husl1_b/cusl1 - runoff_b
    ifl_usl2_b = husl2_b/cusl2 - runoff_b
    cusl2_b = cusl2_b - ifl_usl2*husl2_b/cusl2**2
    cusl1_b = cusl1_b - ifl_usl1*husl1_b/cusl1**2
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ifl_b = ifl_usl2_b
    ELSE
      husl2_b = husl2_b - cusl2*ifl_usl2_b
      cusl2_b = cusl2_b + (1._sp-husl2)*ifl_usl2_b
      ifl_b = 0.0_4
    END IF
    ifl_usl1_b = ifl_usl1_b - ifl_b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ifl_b = ifl_b + ifl_usl1_b
    ELSE
      husl1_b = husl1_b - cusl1*ifl_usl1_b
      cusl1_b = cusl1_b + (1._sp-husl1)*ifl_usl1_b
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      bp1_b = 0.0_4
    ELSE
      IF (branch .EQ. 1) ifl_b = 0.0_4
      cusl = cusl1 + cusl2
      bp1 = b + 1._sp
      iflm = cusl*bp1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        cusl_b = (1.0-pwr1)*ifl_b
        wusl_b = -ifl_b
        pwr1_b = -(cusl*ifl_b)
        CALL POPREAL4(pwr1)
        IF (pwx1 .LE. 0.0 .AND. (bp1 .EQ. 0.0 .OR. bp1 .NE. INT(bp1))) &
&       THEN
          pwx1_b = 0.0_4
        ELSE
          pwx1_b = bp1*pwx1**(bp1-1)*pwr1_b
        END IF
        IF (pwx1 .LE. 0.0) THEN
          bp1_b = 0.0_4
        ELSE
          bp1_b = pwx1**bp1*LOG(pwx1)*pwr1_b
        END IF
        iflc_b = -(pwx1_b/iflm)
        iflm_b = (prcp+iflc)*pwx1_b/iflm**2
        pwy1 = 1._sp/bp1
        pwx1 = 1._sp - wusl/cusl
      ELSE
        cusl_b = ifl_b
        wusl_b = -ifl_b
        iflc_b = 0.0_4
        iflm_b = 0.0_4
        bp1_b = 0.0_4
      END IF
      iflm_b = iflm_b + (1._sp-pwr1)*iflc_b
      pwr1_b = -(iflm*iflc_b)
      IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&     THEN
        pwx1_b = 0.0_4
      ELSE
        pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
      END IF
      IF (pwx1 .LE. 0.0) THEN
        pwy1_b = 0.0_4
      ELSE
        pwy1_b = pwx1**pwy1*LOG(pwx1)*pwr1_b
      END IF
      bp1_b = bp1_b + cusl*iflm_b - pwy1_b/bp1**2
      wusl_b = wusl_b - pwx1_b/cusl
      cusl_b = cusl_b + wusl*pwx1_b/cusl**2 + bp1*iflm_b
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        cusl_b = cusl_b + wusl_b
        wusl_b = 0.0_4
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) wusl_b = 0.0_4
      husl1_b = husl1_b + cusl1*wusl_b
      cusl1_b = cusl1_b + husl1*wusl_b + cusl_b
      husl2_b = husl2_b + cusl2*wusl_b
      cusl2_b = cusl2_b + husl2*wusl_b + cusl_b
    END IF
    b_b = b_b + bp1_b
  END SUBROUTINE VIC_INFILTRATION_B

  SUBROUTINE VIC_INFILTRATION(prcp, cusl1, cusl2, b, husl1, husl2, &
&   runoff)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: prcp, cusl1, cusl2, b
    REAL(sp), INTENT(INOUT) :: husl1, husl2
    REAL(sp), INTENT(OUT) :: runoff
    REAL(sp) :: bp1, ifl, cusl, wusl, iflm, iflc, ifl_usl1, ifl_usl2
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    bp1 = b + 1._sp
    IF (prcp .LE. 0._sp) THEN
      ifl = 0._sp
    ELSE
      cusl = cusl1 + cusl2
      wusl = husl1*cusl1 + husl2*cusl2
      IF (1.e-6 .LT. wusl) THEN
        wusl = wusl
      ELSE
        wusl = 1.e-6
      END IF
      IF (cusl - 1e-6 .GT. wusl) THEN
        wusl = wusl
      ELSE
        wusl = cusl - 1e-6
      END IF
      iflm = cusl*bp1
      pwx1 = 1._sp - wusl/cusl
      pwy1 = 1._sp/bp1
      pwr1 = pwx1**pwy1
      iflc = iflm*(1._sp-pwr1)
      IF (iflc + prcp .GE. iflm) THEN
        ifl = cusl - wusl
      ELSE
        pwx1 = 1._sp - (iflc+prcp)/iflm
        pwr1 = pwx1**bp1
        ifl = cusl - wusl - cusl*pwr1
      END IF
      IF (prcp .GT. ifl) THEN
        ifl = ifl
      ELSE
        ifl = prcp
      END IF
    END IF
    IF ((1._sp-husl1)*cusl1 .GT. ifl) THEN
      ifl_usl1 = ifl
    ELSE
      ifl_usl1 = (1._sp-husl1)*cusl1
    END IF
    ifl = ifl - ifl_usl1
    IF ((1._sp-husl2)*cusl2 .GT. ifl) THEN
      ifl_usl2 = ifl
    ELSE
      ifl_usl2 = (1._sp-husl2)*cusl2
    END IF
    ifl = ifl - ifl_usl2
    husl1 = husl1 + ifl_usl1/cusl1
    husl2 = husl2 + ifl_usl2/cusl2
    runoff = prcp - (ifl_usl1+ifl_usl2)
  END SUBROUTINE VIC_INFILTRATION

!  Differentiation of vic_vertical_transfer in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: hlsl husl1 husl2
!   with respect to varying inputs: hlsl ks cusl1 cusl2 husl1 husl2
!                clsl
  SUBROUTINE VIC_VERTICAL_TRANSFER_D(pet, cusl1, cusl1_d, cusl2, cusl2_d&
&   , clsl, clsl_d, ks, ks_d, husl1, husl1_d, husl2, husl2_d, hlsl, &
&   hlsl_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pet, cusl1, cusl2, clsl, ks
    REAL(sp), INTENT(IN) :: cusl1_d, cusl2_d, clsl_d, ks_d
    REAL(sp), INTENT(INOUT) :: husl1, husl2, hlsl
    REAL(sp), INTENT(INOUT) :: husl1_d, husl2_d, hlsl_d
    REAL(sp) :: fbc, fe, pet_remain
    REAL(sp) :: fbc_d, fe_d, pet_remain_d
    INTRINSIC MAX
    REAL(sp) :: pet_d
    CALL BROOKS_AND_COREY_FLOW_D(ks, ks_d, 0._sp, 1._sp, 1._sp, cusl1, &
&                          cusl1_d, cusl2, cusl2_d, husl1, husl1_d, &
&                          husl2, husl2_d, fbc, fbc_d)
    husl1_d = husl1_d - (fbc_d-fbc*cusl1_d/cusl1)/cusl1
    husl1 = husl1 - fbc/cusl1
    husl2_d = husl2_d + (fbc_d-fbc*cusl2_d/cusl2)/cusl2
    husl2 = husl2 + fbc/cusl2
    CALL BROOKS_AND_COREY_FLOW_D(ks, ks_d, 0._sp, 1._sp, 1._sp, cusl2, &
&                          cusl2_d, clsl, clsl_d, husl2, husl2_d, hlsl, &
&                          hlsl_d, fbc, fbc_d)
    husl2_d = husl2_d - (fbc_d-fbc*cusl2_d/cusl2)/cusl2
    husl2 = husl2 - fbc/cusl2
    hlsl_d = hlsl_d + (fbc_d-fbc*clsl_d/clsl)/clsl
    hlsl = hlsl + fbc/clsl
    pet_d = 0.0_4
    CALL LINEAR_EVAPOTRANSPIRATION_D(pet, pet_d, cusl1, cusl1_d, husl1, &
&                              husl1_d, fe, fe_d)
    husl1_d = husl1_d - (fe_d-fe*cusl1_d/cusl1)/cusl1
    husl1 = husl1 - fe/cusl1
    IF (0._sp .LT. pet - fe) THEN
      pet_remain_d = -fe_d
      pet_remain = pet - fe
    ELSE
      pet_remain = 0._sp
      pet_remain_d = 0.0_4
    END IF
    CALL LINEAR_EVAPOTRANSPIRATION_D(pet_remain, pet_remain_d, cusl2, &
&                              cusl2_d, husl2, husl2_d, fe, fe_d)
    husl2_d = husl2_d - (fe_d-fe*cusl2_d/cusl2)/cusl2
    husl2 = husl2 - fe/cusl2
    IF (0._sp .LT. pet_remain - fe) THEN
      pet_remain_d = pet_remain_d - fe_d
      pet_remain = pet_remain - fe
    ELSE
      pet_remain = 0._sp
      pet_remain_d = 0.0_4
    END IF
    CALL LINEAR_EVAPOTRANSPIRATION_D(pet_remain, pet_remain_d, clsl, &
&                              clsl_d, hlsl, hlsl_d, fe, fe_d)
    hlsl_d = hlsl_d - (fe_d-fe*clsl_d/clsl)/clsl
    hlsl = hlsl - fe/clsl
  END SUBROUTINE VIC_VERTICAL_TRANSFER_D

!  Differentiation of vic_vertical_transfer in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: hlsl ks cusl1 cusl2 husl1 husl2
!                clsl
!   with respect to varying inputs: hlsl ks cusl1 cusl2 husl1 husl2
!                clsl
  SUBROUTINE VIC_VERTICAL_TRANSFER_B(pet, cusl1, cusl1_b, cusl2, cusl2_b&
&   , clsl, clsl_b, ks, ks_b, husl1, husl1_b, husl2, husl2_b, hlsl, &
&   hlsl_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pet, cusl1, cusl2, clsl, ks
    REAL(sp) :: cusl1_b, cusl2_b, clsl_b, ks_b
    REAL(sp), INTENT(INOUT) :: husl1, husl2, hlsl
    REAL(sp), INTENT(INOUT) :: husl1_b, husl2_b, hlsl_b
    REAL(sp) :: fbc, fe, pet_remain
    REAL(sp) :: fbc_b, fe_b, pet_remain_b
    INTRINSIC MAX
    INTEGER :: branch
    REAL(sp) :: pet_b
    CALL BROOKS_AND_COREY_FLOW(ks, 0._sp, 1._sp, 1._sp, cusl1, cusl2, &
&                        husl1, husl2, fbc)
    CALL PUSHREAL4(husl1)
    husl1 = husl1 - fbc/cusl1
    CALL PUSHREAL4(husl2)
    husl2 = husl2 + fbc/cusl2
    CALL PUSHREAL4(fbc)
    CALL BROOKS_AND_COREY_FLOW(ks, 0._sp, 1._sp, 1._sp, cusl2, clsl, &
&                        husl2, hlsl, fbc)
    CALL PUSHREAL4(husl2)
    husl2 = husl2 - fbc/cusl2
    CALL PUSHREAL4(hlsl)
    hlsl = hlsl + fbc/clsl
    CALL LINEAR_EVAPOTRANSPIRATION(pet, cusl1, husl1, fe)
    IF (0._sp .LT. pet - fe) THEN
      pet_remain = pet - fe
      CALL PUSHCONTROL1B(0)
    ELSE
      pet_remain = 0._sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(fe)
    CALL LINEAR_EVAPOTRANSPIRATION(pet_remain, cusl2, husl2, fe)
    IF (0._sp .LT. pet_remain - fe) THEN
      CALL PUSHREAL4(pet_remain)
      pet_remain = pet_remain - fe
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL4(pet_remain)
      pet_remain = 0._sp
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(fe)
    CALL LINEAR_EVAPOTRANSPIRATION(pet_remain, clsl, hlsl, fe)
    fe_b = -(hlsl_b/clsl)
    clsl_b = clsl_b + fe*hlsl_b/clsl**2
    CALL POPREAL4(fe)
    pet_remain_b = 0.0_4
    CALL LINEAR_EVAPOTRANSPIRATION_B(pet_remain, pet_remain_b, clsl, &
&                              clsl_b, hlsl, hlsl_b, fe, fe_b)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(pet_remain)
      fe_b = -pet_remain_b
    ELSE
      CALL POPREAL4(pet_remain)
      pet_remain_b = 0.0_4
      fe_b = 0.0_4
    END IF
    fe_b = fe_b - husl2_b/cusl2
    cusl2_b = cusl2_b + fe*husl2_b/cusl2**2
    CALL POPREAL4(fe)
    CALL LINEAR_EVAPOTRANSPIRATION_B(pet_remain, pet_remain_b, cusl2, &
&                              cusl2_b, husl2, husl2_b, fe, fe_b)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      fe_b = -pet_remain_b
    ELSE
      fe_b = 0.0_4
    END IF
    fe_b = fe_b - husl1_b/cusl1
    cusl1_b = cusl1_b + fe*husl1_b/cusl1**2
    pet_b = 0.0_4
    CALL LINEAR_EVAPOTRANSPIRATION_B(pet, pet_b, cusl1, cusl1_b, husl1, &
&                              husl1_b, fe, fe_b)
    CALL POPREAL4(hlsl)
    fbc_b = hlsl_b/clsl - husl2_b/cusl2
    clsl_b = clsl_b - fbc*hlsl_b/clsl**2
    CALL POPREAL4(husl2)
    cusl2_b = cusl2_b + fbc*husl2_b/cusl2**2
    CALL POPREAL4(fbc)
    CALL BROOKS_AND_COREY_FLOW_B(ks, ks_b, 0._sp, 1._sp, 1._sp, cusl2, &
&                          cusl2_b, clsl, clsl_b, husl2, husl2_b, hlsl, &
&                          hlsl_b, fbc, fbc_b)
    CALL POPREAL4(husl2)
    fbc_b = husl2_b/cusl2 - husl1_b/cusl1
    cusl2_b = cusl2_b - fbc*husl2_b/cusl2**2
    CALL POPREAL4(husl1)
    cusl1_b = cusl1_b + fbc*husl1_b/cusl1**2
    CALL BROOKS_AND_COREY_FLOW_B(ks, ks_b, 0._sp, 1._sp, 1._sp, cusl1, &
&                          cusl1_b, cusl2, cusl2_b, husl1, husl1_b, &
&                          husl2, husl2_b, fbc, fbc_b)
  END SUBROUTINE VIC_VERTICAL_TRANSFER_B

  SUBROUTINE VIC_VERTICAL_TRANSFER(pet, cusl1, cusl2, clsl, ks, husl1, &
&   husl2, hlsl)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: pet, cusl1, cusl2, clsl, ks
    REAL(sp), INTENT(INOUT) :: husl1, husl2, hlsl
    REAL(sp) :: fbc, fe, pet_remain
    INTRINSIC MAX
    CALL BROOKS_AND_COREY_FLOW(ks, 0._sp, 1._sp, 1._sp, cusl1, cusl2, &
&                        husl1, husl2, fbc)
    husl1 = husl1 - fbc/cusl1
    husl2 = husl2 + fbc/cusl2
    CALL BROOKS_AND_COREY_FLOW(ks, 0._sp, 1._sp, 1._sp, cusl2, clsl, &
&                        husl2, hlsl, fbc)
    husl2 = husl2 - fbc/cusl2
    hlsl = hlsl + fbc/clsl
    CALL LINEAR_EVAPOTRANSPIRATION(pet, cusl1, husl1, fe)
    husl1 = husl1 - fe/cusl1
    IF (0._sp .LT. pet - fe) THEN
      pet_remain = pet - fe
    ELSE
      pet_remain = 0._sp
    END IF
    CALL LINEAR_EVAPOTRANSPIRATION(pet_remain, cusl2, husl2, fe)
    husl2 = husl2 - fe/cusl2
    IF (0._sp .LT. pet_remain - fe) THEN
      pet_remain = pet_remain - fe
    ELSE
      pet_remain = 0._sp
    END IF
    CALL LINEAR_EVAPOTRANSPIRATION(pet_remain, clsl, hlsl, fe)
    hlsl = hlsl - fe/clsl
  END SUBROUTINE VIC_VERTICAL_TRANSFER

!  Differentiation of vic_interflow in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: qi husl2
!   with respect to varying inputs: cusl2 husl2
  SUBROUTINE VIC_INTERFLOW_D(n, cusl2, cusl2_d, husl2, husl2_d, qi, qi_d&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, cusl2
    REAL(sp), INTENT(IN) :: cusl2_d
    REAL(sp), INTENT(INOUT) :: husl2
    REAL(sp), INTENT(INOUT) :: husl2_d
    REAL(sp), INTENT(OUT) :: qi
    REAL(sp), INTENT(OUT) :: qi_d
    REAL(sp) :: nm1, d1pnm1, husl2_imd
    REAL(sp) :: husl2_imd_d
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_d
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_d
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_d
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    husl2_imd_d = husl2_d
    husl2_imd = husl2
    pwx1_d = cusl2*husl2_imd_d + husl2_imd*cusl2_d
    pwx1 = husl2_imd*cusl2
    pwy1 = -nm1
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = pwy1*pwx1**(pwy1-1)*pwx1_d
    END IF
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    IF (cusl2 .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&   THEN
      pwr2_d = 0.0_4
    ELSE
      pwr2_d = pwy2*cusl2**(pwy2-1)*cusl2_d
    END IF
    pwr2 = cusl2**pwy2
    pwx3_d = pwr1_d + pwr2_d
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwr3_d = 0.0_4
    ELSE
      pwr3_d = pwy3*pwx3**(pwy3-1)*pwx3_d
    END IF
    pwr3 = pwx3**pwy3
    husl2_d = (pwr3_d-pwr3*cusl2_d/cusl2)/cusl2
    husl2 = pwr3/cusl2
    qi_d = cusl2*(husl2_imd_d-husl2_d) + (husl2_imd-husl2)*cusl2_d
    qi = (husl2_imd-husl2)*cusl2
  END SUBROUTINE VIC_INTERFLOW_D

!  Differentiation of vic_interflow in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: qi cusl2 husl2
!   with respect to varying inputs: cusl2 husl2
  SUBROUTINE VIC_INTERFLOW_B(n, cusl2, cusl2_b, husl2, husl2_b, qi, qi_b&
& )
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, cusl2
    REAL(sp) :: cusl2_b
    REAL(sp), INTENT(INOUT) :: husl2
    REAL(sp), INTENT(INOUT) :: husl2_b
    REAL(sp) :: qi
    REAL(sp) :: qi_b
    REAL(sp) :: nm1, d1pnm1, husl2_imd
    REAL(sp) :: husl2_imd_b
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwr2_b
    REAL(sp) :: pwx3
    REAL(sp) :: pwx3_b
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    REAL(sp) :: pwr3_b
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    husl2_imd = husl2
    pwx1 = husl2_imd*cusl2
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = cusl2**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    husl2 = pwr3/cusl2
    pwx1 = husl2_imd*cusl2
    nm1 = n - 1._sp
    pwy1 = -nm1
    pwy2 = -nm1
    d1pnm1 = 1._sp/nm1
    pwy3 = -d1pnm1
    husl2_b = husl2_b - cusl2*qi_b
    pwr3_b = husl2_b/cusl2
    IF (pwx3 .LE. 0.0 .AND. (pwy3 .EQ. 0.0 .OR. pwy3 .NE. INT(pwy3))) &
&   THEN
      pwx3_b = 0.0_4
    ELSE
      pwx3_b = pwy3*pwx3**(pwy3-1)*pwr3_b
    END IF
    pwr1_b = pwx3_b
    pwr2_b = pwx3_b
    IF (pwx1 .LE. 0.0 .AND. (pwy1 .EQ. 0.0 .OR. pwy1 .NE. INT(pwy1))) &
&   THEN
      pwx1_b = 0.0_4
    ELSE
      pwx1_b = pwy1*pwx1**(pwy1-1)*pwr1_b
    END IF
    husl2_imd_b = cusl2*qi_b + cusl2*pwx1_b
    IF (cusl2 .LE. 0.0 .AND. (pwy2 .EQ. 0.0 .OR. pwy2 .NE. INT(pwy2))) &
&   THEN
      cusl2_b = cusl2_b + (husl2_imd-husl2)*qi_b + husl2_imd*pwx1_b - &
&       pwr3*husl2_b/cusl2**2
    ELSE
      cusl2_b = cusl2_b + (husl2_imd-husl2)*qi_b + pwy2*cusl2**(pwy2-1)*&
&       pwr2_b - pwr3*husl2_b/cusl2**2 + husl2_imd*pwx1_b
    END IF
    husl2_b = husl2_imd_b
  END SUBROUTINE VIC_INTERFLOW_B

  SUBROUTINE VIC_INTERFLOW(n, cusl2, husl2, qi)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: n, cusl2
    REAL(sp), INTENT(INOUT) :: husl2
    REAL(sp), INTENT(OUT) :: qi
    REAL(sp) :: nm1, d1pnm1, husl2_imd
    REAL(sp) :: pwx1
    REAL(sp) :: pwy1
    REAL(sp) :: pwr1
    REAL(sp) :: pwy2
    REAL(sp) :: pwr2
    REAL(sp) :: pwx3
    REAL(sp) :: pwy3
    REAL(sp) :: pwr3
    nm1 = n - 1._sp
    d1pnm1 = 1._sp/nm1
    husl2_imd = husl2
    pwx1 = husl2_imd*cusl2
    pwy1 = -nm1
    pwr1 = pwx1**pwy1
    pwy2 = -nm1
    pwr2 = cusl2**pwy2
    pwx3 = pwr1 + pwr2
    pwy3 = -d1pnm1
    pwr3 = pwx3**pwy3
    husl2 = pwr3/cusl2
    qi = (husl2_imd-husl2)*cusl2
  END SUBROUTINE VIC_INTERFLOW

!  Differentiation of vic_baseflow in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: qb hlsl
!   with respect to varying inputs: ws ds hlsl clsl dsm
  SUBROUTINE VIC_BASEFLOW_D(clsl, clsl_d, ds, ds_d, dsm, dsm_d, ws, ws_d&
&   , hlsl, hlsl_d, qb, qb_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: clsl, ds, dsm, ws
    REAL(sp), INTENT(IN) :: clsl_d, ds_d, dsm_d, ws_d
    REAL(sp), INTENT(INOUT) :: hlsl
    REAL(sp), INTENT(INOUT) :: hlsl_d
    REAL(sp), INTENT(OUT) :: qb
    REAL(sp), INTENT(OUT) :: qb_d
    REAL(sp) :: wlsl
    REAL(sp) :: wlsl_d
    INTRINSIC MIN
    REAL(sp) :: temp
    REAL(sp) :: temp0
    IF (hlsl .LE. ws) THEN
      temp = hlsl/ws
      qb_d = temp*(dsm*ds_d+ds*dsm_d) + ds*dsm*(hlsl_d-temp*ws_d)/ws
      qb = ds*dsm*temp
    ELSE
      temp = dsm/(-ws+1._sp)
      temp0 = ds/ws
      qb_d = (1._sp-temp0)*(temp*(hlsl_d-ws_d)+(hlsl-ws)*(dsm_d+temp*&
&       ws_d)/(1._sp-ws)) - (hlsl-ws)*temp*(ds_d-temp0*ws_d)/ws
      qb = (1._sp-temp0)*((hlsl-ws)*temp)
    END IF
    wlsl_d = hlsl*clsl_d + clsl*hlsl_d
    wlsl = clsl*hlsl
    IF (wlsl .GT. qb) THEN
      qb = qb
    ELSE
      qb_d = wlsl_d
      qb = wlsl
    END IF
    hlsl_d = hlsl_d - (qb_d-qb*clsl_d/clsl)/clsl
    hlsl = hlsl - qb/clsl
  END SUBROUTINE VIC_BASEFLOW_D

!  Differentiation of vic_baseflow in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: qb ws ds hlsl clsl dsm
!   with respect to varying inputs: ws ds hlsl clsl dsm
  SUBROUTINE VIC_BASEFLOW_B(clsl, clsl_b, ds, ds_b, dsm, dsm_b, ws, ws_b&
&   , hlsl, hlsl_b, qb, qb_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: clsl, ds, dsm, ws
    REAL(sp) :: clsl_b, ds_b, dsm_b, ws_b
    REAL(sp), INTENT(INOUT) :: hlsl
    REAL(sp), INTENT(INOUT) :: hlsl_b
    REAL(sp) :: qb
    REAL(sp) :: qb_b
    REAL(sp) :: wlsl
    REAL(sp) :: wlsl_b
    INTRINSIC MIN
    REAL(sp) :: temp
    REAL(sp) :: temp_b
    REAL(sp) :: temp_b0
    REAL(sp) :: temp_b1
    INTEGER :: branch
    IF (hlsl .LE. ws) THEN
      qb = ds*dsm/ws*hlsl
      CALL PUSHCONTROL1B(1)
    ELSE
      qb = dsm*(1._sp-ds/ws)*(hlsl-ws)/(1._sp-ws)
      CALL PUSHCONTROL1B(0)
    END IF
    wlsl = clsl*hlsl
    IF (wlsl .GT. qb) THEN
      qb = qb
      CALL PUSHCONTROL1B(0)
    ELSE
      qb = wlsl
      CALL PUSHCONTROL1B(1)
    END IF
    qb_b = qb_b - hlsl_b/clsl
    clsl_b = clsl_b + qb*hlsl_b/clsl**2
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      wlsl_b = 0.0_4
    ELSE
      wlsl_b = qb_b
      qb_b = 0.0_4
    END IF
    clsl_b = clsl_b + hlsl*wlsl_b
    hlsl_b = hlsl_b + clsl*wlsl_b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp = dsm/(-ws+1._sp)
      temp_b0 = -((hlsl-ws)*temp*qb_b/ws)
      temp_b1 = (1._sp-ds/ws)*qb_b
      hlsl_b = hlsl_b + temp*temp_b1
      temp_b = (hlsl-ws)*temp_b1/(1._sp-ws)
      ws_b = ws_b + temp*temp_b - temp*temp_b1 - ds*temp_b0/ws
      dsm_b = dsm_b + temp_b
      ds_b = ds_b + temp_b0
    ELSE
      temp = hlsl/ws
      ds_b = ds_b + dsm*temp*qb_b
      dsm_b = dsm_b + ds*temp*qb_b
      temp_b = ds*dsm*qb_b/ws
      hlsl_b = hlsl_b + temp_b
      ws_b = ws_b - temp*temp_b
    END IF
  END SUBROUTINE VIC_BASEFLOW_B

  SUBROUTINE VIC_BASEFLOW(clsl, ds, dsm, ws, hlsl, qb)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: clsl, ds, dsm, ws
    REAL(sp), INTENT(INOUT) :: hlsl
    REAL(sp), INTENT(OUT) :: qb
    REAL(sp) :: wlsl
    INTRINSIC MIN
    IF (hlsl .LE. ws) THEN
      qb = ds*dsm/ws*hlsl
    ELSE
      qb = dsm*(1._sp-ds/ws)*(hlsl-ws)/(1._sp-ws)
    END IF
    wlsl = clsl*hlsl
    IF (wlsl .GT. qb) THEN
      qb = qb
    ELSE
      qb = wlsl
    END IF
    hlsl = hlsl - qb/clsl
  END SUBROUTINE VIC_BASEFLOW

!  Differentiation of brooks_and_corey_flow in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: flow
!   with respect to varying inputs: c_lower h_lower ks c_upper
!                h_upper
  SUBROUTINE BROOKS_AND_COREY_FLOW_D(ks, ks_d, residual, porosity, &
&   lambda, c_upper, c_upper_d, c_lower, c_lower_d, h_upper, h_upper_d, &
&   h_lower, h_lower_d, flow, flow_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: ks, residual, porosity, lambda, c_upper, &
&   c_lower, h_upper, h_lower
    REAL(sp), INTENT(IN) :: ks_d, c_upper_d, c_lower_d, h_upper_d, &
&   h_lower_d
    REAL(sp), INTENT(OUT) :: flow
    REAL(sp), INTENT(OUT) :: flow_d
    REAL(sp) :: w_upper, w_lower, max_flow
    REAL(sp) :: w_upper_d, w_lower_d, max_flow_d
    INTRINSIC MIN
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_d
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_d
    pwx1_d = h_upper_d/(porosity-residual)
    pwx1 = (h_upper-residual)/(porosity-residual)
    IF (pwx1 .LE. 0.0 .AND. (lambda .EQ. 0.0 .OR. lambda .NE. INT(lambda&
&       ))) THEN
      pwr1_d = 0.0_4
    ELSE
      pwr1_d = lambda*pwx1**(lambda-1)*pwx1_d
    END IF
    pwr1 = pwx1**lambda
    flow_d = pwr1*ks_d + ks*pwr1_d
    flow = ks*pwr1
    w_upper_d = porosity*(c_upper*h_upper_d+h_upper*c_upper_d)
    w_upper = h_upper*c_upper*porosity
    w_lower_d = porosity*(c_lower*h_lower_d+h_lower*c_lower_d)
    w_lower = h_lower*c_lower*porosity
    IF (w_upper .GT. c_lower - w_lower) THEN
      max_flow_d = c_lower_d - w_lower_d
      max_flow = c_lower - w_lower
    ELSE
      max_flow_d = w_upper_d
      max_flow = w_upper
    END IF
    IF (max_flow .GT. flow) THEN
      flow = flow
    ELSE
      flow_d = max_flow_d
      flow = max_flow
    END IF
  END SUBROUTINE BROOKS_AND_COREY_FLOW_D

!  Differentiation of brooks_and_corey_flow in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: c_lower flow h_lower ks c_upper
!                h_upper
!   with respect to varying inputs: c_lower h_lower ks c_upper
!                h_upper
  SUBROUTINE BROOKS_AND_COREY_FLOW_B(ks, ks_b, residual, porosity, &
&   lambda, c_upper, c_upper_b, c_lower, c_lower_b, h_upper, h_upper_b, &
&   h_lower, h_lower_b, flow, flow_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: ks, residual, porosity, lambda, c_upper, &
&   c_lower, h_upper, h_lower
    REAL(sp) :: ks_b, c_upper_b, c_lower_b, h_upper_b, h_lower_b
    REAL(sp) :: flow
    REAL(sp) :: flow_b
    REAL(sp) :: w_upper, w_lower, max_flow
    REAL(sp) :: w_upper_b, w_lower_b, max_flow_b
    INTRINSIC MIN
    REAL(sp) :: pwx1
    REAL(sp) :: pwx1_b
    REAL(sp) :: pwr1
    REAL(sp) :: pwr1_b
    INTEGER :: branch
    pwx1 = (h_upper-residual)/(porosity-residual)
    pwr1 = pwx1**lambda
    CALL PUSHREAL4(flow)
    flow = ks*pwr1
    w_upper = h_upper*c_upper*porosity
    w_lower = h_lower*c_lower*porosity
    IF (w_upper .GT. c_lower - w_lower) THEN
      max_flow = c_lower - w_lower
      CALL PUSHCONTROL1B(0)
    ELSE
      max_flow = w_upper
      CALL PUSHCONTROL1B(1)
    END IF
    IF (max_flow .GT. flow) THEN
      pwr1 = pwx1**lambda
      max_flow_b = 0.0_4
    ELSE
      pwr1 = pwx1**lambda
      max_flow_b = flow_b
      flow_b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      c_lower_b = c_lower_b + max_flow_b
      w_lower_b = -max_flow_b
      w_upper_b = 0.0_4
    ELSE
      w_upper_b = max_flow_b
      w_lower_b = 0.0_4
    END IF
    pwr1_b = ks*flow_b
    IF (pwx1 .LE. 0.0 .AND. (lambda .EQ. 0.0 .OR. lambda .NE. INT(lambda&
&       ))) THEN
      pwx1_b = 0.0_4
    ELSE
      pwx1_b = lambda*pwx1**(lambda-1)*pwr1_b
    END IF
    h_lower_b = h_lower_b + c_lower*porosity*w_lower_b
    c_lower_b = c_lower_b + h_lower*porosity*w_lower_b
    h_upper_b = h_upper_b + c_upper*porosity*w_upper_b + pwx1_b/(&
&     porosity-residual)
    c_upper_b = c_upper_b + h_upper*porosity*w_upper_b
    CALL POPREAL4(flow)
    ks_b = ks_b + pwr1*flow_b
  END SUBROUTINE BROOKS_AND_COREY_FLOW_B

  SUBROUTINE BROOKS_AND_COREY_FLOW(ks, residual, porosity, lambda, &
&   c_upper, c_lower, h_upper, h_lower, flow)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: ks, residual, porosity, lambda, c_upper, &
&   c_lower, h_upper, h_lower
    REAL(sp), INTENT(OUT) :: flow
    REAL(sp) :: w_upper, w_lower, max_flow
    INTRINSIC MIN
    REAL(sp) :: pwx1
    REAL(sp) :: pwr1
    pwx1 = (h_upper-residual)/(porosity-residual)
    pwr1 = pwx1**lambda
    flow = ks*pwr1
    w_upper = h_upper*c_upper*porosity
    w_lower = h_lower*c_lower*porosity
    IF (w_upper .GT. c_lower - w_lower) THEN
      max_flow = c_lower - w_lower
    ELSE
      max_flow = w_upper
    END IF
    IF (max_flow .GT. flow) THEN
      flow = flow
    ELSE
      flow = max_flow
    END IF
  END SUBROUTINE BROOKS_AND_COREY_FLOW

!  Differentiation of linear_evapotranspiration in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: flow
!   with respect to varying inputs: e h c
  SUBROUTINE LINEAR_EVAPOTRANSPIRATION_D(e, e_d, c, c_d, h, h_d, flow, &
&   flow_d)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: e, c, h
    REAL(sp), INTENT(IN) :: e_d, c_d, h_d
    REAL(sp), INTENT(OUT) :: flow
    REAL(sp), INTENT(OUT) :: flow_d
    REAL(sp) :: w
    REAL(sp) :: w_d
    INTRINSIC MIN
    flow_d = h*e_d + e*h_d
    flow = e*h
    w_d = h*c_d + c*h_d
    w = c*h
    IF (w .GT. flow) THEN
      flow = flow
    ELSE
      flow_d = w_d
      flow = w
    END IF
  END SUBROUTINE LINEAR_EVAPOTRANSPIRATION_D

!  Differentiation of linear_evapotranspiration in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: e h flow c
!   with respect to varying inputs: e h c
  SUBROUTINE LINEAR_EVAPOTRANSPIRATION_B(e, e_b, c, c_b, h, h_b, flow, &
&   flow_b)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: e, c, h
    REAL(sp) :: e_b, c_b, h_b
    REAL(sp) :: flow
    REAL(sp) :: flow_b
    REAL(sp) :: w
    REAL(sp) :: w_b
    INTRINSIC MIN
    CALL PUSHREAL4(flow)
    flow = e*h
    w = c*h
    IF (w .GT. flow) THEN
      w_b = 0.0_4
    ELSE
      w_b = flow_b
      flow_b = 0.0_4
    END IF
    c_b = c_b + h*w_b
    h_b = h_b + c*w_b + e*flow_b
    CALL POPREAL4(flow)
    e_b = e_b + h*flow_b
  END SUBROUTINE LINEAR_EVAPOTRANSPIRATION_B

  SUBROUTINE LINEAR_EVAPOTRANSPIRATION(e, c, h, flow)
    IMPLICIT NONE
    REAL(sp), INTENT(IN) :: e, c, h
    REAL(sp), INTENT(OUT) :: flow
    REAL(sp) :: w
    INTRINSIC MIN
    flow = e*h
    w = c*h
    IF (w .GT. flow) THEN
      flow = flow
    ELSE
      flow = w
    END IF
  END SUBROUTINE LINEAR_EVAPOTRANSPIRATION

END MODULE MD_VIC_OPERATOR_DIFF

!%      This module `md_forward_structure` encapsulates all SMASH forward_structure.
!%      This module is differentiated.
!%
!%      contains
!%
!%      [1] gr_a_forward
!%      [2] gr_b_forward
!%      [2] gr_c_forward
!%      [2] gr_d_forward
!%      [3] vic_a_forward
MODULE MD_FORWARD_STRUCTURE_DIFF
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: gr_interception, gr_production, gr_exchange, &
  USE MD_GR_OPERATOR_DIFF
!% & gr_transfer
!% only: vic_infiltration, vic_vertical_transfer, vic_interflow, vic_baseflow
  USE MD_VIC_OPERATOR_DIFF
!% only: upstream_discharge, linear_routing
  USE MD_ROUTING_OPERATOR_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of gr_a_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim) *(output.qsim_domain)
!                *(states.hp) *(states.hft) *(states.hlr)
!   with respect to varying inputs: *(parameters.cp) *(parameters.cft)
!                *(parameters.exc) *(parameters.lr) *(states.hp)
!                *(states.hft) *(states.hlr)
!   Plus diff mem management of: parameters.cp:in parameters.cft:in
!                parameters.exc:in parameters.lr:in output.qsim:in
!                output.qsim_domain:in states.hp:in states.hft:in
!                states.hlr:in
  SUBROUTINE GR_A_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, states, states_d, output, output_d)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    REAL(sp) :: pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d, qd_d&
&   , qt_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    REAL(sp) :: temp
    REAL :: temp0
    output_d%qsim = 0.0_4
    output_d%qsim_domain = 0.0_4
    q_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              en_d = 0.0_4
              pn_d = 0.0_4
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), 1000._sp&
&                            , states%hp(row, col), states_d%hp(row, col&
&                            ), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            ELSE
              l_d = 0.0_4
              perc_d = 0.0_4
              pr_d = 0.0_4
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr_d = 0.9_sp*(pr_d+perc_d) + l_d
            prr = 0.9_sp*(pr+perc) + l
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
            qt_d = qr_d + qd_d
            qt = qr + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%flwacc, row, &
&                               col, q, q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
            temp = 0.001_sp*(mesh%dx*mesh%dx)
            temp0 = REAL(mesh%flwacc(row, col) - 1)
            q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
            q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (.NOT.setup%sparse_storage) output_d%qsim_domain(row, &
&               col, t) = q_d(row, col)
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%qsim(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%gauge_pos(g&
&         , 2))
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_A_FORWARD_D

!  Differentiation of gr_a_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.cp) *(parameters.cft)
!                *(parameters.exc) *(parameters.lr) *(output.qsim)
!                *(output.qsim_domain) *(states.hp) *(states.hft)
!                *(states.hlr)
!   with respect to varying inputs: *(parameters.cp) *(parameters.cft)
!                *(parameters.exc) *(parameters.lr) *(states.hp)
!                *(states.hft) *(states.hlr)
!   Plus diff mem management of: parameters.cp:in parameters.cft:in
!                parameters.exc:in parameters.lr:in output.qsim:in
!                output.qsim_domain:in states.hp:in states.hft:in
!                states.hlr:in
  SUBROUTINE GR_A_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, states, states_b, output, output_b)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    REAL(sp) :: pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b, qd_b&
&   , qt_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    REAL*4 :: temp_b
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                CALL PUSHREAL4(pn)
                pn = prcp - ei
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL4(pn)
                pn = 0._sp
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHREAL4(en)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            CALL PUSHREAL4(prr)
            prr = 0.9_sp*(pr+perc) + l
            prd = 0.1_sp*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL1B(0)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL1B(1)
            END IF
            qt = qr + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL PUSHREAL4(qup)
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL PUSHREAL4(states%hlr(row, col))
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    q_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      END DO
      DO 100 i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              row = mesh%path(1, i)
              col = mesh%path(2, i)
              q_b(row, col) = q_b(row, col) + output_b%qsim_domain(row, &
&               col, t)
              output_b%qsim_domain(row, col, t) = 0.0_4
            ELSE
              row = mesh%path(1, i)
              col = mesh%path(2, i)
            END IF
          END IF
          temp_b = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b
          qrout_b = REAL(mesh%flwacc(row, col)-1)*temp_b
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, q_b, qup, qup_b)
          qr_b = qt_b
          qd_b = qt_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(states%hft(row, col))
          CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row&
&                      , col), parameters_b%cft(row, col), states%hft(&
&                      row, col), states_b%hft(row, col), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%&
&                        exc(row, col), states%hft(row, col), states_b%&
&                        hft(row, col), l, l_b)
            CALL POPREAL4(states%hp(row, col))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, &
&                          col), parameters_b%cp(row, col), 1000._sp, &
&                          states%hp(row, col), states_b%hp(row, col), &
&                          pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(pn)
            ELSE
              CALL POPREAL4(pn)
            END IF
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 100  CONTINUE
    END DO
  END SUBROUTINE GR_A_FORWARD_B

  SUBROUTINE GR_A_FORWARD(setup, mesh, input_data, parameters, states, &
&   output)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qr = 0._sp
        qd = 0._sp
        qup = 0._sp
        qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr = 0.9_sp*(pr+perc) + l
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
            qt = qr + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
            IF (setup%save_net_prcp_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_net_prcp_domain(k, t) = qt
              ELSE
                output%net_prcp_domain(row, col, t) = qt
              END IF
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_qsim_domain(k, t) = q(row, col)
              ELSE
                output%qsim_domain(row, col, t) = q(row, col)
              END IF
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_A_FORWARD

!  Differentiation of gr_b_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim) *(output.qsim_domain)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hlr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.cft:in parameters.exc:in parameters.lr:in
!                output.qsim:in output.qsim_domain:in states.hi:in
!                states.hp:in states.hft:in states.hlr:in
  SUBROUTINE GR_B_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, states, states_d, output, output_d)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d&
&   , qd_d, qt_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTRINSIC REAL
    REAL(sp) :: temp
    REAL :: temp0
    output_d%qsim = 0.0_4
    output_d%qsim_domain = 0.0_4
    q_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
              en_d = -ei_d
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), 1000._sp&
&                            , states%hp(row, col), states_d%hp(row, col&
&                            ), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            ELSE
              l_d = 0.0_4
              perc_d = 0.0_4
              pr_d = 0.0_4
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr_d = 0.9_sp*(pr_d+perc_d) + l_d
            prr = 0.9_sp*(pr+perc) + l
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
            qt_d = qr_d + qd_d
            qt = qr + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%flwacc, row, &
&                               col, q, q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
            temp = 0.001_sp*(mesh%dx*mesh%dx)
            temp0 = REAL(mesh%flwacc(row, col) - 1)
            q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
            q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (.NOT.setup%sparse_storage) output_d%qsim_domain(row, &
&               col, t) = q_d(row, col)
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%qsim(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%gauge_pos(g&
&         , 2))
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_B_FORWARD_D

!  Differentiation of gr_b_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.exc) *(parameters.lr)
!                *(output.qsim) *(output.qsim_domain) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hlr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.exc) *(parameters.lr)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.cft:in parameters.exc:in parameters.lr:in
!                output.qsim:in output.qsim_domain:in states.hi:in
!                states.hp:in states.hft:in states.hlr:in
  SUBROUTINE GR_B_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, states, states_b, output, output_b)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b&
&   , qd_b, qt_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTRINSIC REAL
    REAL*4 :: temp_b
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              CALL PUSHREAL4(pet)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              CALL PUSHREAL4(pet)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL PUSHREAL4(pn)
              CALL PUSHREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              CALL PUSHREAL4(en)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            CALL PUSHREAL4(prr)
            prr = 0.9_sp*(pr+perc) + l
            prd = 0.1_sp*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL1B(0)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL1B(1)
            END IF
            qt = qr + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL PUSHREAL4(qup)
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL PUSHREAL4(states%hlr(row, col))
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    q_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      END DO
      DO 100 i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              row = mesh%path(1, i)
              col = mesh%path(2, i)
              q_b(row, col) = q_b(row, col) + output_b%qsim_domain(row, &
&               col, t)
              output_b%qsim_domain(row, col, t) = 0.0_4
            ELSE
              row = mesh%path(1, i)
              col = mesh%path(2, i)
            END IF
          END IF
          temp_b = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b
          qrout_b = REAL(mesh%flwacc(row, col)-1)*temp_b
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, q_b, qup, qup_b)
          qr_b = qt_b
          qd_b = qt_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(states%hft(row, col))
          CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row&
&                      , col), parameters_b%cft(row, col), states%hft(&
&                      row, col), states_b%hft(row, col), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%&
&                        exc(row, col), states%hft(row, col), states_b%&
&                        hft(row, col), l, l_b)
            CALL POPREAL4(states%hp(row, col))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, &
&                          col), parameters_b%cp(row, col), 1000._sp, &
&                          states%hp(row, col), states_b%hp(row, col), &
&                          pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(states%hi(row, col))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col), &
&                            parameters_b%ci(row, col), states%hi(row, &
&                            col), states_b%hi(row, col), pn, pn_b, ei, &
&                            ei_b)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 100  CONTINUE
    END DO
  END SUBROUTINE GR_B_FORWARD_B

  SUBROUTINE GR_B_FORWARD(setup, mesh, input_data, parameters, states, &
&   output)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTRINSIC REAL
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qr = 0._sp
        qd = 0._sp
        qup = 0._sp
        qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr = 0.9_sp*(pr+perc) + l
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
            qt = qr + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
            IF (setup%save_net_prcp_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_net_prcp_domain(k, t) = qt
              ELSE
                output%net_prcp_domain(row, col, t) = qt
              END IF
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_qsim_domain(k, t) = q(row, col)
              ELSE
                output%qsim_domain(row, col, t) = q(row, col)
              END IF
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_B_FORWARD

!  Differentiation of gr_c_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim) *(output.qsim_domain)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.cst) *(parameters.exc)
!                *(parameters.lr) *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.cft:in parameters.cst:in parameters.exc:in
!                parameters.lr:in output.qsim:in output.qsim_domain:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.hlr:in
  SUBROUTINE GR_C_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, states, states_d, output, output_d)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qr, &
&   ql, qd, qt, qup, qrout
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prl_d, prd_d&
&   , qr_d, ql_d, qd_d, qt_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTRINSIC REAL
    REAL(sp) :: temp
    REAL :: temp0
    output_d%qsim = 0.0_4
    output_d%qsim_domain = 0.0_4
    q_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
              en_d = -ei_d
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), 1000._sp&
&                            , states%hp(row, col), states_d%hp(row, col&
&                            ), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            ELSE
              l_d = 0.0_4
              perc_d = 0.0_4
              pr_d = 0.0_4
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr_d = 0.6_sp*0.9_sp*(pr_d+perc_d) + l_d
            prr = 0.9_sp*0.6_sp*(pr+perc) + l
            prl_d = 0.4_sp*0.9_sp*(pr_d+perc_d)
            prl = 0.9_sp*0.4_sp*(pr+perc)
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            CALL GR_TRANSFER_D(5._sp, prcp, prl, prl_d, parameters%cst(&
&                        row, col), parameters_d%cst(row, col), states%&
&                        hst(row, col), states_d%hst(row, col), ql, ql_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
            qt_d = qr_d + ql_d + qd_d
            qt = qr + ql + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%flwacc, row, &
&                               col, q, q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
            temp = 0.001_sp*(mesh%dx*mesh%dx)
            temp0 = REAL(mesh%flwacc(row, col) - 1)
            q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
            q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (.NOT.setup%sparse_storage) output_d%qsim_domain(row, &
&               col, t) = q_d(row, col)
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%qsim(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%gauge_pos(g&
&         , 2))
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_C_FORWARD_D

!  Differentiation of gr_c_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.cst) *(parameters.exc)
!                *(parameters.lr) *(output.qsim) *(output.qsim_domain)
!                *(states.hi) *(states.hp) *(states.hft) *(states.hst)
!                *(states.hlr)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.cst) *(parameters.exc)
!                *(parameters.lr) *(states.hi) *(states.hp) *(states.hft)
!                *(states.hst) *(states.hlr)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.cft:in parameters.cst:in parameters.exc:in
!                parameters.lr:in output.qsim:in output.qsim_domain:in
!                states.hi:in states.hp:in states.hft:in states.hst:in
!                states.hlr:in
  SUBROUTINE GR_C_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, states, states_b, output, output_b)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qr, &
&   ql, qd, qt, qup, qrout
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prl_b, prd_b&
&   , qr_b, ql_b, qd_b, qt_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTRINSIC REAL
    REAL(sp) :: temp_b
    REAL*4 :: temp_b0
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              CALL PUSHREAL4(pet)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              CALL PUSHREAL4(pet)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL PUSHREAL4(pn)
              CALL PUSHREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              CALL PUSHREAL4(en)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            CALL PUSHREAL4(prr)
            prr = 0.9_sp*0.6_sp*(pr+perc) + l
            CALL PUSHREAL4(prl)
            prl = 0.9_sp*0.4_sp*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            CALL PUSHREAL4(states%hst(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prl, parameters%cst(row, col)&
&                      , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
              CALL PUSHCONTROL1B(0)
            ELSE
              qd = 0._sp
              CALL PUSHCONTROL1B(1)
            END IF
            qt = qr + ql + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL PUSHREAL4(qup)
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL PUSHREAL4(states%hlr(row, col))
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    q_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      END DO
      DO 100 i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              row = mesh%path(1, i)
              col = mesh%path(2, i)
              q_b(row, col) = q_b(row, col) + output_b%qsim_domain(row, &
&               col, t)
              output_b%qsim_domain(row, col, t) = 0.0_4
            ELSE
              row = mesh%path(1, i)
              col = mesh%path(2, i)
            END IF
          END IF
          temp_b0 = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b0
          qrout_b = REAL(mesh%flwacc(row, col)-1)*temp_b0
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, q_b, qup, qup_b)
          qr_b = qt_b
          ql_b = qt_b
          qd_b = qt_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(states%hst(row, col))
          CALL GR_TRANSFER_B(5._sp, prcp, prl, prl_b, parameters%cst(row&
&                      , col), parameters_b%cst(row, col), states%hst(&
&                      row, col), states_b%hst(row, col), ql, ql_b)
          CALL POPREAL4(states%hft(row, col))
          CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row&
&                      , col), parameters_b%cft(row, col), states%hft(&
&                      row, col), states_b%hft(row, col), qr, qr_b)
          CALL POPREAL4(prl)
          temp_b = 0.4_sp*0.9_sp*prl_b
          pr_b = 0.1_sp*prd_b + temp_b
          perc_b = 0.1_sp*prd_b + temp_b
          CALL POPREAL4(prr)
          temp_b = 0.6_sp*0.9_sp*prr_b
          l_b = l_b + prr_b
          pr_b = pr_b + temp_b
          perc_b = perc_b + temp_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%&
&                        exc(row, col), states%hft(row, col), states_b%&
&                        hft(row, col), l, l_b)
            CALL POPREAL4(states%hp(row, col))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, &
&                          col), parameters_b%cp(row, col), 1000._sp, &
&                          states%hp(row, col), states_b%hp(row, col), &
&                          pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(states%hi(row, col))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col), &
&                            parameters_b%ci(row, col), states%hi(row, &
&                            col), states_b%hi(row, col), pn, pn_b, ei, &
&                            ei_b)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 100  CONTINUE
    END DO
  END SUBROUTINE GR_C_FORWARD_B

  SUBROUTINE GR_C_FORWARD(setup, mesh, input_data, parameters, states, &
&   output)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prl, prd, qr, &
&   ql, qd, qt, qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTRINSIC REAL
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prl = 0._sp
        prd = 0._sp
        qr = 0._sp
        ql = 0._sp
        qd = 0._sp
        qup = 0._sp
        qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr = 0.9_sp*0.6_sp*(pr+perc) + l
            prl = 0.9_sp*0.4_sp*(pr+perc)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            CALL GR_TRANSFER(5._sp, prcp, prl, parameters%cst(row, col)&
&                      , states%hst(row, col), ql)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
            qt = qr + ql + qd
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
            IF (setup%save_net_prcp_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_net_prcp_domain(k, t) = qt
              ELSE
                output%net_prcp_domain(row, col, t) = qt
              END IF
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_qsim_domain(k, t) = q(row, col)
              ELSE
                output%qsim_domain(row, col, t) = q(row, col)
              END IF
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_C_FORWARD

!  Differentiation of gr_d_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim) *(output.qsim_domain)
!                *(states.hp) *(states.hft) *(states.hlr)
!   with respect to varying inputs: *(parameters.cp) *(parameters.cft)
!                *(parameters.lr) *(states.hp) *(states.hft) *(states.hlr)
!   Plus diff mem management of: parameters.cp:in parameters.cft:in
!                parameters.lr:in output.qsim:in output.qsim_domain:in
!                states.hp:in states.hft:in states.hlr:in
  SUBROUTINE GR_D_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, states, states_d, output, output_d)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, prr, qr, qt, qup, qrout
    REAL(sp) :: pn_d, en_d, pr_d, perc_d, prr_d, qr_d, qt_d, qup_d, &
&   qrout_d
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    REAL(sp) :: temp
    REAL :: temp0
    output_d%qsim = 0.0_4
    output_d%qsim_domain = 0.0_4
    q_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              en_d = 0.0_4
              pn_d = 0.0_4
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), 1000._sp&
&                            , states%hp(row, col), states_d%hp(row, col&
&                            ), pr, pr_d, perc, perc_d)
            ELSE
              perc_d = 0.0_4
              pr_d = 0.0_4
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr_d = pr_d + perc_d
            prr = pr + perc
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            qt_d = qr_d
            qt = qr
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%flwacc, row, &
&                               col, q, q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
            temp = 0.001_sp*(mesh%dx*mesh%dx)
            temp0 = REAL(mesh%flwacc(row, col) - 1)
            q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
            q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (.NOT.setup%sparse_storage) output_d%qsim_domain(row, &
&               col, t) = q_d(row, col)
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%qsim(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%gauge_pos(g&
&         , 2))
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_D_FORWARD_D

!  Differentiation of gr_d_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.cp) *(parameters.cft)
!                *(parameters.lr) *(output.qsim) *(output.qsim_domain)
!                *(states.hp) *(states.hft) *(states.hlr)
!   with respect to varying inputs: *(parameters.cp) *(parameters.cft)
!                *(parameters.lr) *(states.hp) *(states.hft) *(states.hlr)
!   Plus diff mem management of: parameters.cp:in parameters.cft:in
!                parameters.lr:in output.qsim:in output.qsim_domain:in
!                states.hp:in states.hft:in states.hlr:in
  SUBROUTINE GR_D_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, states, states_b, output, output_b)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, prr, qr, qt, qup, qrout
    REAL(sp) :: pn_b, en_b, pr_b, perc_b, prr_b, qr_b, qt_b, qup_b, &
&   qrout_b
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
    REAL*4 :: temp_b
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                CALL PUSHREAL4(pn)
                pn = prcp - ei
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL4(pn)
                pn = 0._sp
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHREAL4(en)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            CALL PUSHREAL4(prr)
            prr = pr + perc
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            qt = qr
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL PUSHREAL4(qup)
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL PUSHREAL4(states%hlr(row, col))
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    q_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      END DO
      DO 100 i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              row = mesh%path(1, i)
              col = mesh%path(2, i)
              q_b(row, col) = q_b(row, col) + output_b%qsim_domain(row, &
&               col, t)
              output_b%qsim_domain(row, col, t) = 0.0_4
            ELSE
              row = mesh%path(1, i)
              col = mesh%path(2, i)
            END IF
          END IF
          temp_b = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b
          qrout_b = REAL(mesh%flwacc(row, col)-1)*temp_b
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, q_b, qup, qup_b)
          qr_b = qt_b
          CALL POPREAL4(states%hft(row, col))
          CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row&
&                      , col), parameters_b%cft(row, col), states%hft(&
&                      row, col), states_b%hft(row, col), qr, qr_b)
          CALL POPREAL4(prr)
          pr_b = prr_b
          perc_b = prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(states%hp(row, col))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, &
&                          col), parameters_b%cp(row, col), 1000._sp, &
&                          states%hp(row, col), states_b%hp(row, col), &
&                          pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(pn)
            ELSE
              CALL POPREAL4(pn)
            END IF
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 100  CONTINUE
    END DO
  END SUBROUTINE GR_D_FORWARD_B

  SUBROUTINE GR_D_FORWARD(setup, mesh, input_data, parameters, states, &
&   output)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, prr, qr, qt, qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC REAL
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        prr = 0._sp
        qr = 0._sp
        qup = 0._sp
        qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
              IF (pet .GT. prcp) THEN
                ei = prcp
              ELSE
                ei = pet
              END IF
              IF (0._sp .LT. prcp - ei) THEN
                pn = prcp - ei
              ELSE
                pn = 0._sp
              END IF
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr = pr + perc
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            qt = qr
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
            IF (setup%save_net_prcp_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_net_prcp_domain(k, t) = qt
              ELSE
                output%net_prcp_domain(row, col, t) = qt
              END IF
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_qsim_domain(k, t) = q(row, col)
              ELSE
                output%qsim_domain(row, col, t) = q(row, col)
              END IF
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_D_FORWARD

!  Differentiation of gr_g_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim) *(output.qsim_domain)
!                *(states.hi) *(states.hp) *(states.hft)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.exc) *(states.hi)
!                *(states.hp) *(states.hft)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.cft:in parameters.exc:in output.qsim:in
!                output.qsim_domain:in states.hi:in states.hp:in
!                states.hft:in
  SUBROUTINE GR_G_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, states, states_d, output, output_d)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    REAL(sp) :: ei_d, pn_d, en_d, pr_d, perc_d, l_d, prr_d, prd_d, qr_d&
&   , qd_d, qt_d
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    REAL(sp) :: temp
    output_d%qsim = 0.0_4
    output_d%qsim_domain = 0.0_4
    q_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL GR_INTERCEPTION_D(prcp, pet, parameters%ci(row, col)&
&                              , parameters_d%ci(row, col), states%hi(&
&                              row, col), states_d%hi(row, col), pn, &
&                              pn_d, ei, ei_d)
              en_d = -ei_d
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION_D(pn, pn_d, en, en_d, parameters%cp(row&
&                            , col), parameters_d%cp(row, col), 1000._sp&
&                            , states%hp(row, col), states_d%hp(row, col&
&                            ), pr, pr_d, perc, perc_d)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE_D(parameters%exc(row, col), parameters_d%&
&                          exc(row, col), states%hft(row, col), states_d&
&                          %hft(row, col), l, l_d)
            ELSE
              l_d = 0.0_4
              perc_d = 0.0_4
              pr_d = 0.0_4
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr_d = 0.9_sp*(pr_d+perc_d) + l_d
            prr = 0.9_sp*(pr+perc) + l
            prd_d = 0.1_sp*(pr_d+perc_d)
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER_D(5._sp, prcp, prr, prr_d, parameters%cft(&
&                        row, col), parameters_d%cft(row, col), states%&
&                        hft(row, col), states_d%hft(row, col), qr, qr_d&
&                       )
            IF (0._sp .LT. prd + l) THEN
              qd_d = prd_d + l_d
              qd = prd + l
            ELSE
              qd = 0._sp
              qd_d = 0.0_4
            END IF
            qt_d = qr_d + qd_d
            qt = qr + qd
            temp = 0.001_sp*(mesh%dx*mesh%dx)
            q_d(row, col) = temp*qt_d/setup%dt
            q(row, col) = temp*(qt/setup%dt)
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (.NOT.setup%sparse_storage) output_d%qsim_domain(row, &
&               col, t) = q_d(row, col)
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%qsim(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%gauge_pos(g&
&         , 2))
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_G_FORWARD_D

!  Differentiation of gr_g_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.exc) *(output.qsim)
!                *(output.qsim_domain) *(states.hi) *(states.hp)
!                *(states.hft)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.cft) *(parameters.exc) *(states.hi)
!                *(states.hp) *(states.hft)
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.cft:in parameters.exc:in output.qsim:in
!                output.qsim_domain:in states.hi:in states.hp:in
!                states.hft:in
  SUBROUTINE GR_G_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, states, states_b, output, output_b)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    REAL(sp) :: ei_b, pn_b, en_b, pr_b, perc_b, l_b, prr_b, prd_b, qr_b&
&   , qd_b, qt_b
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              CALL PUSHREAL4(pet)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              CALL PUSHREAL4(pet)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL PUSHREAL4(pn)
              CALL PUSHREAL4(states%hi(row, col))
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              CALL PUSHREAL4(en)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%hp(row, col))
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            CALL PUSHREAL4(prr)
            prr = 0.9_sp*(pr+perc) + l
            prd = 0.1_sp*(pr+perc)
            CALL PUSHREAL4(states%hft(row, col))
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    q_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      END DO
      DO 100 i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              row = mesh%path(1, i)
              col = mesh%path(2, i)
              q_b(row, col) = q_b(row, col) + output_b%qsim_domain(row, &
&               col, t)
              output_b%qsim_domain(row, col, t) = 0.0_4
            ELSE
              row = mesh%path(1, i)
              col = mesh%path(2, i)
            END IF
          END IF
          qt_b = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qr_b = qt_b
          qd_b = qt_b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            prd_b = qd_b
            l_b = qd_b
          ELSE
            l_b = 0.0_4
            prd_b = 0.0_4
          END IF
          CALL POPREAL4(states%hft(row, col))
          CALL GR_TRANSFER_B(5._sp, prcp, prr, prr_b, parameters%cft(row&
&                      , col), parameters_b%cft(row, col), states%hft(&
&                      row, col), states_b%hft(row, col), qr, qr_b)
          pr_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          perc_b = 0.1_sp*prd_b + 0.9_sp*prr_b
          CALL POPREAL4(prr)
          l_b = l_b + prr_b
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL GR_EXCHANGE_B(parameters%exc(row, col), parameters_b%&
&                        exc(row, col), states%hft(row, col), states_b%&
&                        hft(row, col), l, l_b)
            CALL POPREAL4(states%hp(row, col))
            CALL GR_PRODUCTION_B(pn, pn_b, en, en_b, parameters%cp(row, &
&                          col), parameters_b%cp(row, col), 1000._sp, &
&                          states%hp(row, col), states_b%hp(row, col), &
&                          pr, pr_b, perc, perc_b)
            CALL POPREAL4(en)
            ei_b = -en_b
            CALL POPREAL4(states%hi(row, col))
            CALL POPREAL4(pn)
            CALL GR_INTERCEPTION_B(prcp, pet, parameters%ci(row, col), &
&                            parameters_b%ci(row, col), states%hi(row, &
&                            col), states_b%hi(row, col), pn, pn_b, ei, &
&                            ei_b)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 100  CONTINUE
    END DO
  END SUBROUTINE GR_G_FORWARD_B

  SUBROUTINE GR_G_FORWARD(setup, mesh, input_data, parameters, states, &
&   output)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp) :: prcp, pet, ei, pn, en, pr, perc, l, prr, prd, qr, qd, qt&
&   , qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC MAX
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        ei = 0._sp
        pn = 0._sp
        en = 0._sp
        pr = 0._sp
        perc = 0._sp
        l = 0._sp
        prr = 0._sp
        prd = 0._sp
        qr = 0._sp
        qd = 0._sp
        qup = 0._sp
        qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Interception module
!% =============================================================================================== %!
              CALL GR_INTERCEPTION(prcp, pet, parameters%ci(row, col), &
&                            states%hi(row, col), pn, ei)
              en = pet - ei
!% =============================================================================================== %!
!%   Production module
!% =============================================================================================== %!
              CALL GR_PRODUCTION(pn, en, parameters%cp(row, col), &
&                          1000._sp, states%hp(row, col), pr, perc)
!% =============================================================================================== %!
!%   Exchange module
!% =============================================================================================== %!
              CALL GR_EXCHANGE(parameters%exc(row, col), states%hft(row&
&                        , col), l)
            END IF
!% =================================================================================================== %!
!%   Transfer module
!% =================================================================================================== %!
            prr = 0.9_sp*(pr+perc) + l
            prd = 0.1_sp*(pr+perc)
            CALL GR_TRANSFER(5._sp, prcp, prr, parameters%cft(row, col)&
&                      , states%hft(row, col), qr)
            IF (0._sp .LT. prd + l) THEN
              qd = prd + l
            ELSE
              qd = 0._sp
            END IF
            qt = qr + qd
            q(row, col) = qt*mesh%dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
            IF (setup%save_net_prcp_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_net_prcp_domain(k, t) = qt
              ELSE
                output%net_prcp_domain(row, col, t) = qt
              END IF
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_qsim_domain(k, t) = q(row, col)
              ELSE
                output%qsim_domain(row, col, t) = q(row, col)
              END IF
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE GR_G_FORWARD

!  Differentiation of vic_a_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim) *(output.qsim_domain)
!                *(states.husl1) *(states.husl2) *(states.hlsl)
!                *(states.hlr)
!   with respect to varying inputs: *(parameters.b) *(parameters.cusl1)
!                *(parameters.cusl2) *(parameters.clsl) *(parameters.ks)
!                *(parameters.ds) *(parameters.dsm) *(parameters.ws)
!                *(parameters.lr) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: parameters.b:in parameters.cusl1:in
!                parameters.cusl2:in parameters.clsl:in parameters.ks:in
!                parameters.ds:in parameters.dsm:in parameters.ws:in
!                parameters.lr:in output.qsim:in output.qsim_domain:in
!                states.husl1:in states.husl2:in states.hlsl:in
!                states.hlr:in
  SUBROUTINE VIC_A_FORWARD_D(setup, mesh, input_data, parameters, &
&   parameters_d, states, states_d, output, output_d)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters_d
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_d
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_d
    REAL(sp) :: prcp, pet, runoff, qi, qb, qt, qup, qrout
    REAL(sp) :: runoff_d, qi_d, qb_d, qt_d, qup_d, qrout_d
    INTEGER :: t, i, row, col, k, g
    INTRINSIC REAL
    REAL(sp) :: temp
    REAL :: temp0
    output_d%qsim = 0.0_4
    output_d%qsim_domain = 0.0_4
    q_d = 0.0_4
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        runoff = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Infiltration module
!% =============================================================================================== %!
              CALL VIC_INFILTRATION_D(prcp, parameters%cusl1(row, col), &
&                               parameters_d%cusl1(row, col), parameters&
&                               %cusl2(row, col), parameters_d%cusl2(row&
&                               , col), parameters%b(row, col), &
&                               parameters_d%b(row, col), states%husl1(&
&                               row, col), states_d%husl1(row, col), &
&                               states%husl2(row, col), states_d%husl2(&
&                               row, col), runoff, runoff_d)
!% =============================================================================================== %!
!%   Vertical transfer module
!% =============================================================================================== %!
              CALL VIC_VERTICAL_TRANSFER_D(pet, parameters%cusl1(row, &
&                                    col), parameters_d%cusl1(row, col)&
&                                    , parameters%cusl2(row, col), &
&                                    parameters_d%cusl2(row, col), &
&                                    parameters%clsl(row, col), &
&                                    parameters_d%clsl(row, col), &
&                                    parameters%ks(row, col), &
&                                    parameters_d%ks(row, col), states%&
&                                    husl1(row, col), states_d%husl1(row&
&                                    , col), states%husl2(row, col), &
&                                    states_d%husl2(row, col), states%&
&                                    hlsl(row, col), states_d%hlsl(row, &
&                                    col))
            ELSE
              runoff_d = 0.0_4
            END IF
!% =================================================================================================== %!
!%   Horizontal transfer module
!% =================================================================================================== %!
            CALL VIC_INTERFLOW_D(5._sp, parameters%cusl2(row, col), &
&                          parameters_d%cusl2(row, col), states%husl2(&
&                          row, col), states_d%husl2(row, col), qi, qi_d&
&                         )
            CALL VIC_BASEFLOW_D(parameters%clsl(row, col), parameters_d%&
&                         clsl(row, col), parameters%ds(row, col), &
&                         parameters_d%ds(row, col), parameters%dsm(row&
&                         , col), parameters_d%dsm(row, col), parameters&
&                         %ws(row, col), parameters_d%ws(row, col), &
&                         states%hlsl(row, col), states_d%hlsl(row, col)&
&                         , qb, qb_d)
            qt_d = runoff_d + qi_d + qb_d
            qt = runoff + qi + qb
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE_D(setup%dt, mesh%dx, mesh%nrow, mesh&
&                               %ncol, mesh%flwdir, mesh%flwacc, row, &
&                               col, q, q_d, qup, qup_d)
            CALL LINEAR_ROUTING_D(setup%dt, qup, qup_d, parameters%lr(&
&                           row, col), parameters_d%lr(row, col), states&
&                           %hlr(row, col), states_d%hlr(row, col), &
&                           qrout, qrout_d)
            temp = 0.001_sp*(mesh%dx*mesh%dx)
            temp0 = REAL(mesh%flwacc(row, col) - 1)
            q_d(row, col) = temp*(qt_d+temp0*qrout_d)/setup%dt
            q(row, col) = temp*((qt+temp0*qrout)/setup%dt)
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (.NOT.setup%sparse_storage) output_d%qsim_domain(row, &
&               col, t) = q_d(row, col)
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output_d%qsim(g, t) = q_d(mesh%gauge_pos(g, 1), mesh%gauge_pos(g&
&         , 2))
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE VIC_A_FORWARD_D

!  Differentiation of vic_a_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(parameters.b) *(parameters.cusl1)
!                *(parameters.cusl2) *(parameters.clsl) *(parameters.ks)
!                *(parameters.ds) *(parameters.dsm) *(parameters.ws)
!                *(parameters.lr) *(output.qsim) *(output.qsim_domain)
!                *(states.husl1) *(states.husl2) *(states.hlsl)
!                *(states.hlr)
!   with respect to varying inputs: *(parameters.b) *(parameters.cusl1)
!                *(parameters.cusl2) *(parameters.clsl) *(parameters.ks)
!                *(parameters.ds) *(parameters.dsm) *(parameters.ws)
!                *(parameters.lr) *(states.husl1) *(states.husl2)
!                *(states.hlsl) *(states.hlr)
!   Plus diff mem management of: parameters.b:in parameters.cusl1:in
!                parameters.cusl2:in parameters.clsl:in parameters.ks:in
!                parameters.ds:in parameters.dsm:in parameters.ws:in
!                parameters.lr:in output.qsim:in output.qsim_domain:in
!                states.husl1:in states.husl2:in states.hlsl:in
!                states.hlr:in
  SUBROUTINE VIC_A_FORWARD_B(setup, mesh, input_data, parameters, &
&   parameters_b, states, states_b, output, output_b)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(PARAMETERSDT) :: parameters_b
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(STATESDT), INTENT(INOUT) :: states_b
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
    TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q_b
    REAL(sp) :: prcp, pet, runoff, qi, qb, qt, qup, qrout
    REAL(sp) :: runoff_b, qi_b, qb_b, qt_b, qup_b, qrout_b
    INTEGER :: t, i, row, col, k, g
    INTRINSIC REAL
    REAL*4 :: temp_b
    INTEGER :: branch
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        runoff = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          CALL PUSHINTEGER4(row)
          row = mesh%path(1, i)
          CALL PUSHINTEGER4(col)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              CALL PUSHREAL4(prcp)
              prcp = input_data%sparse_prcp(k, t)
              CALL PUSHREAL4(pet)
              pet = input_data%sparse_pet(k, t)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4(prcp)
              prcp = input_data%prcp(row, col, t)
              CALL PUSHREAL4(pet)
              pet = input_data%pet(row, col, t)
              CALL PUSHCONTROL1B(1)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Infiltration module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%husl2(row, col))
              CALL PUSHREAL4(states%husl1(row, col))
              CALL VIC_INFILTRATION(prcp, parameters%cusl1(row, col), &
&                             parameters%cusl2(row, col), parameters%b(&
&                             row, col), states%husl1(row, col), states%&
&                             husl2(row, col), runoff)
!% =============================================================================================== %!
!%   Vertical transfer module
!% =============================================================================================== %!
              CALL PUSHREAL4(states%hlsl(row, col))
              CALL PUSHREAL4(states%husl2(row, col))
              CALL PUSHREAL4(states%husl1(row, col))
              CALL VIC_VERTICAL_TRANSFER(pet, parameters%cusl1(row, col)&
&                                  , parameters%cusl2(row, col), &
&                                  parameters%clsl(row, col), parameters&
&                                  %ks(row, col), states%husl1(row, col)&
&                                  , states%husl2(row, col), states%hlsl&
&                                  (row, col))
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!% =================================================================================================== %!
!%   Horizontal transfer module
!% =================================================================================================== %!
            CALL PUSHREAL4(states%husl2(row, col))
            CALL VIC_INTERFLOW(5._sp, parameters%cusl2(row, col), states&
&                        %husl2(row, col), qi)
            CALL PUSHREAL4(states%hlsl(row, col))
            CALL VIC_BASEFLOW(parameters%clsl(row, col), parameters%ds(&
&                       row, col), parameters%dsm(row, col), parameters%&
&                       ws(row, col), states%hlsl(row, col), qb)
            qt = runoff + qi + qb
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL PUSHREAL4(qup)
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL PUSHREAL4(states%hlr(row, col))
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
    END DO
    q_b = 0.0_4
    DO t=setup%ntime_step,1,-1
      DO g=mesh%ng,1,-1
        q_b(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)) = q_b(mesh%&
&         gauge_pos(g, 1), mesh%gauge_pos(g, 2)) + output_b%qsim(g, t)
        output_b%qsim(g, t) = 0.0_4
      END DO
      DO 100 i=mesh%nrow*mesh%ncol,1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .NE. 2) THEN
            IF (branch .EQ. 3) THEN
              row = mesh%path(1, i)
              col = mesh%path(2, i)
              q_b(row, col) = q_b(row, col) + output_b%qsim_domain(row, &
&               col, t)
              output_b%qsim_domain(row, col, t) = 0.0_4
            ELSE
              row = mesh%path(1, i)
              col = mesh%path(2, i)
            END IF
          END IF
          temp_b = mesh%dx**2*0.001_sp*q_b(row, col)/setup%dt
          q_b(row, col) = 0.0_4
          qt_b = temp_b
          qrout_b = REAL(mesh%flwacc(row, col)-1)*temp_b
          CALL POPREAL4(states%hlr(row, col))
          CALL LINEAR_ROUTING_B(setup%dt, qup, qup_b, parameters%lr(row&
&                         , col), parameters_b%lr(row, col), states%hlr(&
&                         row, col), states_b%hlr(row, col), qrout, &
&                         qrout_b)
          CALL POPREAL4(qup)
          CALL UPSTREAM_DISCHARGE_B(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, q_b, qup, qup_b)
          runoff_b = qt_b
          qi_b = qt_b
          qb_b = qt_b
          CALL POPREAL4(states%hlsl(row, col))
          CALL VIC_BASEFLOW_B(parameters%clsl(row, col), parameters_b%&
&                       clsl(row, col), parameters%ds(row, col), &
&                       parameters_b%ds(row, col), parameters%dsm(row, &
&                       col), parameters_b%dsm(row, col), parameters%ws(&
&                       row, col), parameters_b%ws(row, col), states%&
&                       hlsl(row, col), states_b%hlsl(row, col), qb, &
&                       qb_b)
          CALL POPREAL4(states%husl2(row, col))
          CALL VIC_INTERFLOW_B(5._sp, parameters%cusl2(row, col), &
&                        parameters_b%cusl2(row, col), states%husl2(row&
&                        , col), states_b%husl2(row, col), qi, qi_b)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(states%husl1(row, col))
            CALL POPREAL4(states%husl2(row, col))
            CALL POPREAL4(states%hlsl(row, col))
            CALL VIC_VERTICAL_TRANSFER_B(pet, parameters%cusl1(row, col)&
&                                  , parameters_b%cusl1(row, col), &
&                                  parameters%cusl2(row, col), &
&                                  parameters_b%cusl2(row, col), &
&                                  parameters%clsl(row, col), &
&                                  parameters_b%clsl(row, col), &
&                                  parameters%ks(row, col), parameters_b&
&                                  %ks(row, col), states%husl1(row, col)&
&                                  , states_b%husl1(row, col), states%&
&                                  husl2(row, col), states_b%husl2(row, &
&                                  col), states%hlsl(row, col), states_b&
&                                  %hlsl(row, col))
            CALL POPREAL4(states%husl1(row, col))
            CALL POPREAL4(states%husl2(row, col))
            CALL VIC_INFILTRATION_B(prcp, parameters%cusl1(row, col), &
&                             parameters_b%cusl1(row, col), parameters%&
&                             cusl2(row, col), parameters_b%cusl2(row, &
&                             col), parameters%b(row, col), parameters_b&
&                             %b(row, col), states%husl1(row, col), &
&                             states_b%husl1(row, col), states%husl2(row&
&                             , col), states_b%husl2(row, col), runoff, &
&                             runoff_b)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          ELSE
            CALL POPREAL4(pet)
            CALL POPREAL4(prcp)
          END IF
        END IF
        CALL POPINTEGER4(col)
        CALL POPINTEGER4(row)
 100  CONTINUE
    END DO
  END SUBROUTINE VIC_A_FORWARD_B

  SUBROUTINE VIC_A_FORWARD(setup, mesh, input_data, parameters, states, &
&   output)
    IMPLICIT NONE
!% [ END DO TIME ]
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
    TYPE(SETUPDT), INTENT(IN) :: setup
    TYPE(MESHDT), INTENT(IN) :: mesh
    TYPE(INPUT_DATADT), INTENT(IN) :: input_data
    TYPE(PARAMETERSDT), INTENT(IN) :: parameters
    TYPE(STATESDT), INTENT(INOUT) :: states
    TYPE(OUTPUTDT), INTENT(INOUT) :: output
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
    REAL(sp), DIMENSION(mesh%nrow, mesh%ncol) :: q
    REAL(sp) :: prcp, pet, runoff, qi, qb, qt, qup, qrout
    INTEGER :: t, i, row, col, k, g
    INTRINSIC REAL
!% =================================================================================================================== %!
!%   Begin subroutine
!% =================================================================================================================== %!
!% [ DO TIME ]
    DO t=1,setup%ntime_step
!% [ DO SPACE ]
      DO i=1,mesh%nrow*mesh%ncol
!% =============================================================================================================== %!
!%   Local Variables Initialisation for time step (t) and cell (i)
!% =============================================================================================================== %!
        runoff = 0._sp
        qi = 0._sp
        qb = 0._sp
        qt = 0._sp
        qup = 0._sp
        qrout = 0._sp
!% [ END IF PATH ]
!% =========================================================================================================== %!
!%   Cell indice (i) to Cell indices (row, col) following an increasing order of flow accumulation
!% =========================================================================================================== %!
        IF (mesh%path(1, i) .GT. 0 .AND. mesh%path(2, i) .GT. 0) THEN
!% [ IF PATH ]
          row = mesh%path(1, i)
          col = mesh%path(2, i)
          IF (setup%sparse_storage) k = mesh%rowcol_to_ind_sparse(row, &
&             col)
!% [ END IF ACTIVE CELL ]
!% ======================================================================================================= %!
!%   Global/Local active cell
!% ======================================================================================================= %!
          IF (mesh%active_cell(row, col) .EQ. 1 .AND. mesh%&
&             local_active_cell(row, col) .EQ. 1) THEN
!% [ IF ACTIVE CELL ]
            IF (setup%sparse_storage) THEN
              prcp = input_data%sparse_prcp(k, t)
              pet = input_data%sparse_pet(k, t)
            ELSE
              prcp = input_data%prcp(row, col, t)
              pet = input_data%pet(row, col, t)
            END IF
!% [ END IF PRCP GAP ]
            IF (prcp .GE. 0 .AND. pet .GE. 0) THEN
!% [ IF PRCP GAP ]
!% =============================================================================================== %!
!%   Infiltration module
!% =============================================================================================== %!
              CALL VIC_INFILTRATION(prcp, parameters%cusl1(row, col), &
&                             parameters%cusl2(row, col), parameters%b(&
&                             row, col), states%husl1(row, col), states%&
&                             husl2(row, col), runoff)
!% =============================================================================================== %!
!%   Vertical transfer module
!% =============================================================================================== %!
              CALL VIC_VERTICAL_TRANSFER(pet, parameters%cusl1(row, col)&
&                                  , parameters%cusl2(row, col), &
&                                  parameters%clsl(row, col), parameters&
&                                  %ks(row, col), states%husl1(row, col)&
&                                  , states%husl2(row, col), states%hlsl&
&                                  (row, col))
            END IF
!% =================================================================================================== %!
!%   Horizontal transfer module
!% =================================================================================================== %!
            CALL VIC_INTERFLOW(5._sp, parameters%cusl2(row, col), states&
&                        %husl2(row, col), qi)
            CALL VIC_BASEFLOW(parameters%clsl(row, col), parameters%ds(&
&                       row, col), parameters%dsm(row, col), parameters%&
&                       ws(row, col), states%hlsl(row, col), qb)
            qt = runoff + qi + qb
!% =================================================================================================== %!
!%   Routing module
!% =================================================================================================== %!
            CALL UPSTREAM_DISCHARGE(setup%dt, mesh%dx, mesh%nrow, mesh%&
&                             ncol, mesh%flwdir, mesh%flwacc, row, col, &
&                             q, qup)
            CALL LINEAR_ROUTING(setup%dt, qup, parameters%lr(row, col), &
&                         states%hlr(row, col), qrout)
            q(row, col) = (qt+qrout*REAL(mesh%flwacc(row, col)-1))*mesh%&
&             dx*mesh%dx*0.001_sp/setup%dt
!% =================================================================================================== %!
!%   Store simulated net rainfall on domain (optional)
!%   The net rainfall over a surface is a fictitious quantity that corresponds to
!%   the part of the rainfall water depth that actually causes runoff.
!% =================================================================================================== %!
            IF (setup%save_net_prcp_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_net_prcp_domain(k, t) = qt
              ELSE
                output%net_prcp_domain(row, col, t) = qt
              END IF
            END IF
!% =================================================================================================== %!
!%   Store simulated discharge on domain (optional)
!% =================================================================================================== %!
            IF (setup%save_qsim_domain) THEN
              IF (setup%sparse_storage) THEN
                output%sparse_qsim_domain(k, t) = q(row, col)
              ELSE
                output%qsim_domain(row, col, t) = q(row, col)
              END IF
            END IF
          END IF
        END IF
      END DO
!% [ END DO SPACE ]
!% =============================================================================================================== %!
!%   Store simulated discharge at gauge
!% =============================================================================================================== %!
      DO g=1,mesh%ng
        output%qsim(g, t) = q(mesh%gauge_pos(g, 1), mesh%gauge_pos(g, 2)&
&         )
      END DO
    END DO
  END SUBROUTINE VIC_A_FORWARD

END MODULE MD_FORWARD_STRUCTURE_DIFF

!  Differentiation of base_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: *(output.qsim_domain)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hst) *(states.husl1)
!                *(states.husl2) *(states.hlsl) *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):in-killed
!                parameters.cp:(loc) *(parameters.cp):in-killed
!                parameters.beta:(loc) *(parameters.beta):in-killed
!                parameters.cft:(loc) *(parameters.cft):in-killed
!                parameters.cst:(loc) *(parameters.cst):in-killed
!                parameters.alpha:(loc) *(parameters.alpha):in-killed
!                parameters.exc:(loc) *(parameters.exc):in-killed
!                parameters.b:(loc) *(parameters.b):in-killed parameters.cusl1:(loc)
!                *(parameters.cusl1):in-killed parameters.cusl2:(loc)
!                *(parameters.cusl2):in-killed parameters.clsl:(loc)
!                *(parameters.clsl):in-killed parameters.ks:(loc)
!                *(parameters.ks):in-killed parameters.ds:(loc)
!                *(parameters.ds):in-killed parameters.dsm:(loc)
!                *(parameters.dsm):in-killed parameters.ws:(loc)
!                *(parameters.ws):in-killed parameters.lr:(loc)
!                *(parameters.lr):in-killed *(output.qsim):(loc)
!                output.qsim_domain:(loc) *(output.qsim_domain):out
!                states.hi:(loc) *(states.hi):in-killed states.hp:(loc)
!                *(states.hp):in-killed states.hft:(loc) *(states.hft):in-killed
!                states.hst:(loc) *(states.hst):in-killed states.husl1:(loc)
!                *(states.husl1):in-killed states.husl2:(loc) *(states.husl2):in-killed
!                states.hlsl:(loc) *(states.hlsl):in-killed states.hlr:(loc)
!                *(states.hlr):in-killed
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in output.qsim:in output.qsim_domain:in
!                states.hi:in-out states.hp:in-out states.hft:in-out
!                states.hst:in-out states.husl1:in-out states.husl2:in-out
!                states.hlsl:in-out states.hlr:in-out parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
SUBROUTINE BASE_FORWARD_D0(setup, mesh, input_data, parameters, &
& parameters_d, parameters_bgd, parameters_bgd_d, states, states_d, &
& states_bgd, states_bgd_d, output, output_d, cost)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, gr_g_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: denormalize_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: denormalize_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd_d
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(STATESDT), INTENT(IN) :: states_bgd
  TYPE(STATESDT), INTENT(IN) :: states_bgd_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp) :: cost_d
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_d
  INTRINSIC TRIM
  IF (setup%optimize%denormalize_forward) THEN
    CALL DENORMALIZE_PARAMETERS_D(setup, mesh, parameters, parameters_d)
    CALL DENORMALIZE_STATES_D(setup, mesh, states, states_d)
  END IF
  states_imd_d = states_d
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL GR_A_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-b') 
    CALL GR_B_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-c') 
    CALL GR_C_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-d') 
    CALL GR_D_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-g') 
    CALL GR_G_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('vic-a') 
    CALL VIC_A_FORWARD_D(setup, mesh, input_data, parameters, &
&                  parameters_d, states, states_d, output, output_d)
  CASE DEFAULT
    output_d%qsim_domain = 0.0_4
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
  states_d = states_imd_d
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, parameters_bgd&
&             , states, states_bgd, output, cost)
END SUBROUTINE BASE_FORWARD_D0

!  Differentiation of base_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hst) *(states.husl1)
!                *(states.husl2) *(states.hlsl) *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):in-killed
!                parameters.cp:(loc) *(parameters.cp):in-killed
!                parameters.beta:(loc) *(parameters.beta):in-killed
!                parameters.cft:(loc) *(parameters.cft):in-killed
!                parameters.cst:(loc) *(parameters.cst):in-killed
!                parameters.alpha:(loc) *(parameters.alpha):in-killed
!                parameters.exc:(loc) *(parameters.exc):in-killed
!                parameters.b:(loc) *(parameters.b):in-killed parameters.cusl1:(loc)
!                *(parameters.cusl1):in-killed parameters.cusl2:(loc)
!                *(parameters.cusl2):in-killed parameters.clsl:(loc)
!                *(parameters.clsl):in-killed parameters.ks:(loc)
!                *(parameters.ks):in-killed parameters.ds:(loc)
!                *(parameters.ds):in-killed parameters.dsm:(loc)
!                *(parameters.dsm):in-killed parameters.ws:(loc)
!                *(parameters.ws):in-killed parameters.lr:(loc)
!                *(parameters.lr):in-killed *(output.qsim):(loc)
!                *(output.qsim_domain):(loc) states.hi:(loc) *(states.hi):in-killed
!                states.hp:(loc) *(states.hp):in-killed states.hft:(loc)
!                *(states.hft):in-killed states.hst:(loc) *(states.hst):in-killed
!                states.husl1:(loc) *(states.husl1):in-killed states.husl2:(loc)
!                *(states.husl2):in-killed states.hlsl:(loc) *(states.hlsl):in-killed
!                states.hlr:(loc) *(states.hlr):in-killed cost:out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in output.qsim:in output.qsim_domain:in
!                states.hi:in-out states.hp:in-out states.hft:in-out
!                states.hst:in-out states.husl1:in-out states.husl2:in-out
!                states.hlsl:in-out states.hlr:in-out parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
SUBROUTINE BASE_FORWARD_D(setup, mesh, input_data, parameters, &
& parameters_d, parameters_bgd, parameters_bgd_d, states, states_d, &
& states_bgd, states_bgd_d, output, output_d, cost, cost_d)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, gr_g_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: denormalize_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: denormalize_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd_d
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(STATESDT), INTENT(IN) :: states_bgd
  TYPE(STATESDT), INTENT(IN) :: states_bgd_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_d
  INTRINSIC TRIM
  IF (setup%optimize%denormalize_forward) THEN
    CALL DENORMALIZE_PARAMETERS_D(setup, mesh, parameters, parameters_d)
    CALL DENORMALIZE_STATES_D(setup, mesh, states, states_d)
  END IF
  states_imd_d = states_d
  states_imd = states
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL GR_A_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-b') 
    CALL GR_B_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-c') 
    CALL GR_C_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-d') 
    CALL GR_D_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-g') 
    CALL GR_G_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('vic-a') 
    CALL VIC_A_FORWARD_D(setup, mesh, input_data, parameters, &
&                  parameters_d, states, states_d, output, output_d)
  CASE DEFAULT
    output_d%qsim = 0.0_4
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
  states_d = states_imd_d
  states = states_imd
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST_D(setup, mesh, input_data, parameters, parameters_d&
&               , parameters_bgd, parameters_bgd_d, states, states_d, &
&               states_bgd, states_bgd_d, output, output_d, cost, cost_d&
&              )
END SUBROUTINE BASE_FORWARD_D

!  Differentiation of base_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: *(output.qsim_domain)
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hst) *(states.husl1)
!                *(states.husl2) *(states.hlsl) *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):out
!                parameters.cp:(loc) *(parameters.cp):out parameters.beta:(loc)
!                *(parameters.beta):out parameters.cft:(loc) *(parameters.cft):out
!                parameters.cst:(loc) *(parameters.cst):out parameters.alpha:(loc)
!                *(parameters.alpha):out parameters.exc:(loc) *(parameters.exc):out
!                parameters.b:(loc) *(parameters.b):out parameters.cusl1:(loc)
!                *(parameters.cusl1):out parameters.cusl2:(loc)
!                *(parameters.cusl2):out parameters.clsl:(loc)
!                *(parameters.clsl):out parameters.ks:(loc) *(parameters.ks):out
!                parameters.ds:(loc) *(parameters.ds):out parameters.dsm:(loc)
!                *(parameters.dsm):out parameters.ws:(loc) *(parameters.ws):out
!                parameters.lr:(loc) *(parameters.lr):out *(output.qsim):(loc)
!                output.qsim_domain:(loc) *(output.qsim_domain):in-killed
!                states.hi:(loc) *(states.hi):out states.hp:(loc)
!                *(states.hp):out states.hft:(loc) *(states.hft):out
!                states.hst:(loc) *(states.hst):out states.husl1:(loc)
!                *(states.husl1):out states.husl2:(loc) *(states.husl2):out
!                states.hlsl:(loc) *(states.hlsl):out states.hlr:(loc)
!                *(states.hlr):out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in output.qsim:in output.qsim_domain:in
!                states.hi:in-out states.hp:in-out states.hft:in-out
!                states.hst:in-out states.husl1:in-out states.husl2:in-out
!                states.hlsl:in-out states.hlr:in-out parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
SUBROUTINE BASE_FORWARD_B0(setup, mesh, input_data, parameters, &
& parameters_b, parameters_bgd, parameters_bgd_b, states, states_b, &
& states_bgd, states_bgd_b, output, output_b, cost)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, gr_g_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: denormalize_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: denormalize_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
  TYPE(PARAMETERSDT) :: parameters_bgd_b
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_b
  TYPE(STATESDT), INTENT(IN) :: states_bgd
  TYPE(STATESDT) :: states_bgd_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp) :: cost_b
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_b
  INTRINSIC TRIM
  INTEGER :: branch
  IF (setup%optimize%denormalize_forward) THEN
    CALL DENORMALIZE_PARAMETERS(setup, mesh, parameters)
    CALL DENORMALIZE_STATES(setup, mesh, states)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  states_imd_b = states_b
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_A_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(1)
  CASE ('gr-b') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_B_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(2)
  CASE ('gr-c') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_C_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(3)
  CASE ('gr-d') 
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_D_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(4)
  CASE ('gr-g') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL GR_G_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(5)
  CASE ('vic-a') 
    CALL PUSHREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                 husl1, 2))
    CALL PUSHREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                 husl2, 2))
    CALL PUSHREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                 hlsl, 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL VIC_A_FORWARD(setup, mesh, input_data, parameters, states, &
&                output)
    CALL PUSHCONTROL3B(6)
  CASE DEFAULT
    CALL PUSHCONTROL3B(0)
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
  states_b = states_imd_b
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL POPCONTROL3B(branch)
  IF (branch .LT. 3) THEN
    IF (branch .EQ. 0) THEN
      parameters_b%ci = 0.0_4
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hi = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
      states_b%hlr = 0.0_4
    ELSE IF (branch .EQ. 1) THEN
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hlr = 0.0_4
      output_b%qsim = 0.0_4
      CALL GR_A_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
      parameters_b%ci = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      states_b%hi = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
    ELSE
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2&
&                  ))
      parameters_b%ci = 0.0_4
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hi = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hlr = 0.0_4
      output_b%qsim = 0.0_4
      CALL GR_B_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
      parameters_b%cst = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
    END IF
  ELSE IF (branch .LT. 5) THEN
    IF (branch .EQ. 3) THEN
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2&
&                  ))
      parameters_b%ci = 0.0_4
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hi = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hst = 0.0_4
      states_b%hlr = 0.0_4
      output_b%qsim = 0.0_4
      CALL GR_C_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
    ELSE
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hlr = 0.0_4
      output_b%qsim = 0.0_4
      CALL GR_D_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
      parameters_b%ci = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      states_b%hi = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
    END IF
  ELSE IF (branch .EQ. 5) THEN
    CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, &
&                2))
    CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
    CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2))
    parameters_b%ci = 0.0_4
    parameters_b%cp = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%exc = 0.0_4
    states_b%hi = 0.0_4
    states_b%hp = 0.0_4
    states_b%hft = 0.0_4
    output_b%qsim = 0.0_4
    CALL GR_G_FORWARD_B(setup, mesh, input_data, parameters, &
&                 parameters_b, states, states_b, output, output_b)
    parameters_b%cst = 0.0_4
    parameters_b%b = 0.0_4
    parameters_b%cusl1 = 0.0_4
    parameters_b%cusl2 = 0.0_4
    parameters_b%clsl = 0.0_4
    parameters_b%ks = 0.0_4
    parameters_b%ds = 0.0_4
    parameters_b%dsm = 0.0_4
    parameters_b%ws = 0.0_4
    parameters_b%lr = 0.0_4
    states_b%hst = 0.0_4
    states_b%husl1 = 0.0_4
    states_b%husl2 = 0.0_4
    states_b%hlsl = 0.0_4
    states_b%hlr = 0.0_4
  ELSE
    CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, &
&                2))
    CALL POPREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                hlsl, 2))
    CALL POPREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                husl2, 2))
    CALL POPREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                husl1, 2))
    parameters_b%b = 0.0_4
    parameters_b%cusl1 = 0.0_4
    parameters_b%cusl2 = 0.0_4
    parameters_b%clsl = 0.0_4
    parameters_b%ks = 0.0_4
    parameters_b%ds = 0.0_4
    parameters_b%dsm = 0.0_4
    parameters_b%ws = 0.0_4
    parameters_b%lr = 0.0_4
    states_b%husl1 = 0.0_4
    states_b%husl2 = 0.0_4
    states_b%hlsl = 0.0_4
    states_b%hlr = 0.0_4
    output_b%qsim = 0.0_4
    CALL VIC_A_FORWARD_B(setup, mesh, input_data, parameters, &
&                  parameters_b, states, states_b, output, output_b)
    parameters_b%ci = 0.0_4
    parameters_b%cp = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%cst = 0.0_4
    parameters_b%exc = 0.0_4
    states_b%hi = 0.0_4
    states_b%hp = 0.0_4
    states_b%hft = 0.0_4
    states_b%hst = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL DENORMALIZE_STATES_B(setup, mesh, states, states_b)
    parameters_b%beta = 0.0_4
    parameters_b%alpha = 0.0_4
    CALL DENORMALIZE_PARAMETERS_B(setup, mesh, parameters, parameters_b)
  ELSE
    parameters_b%beta = 0.0_4
    parameters_b%alpha = 0.0_4
  END IF
END SUBROUTINE BASE_FORWARD_B0

!  Differentiation of base_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(parameters.ci) *(parameters.cp)
!                *(parameters.beta) *(parameters.cft) *(parameters.cst)
!                *(parameters.alpha) *(parameters.exc) *(parameters.b)
!                *(parameters.cusl1) *(parameters.cusl2) *(parameters.clsl)
!                *(parameters.ks) *(parameters.ds) *(parameters.dsm)
!                *(parameters.ws) *(parameters.lr) *(states.hi)
!                *(states.hp) *(states.hft) *(states.hst) *(states.husl1)
!                *(states.husl2) *(states.hlsl) *(states.hlr)
!   RW status of diff variables: parameters.ci:(loc) *(parameters.ci):out
!                parameters.cp:(loc) *(parameters.cp):out parameters.beta:(loc)
!                *(parameters.beta):out parameters.cft:(loc) *(parameters.cft):out
!                parameters.cst:(loc) *(parameters.cst):out parameters.alpha:(loc)
!                *(parameters.alpha):out parameters.exc:(loc) *(parameters.exc):out
!                parameters.b:(loc) *(parameters.b):out parameters.cusl1:(loc)
!                *(parameters.cusl1):out parameters.cusl2:(loc)
!                *(parameters.cusl2):out parameters.clsl:(loc)
!                *(parameters.clsl):out parameters.ks:(loc) *(parameters.ks):out
!                parameters.ds:(loc) *(parameters.ds):out parameters.dsm:(loc)
!                *(parameters.dsm):out parameters.ws:(loc) *(parameters.ws):out
!                parameters.lr:(loc) *(parameters.lr):out *(output.qsim):(loc)
!                *(output.qsim_domain):(loc) states.hi:(loc) *(states.hi):out
!                states.hp:(loc) *(states.hp):out states.hft:(loc)
!                *(states.hft):out states.hst:(loc) *(states.hst):out
!                states.husl1:(loc) *(states.husl1):out states.husl2:(loc)
!                *(states.husl2):out states.hlsl:(loc) *(states.hlsl):out
!                states.hlr:(loc) *(states.hlr):out cost:in-killed
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in states_bgd.hi:in
!                states_bgd.hp:in states_bgd.hft:in states_bgd.hst:in
!                states_bgd.husl1:in states_bgd.husl2:in states_bgd.hlsl:in
!                states_bgd.hlr:in output.qsim:in output.qsim_domain:in
!                states.hi:in-out states.hp:in-out states.hft:in-out
!                states.hst:in-out states.husl1:in-out states.husl2:in-out
!                states.hlsl:in-out states.hlr:in-out parameters_bgd.ci:in
!                parameters_bgd.cp:in parameters_bgd.beta:in parameters_bgd.cft:in
!                parameters_bgd.cst:in parameters_bgd.alpha:in
!                parameters_bgd.exc:in parameters_bgd.b:in parameters_bgd.cusl1:in
!                parameters_bgd.cusl2:in parameters_bgd.clsl:in
!                parameters_bgd.ks:in parameters_bgd.ds:in parameters_bgd.dsm:in
!                parameters_bgd.ws:in parameters_bgd.lr:in
SUBROUTINE BASE_FORWARD_B(setup, mesh, input_data, parameters, &
& parameters_b, parameters_bgd, parameters_bgd_b, states, states_b, &
& states_bgd, states_bgd_b, output, output_b, cost, cost_b)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, gr_g_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: denormalize_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: denormalize_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
  TYPE(PARAMETERSDT) :: parameters_bgd_b
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_b
  TYPE(STATESDT), INTENT(IN) :: states_bgd
  TYPE(STATESDT) :: states_bgd_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_b
  TYPE(STATESDT) :: states_imd
  TYPE(STATESDT) :: states_imd_b
  INTRINSIC TRIM
  INTEGER :: branch
  IF (setup%optimize%denormalize_forward) THEN
    CALL DENORMALIZE_PARAMETERS(setup, mesh, parameters)
    CALL DENORMALIZE_STATES(setup, mesh, states)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  states_imd_b = states_b
  states_imd = states
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_A_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(1)
  CASE ('gr-b') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_B_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(2)
  CASE ('gr-c') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_C_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(3)
  CASE ('gr-d') 
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_D_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(4)
  CASE ('gr-g') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL GR_G_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(5)
  CASE ('vic-a') 
    CALL PUSHREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                 husl1, 2))
    CALL PUSHREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                 husl2, 2))
    CALL PUSHREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                 hlsl, 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL VIC_A_FORWARD(setup, mesh, input_data, parameters, states, &
&                output)
    CALL PUSHCONTROL3B(6)
  CASE DEFAULT
    CALL PUSHCONTROL3B(0)
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
  states_b = states_imd_b
  states = states_imd
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2))
  CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
  CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, 2&
&               ))
  CALL PUSHREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst, 2&
&               ))
  CALL PUSHREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&               husl1, 2))
  CALL PUSHREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&               husl2, 2))
  CALL PUSHREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%hlsl&
&               , 2))
  CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, 2&
&               ))
  CALL PUSHREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&               parameters%ci, 2))
  CALL PUSHREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&               parameters%cp, 2))
  CALL PUSHREAL4ARRAY(parameters%beta, SIZE(parameters%beta, 1)*SIZE(&
&               parameters%beta, 2))
  CALL PUSHREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&               parameters%cft, 2))
  CALL PUSHREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&               parameters%cst, 2))
  CALL PUSHREAL4ARRAY(parameters%alpha, SIZE(parameters%alpha, 1)*SIZE(&
&               parameters%alpha, 2))
  CALL PUSHREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&               parameters%exc, 2))
  CALL PUSHREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(&
&               parameters%b, 2))
  CALL PUSHREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*SIZE(&
&               parameters%cusl1, 2))
  CALL PUSHREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*SIZE(&
&               parameters%cusl2, 2))
  CALL PUSHREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&               parameters%clsl, 2))
  CALL PUSHREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&               parameters%ks, 2))
  CALL PUSHREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&               parameters%ds, 2))
  CALL PUSHREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&               parameters%dsm, 2))
  CALL PUSHREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&               parameters%ws, 2))
  CALL PUSHREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&               parameters%lr, 2))
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, parameters_bgd&
&             , states, states_bgd, output, cost)
  CALL POPREAL4ARRAY(parameters%lr, SIZE(parameters%lr, 1)*SIZE(&
&              parameters%lr, 2))
  CALL POPREAL4ARRAY(parameters%ws, SIZE(parameters%ws, 1)*SIZE(&
&              parameters%ws, 2))
  CALL POPREAL4ARRAY(parameters%dsm, SIZE(parameters%dsm, 1)*SIZE(&
&              parameters%dsm, 2))
  CALL POPREAL4ARRAY(parameters%ds, SIZE(parameters%ds, 1)*SIZE(&
&              parameters%ds, 2))
  CALL POPREAL4ARRAY(parameters%ks, SIZE(parameters%ks, 1)*SIZE(&
&              parameters%ks, 2))
  CALL POPREAL4ARRAY(parameters%clsl, SIZE(parameters%clsl, 1)*SIZE(&
&              parameters%clsl, 2))
  CALL POPREAL4ARRAY(parameters%cusl2, SIZE(parameters%cusl2, 1)*SIZE(&
&              parameters%cusl2, 2))
  CALL POPREAL4ARRAY(parameters%cusl1, SIZE(parameters%cusl1, 1)*SIZE(&
&              parameters%cusl1, 2))
  CALL POPREAL4ARRAY(parameters%b, SIZE(parameters%b, 1)*SIZE(parameters&
&              %b, 2))
  CALL POPREAL4ARRAY(parameters%exc, SIZE(parameters%exc, 1)*SIZE(&
&              parameters%exc, 2))
  CALL POPREAL4ARRAY(parameters%alpha, SIZE(parameters%alpha, 1)*SIZE(&
&              parameters%alpha, 2))
  CALL POPREAL4ARRAY(parameters%cst, SIZE(parameters%cst, 1)*SIZE(&
&              parameters%cst, 2))
  CALL POPREAL4ARRAY(parameters%cft, SIZE(parameters%cft, 1)*SIZE(&
&              parameters%cft, 2))
  CALL POPREAL4ARRAY(parameters%beta, SIZE(parameters%beta, 1)*SIZE(&
&              parameters%beta, 2))
  CALL POPREAL4ARRAY(parameters%cp, SIZE(parameters%cp, 1)*SIZE(&
&              parameters%cp, 2))
  CALL POPREAL4ARRAY(parameters%ci, SIZE(parameters%ci, 1)*SIZE(&
&              parameters%ci, 2))
  CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, 2)&
&             )
  CALL POPREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%hlsl&
&              , 2))
  CALL POPREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&              husl2, 2))
  CALL POPREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&              husl1, 2))
  CALL POPREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst, 2)&
&             )
  CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, 2)&
&             )
  CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
  CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2))
  CALL SET_PARAMETERS(mesh, parameters_b, 0.0_4)
  CALL SET_STATES(mesh, states_b, 0.0_4)
  CALL COMPUTE_COST_B(setup, mesh, input_data, parameters, parameters_b&
&               , parameters_bgd, parameters_bgd_b, states, states_b, &
&               states_bgd, states_bgd_b, output, output_b, cost, cost_b&
&              )
  CALL POPCONTROL3B(branch)
  IF (branch .LT. 3) THEN
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%&
&                    hlr, 2))
        CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%&
&                    hft, 2))
        CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp&
&                    , 2))
        output_b%qsim_domain = 0.0_4
        CALL GR_A_FORWARD_B(setup, mesh, input_data, parameters, &
&                     parameters_b, states, states_b, output, output_b)
      ELSE
        CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%&
&                    hlr, 2))
        CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%&
&                    hft, 2))
        CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp&
&                    , 2))
        CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi&
&                    , 2))
        output_b%qsim_domain = 0.0_4
        CALL GR_B_FORWARD_B(setup, mesh, input_data, parameters, &
&                     parameters_b, states, states_b, output, output_b)
      END IF
    END IF
  ELSE IF (branch .LT. 5) THEN
    IF (branch .EQ. 3) THEN
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2&
&                  ))
      output_b%qsim_domain = 0.0_4
      CALL GR_C_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
    ELSE
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      output_b%qsim_domain = 0.0_4
      CALL GR_D_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
    END IF
  ELSE IF (branch .EQ. 5) THEN
    CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, &
&                2))
    CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
    CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2))
    output_b%qsim_domain = 0.0_4
    CALL GR_G_FORWARD_B(setup, mesh, input_data, parameters, &
&                 parameters_b, states, states_b, output, output_b)
  ELSE
    CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, &
&                2))
    CALL POPREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                hlsl, 2))
    CALL POPREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                husl2, 2))
    CALL POPREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                husl1, 2))
    output_b%qsim_domain = 0.0_4
    CALL VIC_A_FORWARD_B(setup, mesh, input_data, parameters, &
&                  parameters_b, states, states_b, output, output_b)
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL DENORMALIZE_STATES_B(setup, mesh, states, states_b)
    CALL DENORMALIZE_PARAMETERS_B(setup, mesh, parameters, parameters_b)
  END IF
END SUBROUTINE BASE_FORWARD_B

SUBROUTINE BASE_FORWARD_NODIFF(setup, mesh, input_data, parameters, &
& parameters_bgd, states, states_bgd, output, cost)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, gr_g_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: denormalize_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: denormalize_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(IN) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(IN) :: parameters_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(IN) :: states_bgd
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
  TYPE(STATESDT) :: states_imd
  INTRINSIC TRIM
  IF (setup%optimize%denormalize_forward) THEN
    CALL DENORMALIZE_PARAMETERS(setup, mesh, parameters)
    CALL DENORMALIZE_STATES(setup, mesh, states)
  END IF
  cost = 0._sp
  states_imd = states
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL GR_A_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-b') 
    CALL GR_B_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-c') 
    CALL GR_C_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-d') 
    CALL GR_D_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-g') 
    CALL GR_G_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('vic-a') 
    CALL VIC_A_FORWARD(setup, mesh, input_data, parameters, states, &
&                output)
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
  output%fstates = states
  states = states_imd
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL COMPUTE_COST(setup, mesh, input_data, parameters, parameters_bgd&
&             , states, states_bgd, output, cost)
END SUBROUTINE BASE_FORWARD_NODIFF

!  Differentiation of base_hyper_forward in forward (tangent) mode (with options fixinterface noISIZE):
!   variations   of useful results: cost
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.husl1)
!                *(hyper_states.husl2) *(hyper_states.hlsl) *(hyper_states.hlr)
!                *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.b)
!                *(hyper_parameters.cusl1) *(hyper_parameters.cusl2)
!                *(hyper_parameters.clsl) *(hyper_parameters.ks)
!                *(hyper_parameters.ds) *(hyper_parameters.dsm)
!                *(hyper_parameters.ws) *(hyper_parameters.lr)
!   RW status of diff variables: *(parameters.ci):(loc) *(parameters.cp):(loc)
!                *(parameters.beta):(loc) *(parameters.cft):(loc)
!                *(parameters.cst):(loc) *(parameters.alpha):(loc)
!                *(parameters.exc):(loc) *(parameters.b):(loc)
!                *(parameters.cusl1):(loc) *(parameters.cusl2):(loc)
!                *(parameters.clsl):(loc) *(parameters.ks):(loc)
!                *(parameters.ds):(loc) *(parameters.dsm):(loc)
!                *(parameters.ws):(loc) *(parameters.lr):(loc)
!                hyper_states.hi:(loc) *(hyper_states.hi):in hyper_states.hp:(loc)
!                *(hyper_states.hp):in hyper_states.hft:(loc) *(hyper_states.hft):in
!                hyper_states.hst:(loc) *(hyper_states.hst):in
!                hyper_states.husl1:(loc) *(hyper_states.husl1):in
!                hyper_states.husl2:(loc) *(hyper_states.husl2):in
!                hyper_states.hlsl:(loc) *(hyper_states.hlsl):in
!                hyper_states.hlr:(loc) *(hyper_states.hlr):in
!                hyper_parameters.ci:(loc) *(hyper_parameters.ci):in
!                hyper_parameters.cp:(loc) *(hyper_parameters.cp):in
!                hyper_parameters.beta:(loc) *(hyper_parameters.beta):in
!                hyper_parameters.cft:(loc) *(hyper_parameters.cft):in
!                hyper_parameters.cst:(loc) *(hyper_parameters.cst):in
!                hyper_parameters.alpha:(loc) *(hyper_parameters.alpha):in
!                hyper_parameters.exc:(loc) *(hyper_parameters.exc):in
!                hyper_parameters.b:(loc) *(hyper_parameters.b):in
!                hyper_parameters.cusl1:(loc) *(hyper_parameters.cusl1):in
!                hyper_parameters.cusl2:(loc) *(hyper_parameters.cusl2):in
!                hyper_parameters.clsl:(loc) *(hyper_parameters.clsl):in
!                hyper_parameters.ks:(loc) *(hyper_parameters.ks):in
!                hyper_parameters.ds:(loc) *(hyper_parameters.ds):in
!                hyper_parameters.dsm:(loc) *(hyper_parameters.dsm):in
!                hyper_parameters.ws:(loc) *(hyper_parameters.ws):in
!                hyper_parameters.lr:(loc) *(hyper_parameters.lr):in
!                *(output.qsim):(loc) *(output.qsim_domain):(loc)
!                *(states.hi):(loc) *(states.hp):(loc) *(states.hft):(loc)
!                *(states.hst):(loc) *(states.husl1):(loc) *(states.husl2):(loc)
!                *(states.hlsl):(loc) *(states.hlr):(loc) cost:out
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in hyper_states.hi:in
!                hyper_states.hp:in hyper_states.hft:in hyper_states.hst:in
!                hyper_states.husl1:in hyper_states.husl2:in hyper_states.hlsl:in
!                hyper_states.hlr:in hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.b:in
!                hyper_parameters.cusl1:in hyper_parameters.cusl2:in
!                hyper_parameters.clsl:in hyper_parameters.ks:in
!                hyper_parameters.ds:in hyper_parameters.dsm:in
!                hyper_parameters.ws:in hyper_parameters.lr:in
!                output.qsim:in output.qsim_domain:in states.hi:in
!                states.hp:in states.hft:in states.hst:in states.husl1:in
!                states.husl2:in states.hlsl:in states.hlr:in
SUBROUTINE BASE_HYPER_FORWARD_D(setup, mesh, input_data, parameters, &
& parameters_d, hyper_parameters, hyper_parameters_d, &
& hyper_parameters_bgd, states, states_d, hyper_states, hyper_states_d, &
& hyper_states_bgd, output, output_d, cost, cost_d)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_hyper_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: hyper_parameters_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: hyper_states_to_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_d
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
& hyper_parameters_bgd
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters_d
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_d
  TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
  TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states_d
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_d
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_d
  INTRINSIC TRIM
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  CALL HYPER_PARAMETERS_TO_PARAMETERS_D(hyper_parameters, &
&                                 hyper_parameters_d, parameters, &
&                                 parameters_d, setup, mesh, input_data)
  CALL HYPER_STATES_TO_STATES_D(hyper_states, hyper_states_d, states, &
&                         states_d, setup, mesh, input_data)
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL GR_A_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-b') 
    CALL GR_B_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-c') 
    CALL GR_C_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('gr-d') 
    CALL GR_D_FORWARD_D(setup, mesh, input_data, parameters, &
&                 parameters_d, states, states_d, output, output_d)
  CASE ('vic-a') 
    CALL VIC_A_FORWARD_D(setup, mesh, input_data, parameters, &
&                  parameters_d, states, states_d, output, output_d)
  CASE DEFAULT
    output_d%qsim = 0.0_4
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL HYPER_COMPUTE_COST_D(setup, mesh, input_data, hyper_parameters, &
&                     hyper_parameters_bgd, hyper_states, &
&                     hyper_states_bgd, output, output_d, cost, cost_d)
END SUBROUTINE BASE_HYPER_FORWARD_D

!  Differentiation of base_hyper_forward in reverse (adjoint) mode (with options fixinterface noISIZE):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(hyper_states.hi) *(hyper_states.hp)
!                *(hyper_states.hft) *(hyper_states.hst) *(hyper_states.husl1)
!                *(hyper_states.husl2) *(hyper_states.hlsl) *(hyper_states.hlr)
!                *(hyper_parameters.ci) *(hyper_parameters.cp)
!                *(hyper_parameters.beta) *(hyper_parameters.cft)
!                *(hyper_parameters.cst) *(hyper_parameters.alpha)
!                *(hyper_parameters.exc) *(hyper_parameters.b)
!                *(hyper_parameters.cusl1) *(hyper_parameters.cusl2)
!                *(hyper_parameters.clsl) *(hyper_parameters.ks)
!                *(hyper_parameters.ds) *(hyper_parameters.dsm)
!                *(hyper_parameters.ws) *(hyper_parameters.lr)
!   RW status of diff variables: *(parameters.ci):(loc) *(parameters.cp):(loc)
!                *(parameters.beta):(loc) *(parameters.cft):(loc)
!                *(parameters.cst):(loc) *(parameters.alpha):(loc)
!                *(parameters.exc):(loc) *(parameters.b):(loc)
!                *(parameters.cusl1):(loc) *(parameters.cusl2):(loc)
!                *(parameters.clsl):(loc) *(parameters.ks):(loc)
!                *(parameters.ds):(loc) *(parameters.dsm):(loc)
!                *(parameters.ws):(loc) *(parameters.lr):(loc)
!                hyper_states.hi:(loc) *(hyper_states.hi):out hyper_states.hp:(loc)
!                *(hyper_states.hp):out hyper_states.hft:(loc)
!                *(hyper_states.hft):out hyper_states.hst:(loc)
!                *(hyper_states.hst):out hyper_states.husl1:(loc)
!                *(hyper_states.husl1):out hyper_states.husl2:(loc)
!                *(hyper_states.husl2):out hyper_states.hlsl:(loc)
!                *(hyper_states.hlsl):out hyper_states.hlr:(loc)
!                *(hyper_states.hlr):out hyper_parameters.ci:(loc)
!                *(hyper_parameters.ci):out hyper_parameters.cp:(loc)
!                *(hyper_parameters.cp):out hyper_parameters.beta:(loc)
!                *(hyper_parameters.beta):out hyper_parameters.cft:(loc)
!                *(hyper_parameters.cft):out hyper_parameters.cst:(loc)
!                *(hyper_parameters.cst):out hyper_parameters.alpha:(loc)
!                *(hyper_parameters.alpha):out hyper_parameters.exc:(loc)
!                *(hyper_parameters.exc):out hyper_parameters.b:(loc)
!                *(hyper_parameters.b):out hyper_parameters.cusl1:(loc)
!                *(hyper_parameters.cusl1):out hyper_parameters.cusl2:(loc)
!                *(hyper_parameters.cusl2):out hyper_parameters.clsl:(loc)
!                *(hyper_parameters.clsl):out hyper_parameters.ks:(loc)
!                *(hyper_parameters.ks):out hyper_parameters.ds:(loc)
!                *(hyper_parameters.ds):out hyper_parameters.dsm:(loc)
!                *(hyper_parameters.dsm):out hyper_parameters.ws:(loc)
!                *(hyper_parameters.ws):out hyper_parameters.lr:(loc)
!                *(hyper_parameters.lr):out *(output.qsim):(loc)
!                *(output.qsim_domain):(loc) *(states.hi):(loc)
!                *(states.hp):(loc) *(states.hft):(loc) *(states.hst):(loc)
!                *(states.husl1):(loc) *(states.husl2):(loc) *(states.hlsl):(loc)
!                *(states.hlr):(loc) cost:in-killed
!   Plus diff mem management of: parameters.ci:in parameters.cp:in
!                parameters.beta:in parameters.cft:in parameters.cst:in
!                parameters.alpha:in parameters.exc:in parameters.b:in
!                parameters.cusl1:in parameters.cusl2:in parameters.clsl:in
!                parameters.ks:in parameters.ds:in parameters.dsm:in
!                parameters.ws:in parameters.lr:in hyper_states.hi:in
!                hyper_states.hp:in hyper_states.hft:in hyper_states.hst:in
!                hyper_states.husl1:in hyper_states.husl2:in hyper_states.hlsl:in
!                hyper_states.hlr:in hyper_parameters.ci:in hyper_parameters.cp:in
!                hyper_parameters.beta:in hyper_parameters.cft:in
!                hyper_parameters.cst:in hyper_parameters.alpha:in
!                hyper_parameters.exc:in hyper_parameters.b:in
!                hyper_parameters.cusl1:in hyper_parameters.cusl2:in
!                hyper_parameters.clsl:in hyper_parameters.ks:in
!                hyper_parameters.ds:in hyper_parameters.dsm:in
!                hyper_parameters.ws:in hyper_parameters.lr:in
!                output.qsim:in output.qsim_domain:in states.hi:in
!                states.hp:in states.hft:in states.hst:in states.husl1:in
!                states.husl2:in states.hlsl:in states.hlr:in
SUBROUTINE BASE_HYPER_FORWARD_B(setup, mesh, input_data, parameters, &
& parameters_b, hyper_parameters, hyper_parameters_b, &
& hyper_parameters_bgd, states, states_b, hyper_states, hyper_states_b, &
& hyper_states_bgd, output, output_b, cost, cost_b)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_hyper_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: hyper_parameters_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: hyper_states_to_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters_b
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
& hyper_parameters_bgd
  TYPE(HYPER_PARAMETERSDT) :: hyper_parameters_b
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(STATESDT), INTENT(INOUT) :: states_b
  TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
  TYPE(HYPER_STATESDT) :: hyper_states_b
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  TYPE(OUTPUTDT_DIFF), INTENT(INOUT) :: output_b
  REAL(sp), INTENT(INOUT) :: cost
  REAL(sp), INTENT(INOUT) :: cost_b
  INTRINSIC TRIM
  INTEGER :: branch
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  CALL HYPER_PARAMETERS_TO_PARAMETERS(hyper_parameters, parameters, &
&                               setup, mesh, input_data)
  CALL HYPER_STATES_TO_STATES(hyper_states, states, setup, mesh, &
&                       input_data)
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_A_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(1)
  CASE ('gr-b') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_B_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(2)
  CASE ('gr-c') 
    CALL PUSHREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_C_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(3)
  CASE ('gr-d') 
    CALL PUSHREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2)&
&                )
    CALL PUSHREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                 , 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL GR_D_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
    CALL PUSHCONTROL3B(4)
  CASE ('vic-a') 
    CALL PUSHREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                 husl1, 2))
    CALL PUSHREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                 husl2, 2))
    CALL PUSHREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                 hlsl, 2))
    CALL PUSHREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                 , 2))
    CALL VIC_A_FORWARD(setup, mesh, input_data, parameters, states, &
&                output)
    CALL PUSHCONTROL3B(5)
  CASE DEFAULT
    CALL PUSHCONTROL3B(0)
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL HYPER_COMPUTE_COST(setup, mesh, input_data, hyper_parameters, &
&                   hyper_parameters_bgd, hyper_states, hyper_states_bgd&
&                   , output, cost)
  CALL SET_HYPER_PARAMETERS(setup, hyper_parameters_b, 0.0_4)
  CALL SET_HYPER_STATES(setup, hyper_states_b, 0.0_4)
  CALL HYPER_COMPUTE_COST_B(setup, mesh, input_data, hyper_parameters, &
&                     hyper_parameters_bgd, hyper_states, &
&                     hyper_states_bgd, output, output_b, cost, cost_b)
  CALL POPCONTROL3B(branch)
  IF (branch .LT. 3) THEN
    IF (branch .EQ. 0) THEN
      parameters_b%ci = 0.0_4
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hi = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
      states_b%hlr = 0.0_4
    ELSE IF (branch .EQ. 1) THEN
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hlr = 0.0_4
      output_b%qsim_domain = 0.0_4
      CALL GR_A_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
      parameters_b%ci = 0.0_4
      parameters_b%cst = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      states_b%hi = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
    ELSE
      CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr&
&                  , 2))
      CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft&
&                  , 2))
      CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2&
&                  ))
      CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2&
&                  ))
      parameters_b%ci = 0.0_4
      parameters_b%cp = 0.0_4
      parameters_b%cft = 0.0_4
      parameters_b%exc = 0.0_4
      parameters_b%lr = 0.0_4
      states_b%hi = 0.0_4
      states_b%hp = 0.0_4
      states_b%hft = 0.0_4
      states_b%hlr = 0.0_4
      output_b%qsim_domain = 0.0_4
      CALL GR_B_FORWARD_B(setup, mesh, input_data, parameters, &
&                   parameters_b, states, states_b, output, output_b)
      parameters_b%cst = 0.0_4
      parameters_b%b = 0.0_4
      parameters_b%cusl1 = 0.0_4
      parameters_b%cusl2 = 0.0_4
      parameters_b%clsl = 0.0_4
      parameters_b%ks = 0.0_4
      parameters_b%ds = 0.0_4
      parameters_b%dsm = 0.0_4
      parameters_b%ws = 0.0_4
      states_b%hst = 0.0_4
      states_b%husl1 = 0.0_4
      states_b%husl2 = 0.0_4
      states_b%hlsl = 0.0_4
    END IF
  ELSE IF (branch .EQ. 3) THEN
    CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, &
&                2))
    CALL POPREAL4ARRAY(states%hst, SIZE(states%hst, 1)*SIZE(states%hst, &
&                2))
    CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, &
&                2))
    CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
    CALL POPREAL4ARRAY(states%hi, SIZE(states%hi, 1)*SIZE(states%hi, 2))
    parameters_b%ci = 0.0_4
    parameters_b%cp = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%cst = 0.0_4
    parameters_b%exc = 0.0_4
    parameters_b%lr = 0.0_4
    states_b%hi = 0.0_4
    states_b%hp = 0.0_4
    states_b%hft = 0.0_4
    states_b%hst = 0.0_4
    states_b%hlr = 0.0_4
    output_b%qsim_domain = 0.0_4
    CALL GR_C_FORWARD_B(setup, mesh, input_data, parameters, &
&                 parameters_b, states, states_b, output, output_b)
    parameters_b%b = 0.0_4
    parameters_b%cusl1 = 0.0_4
    parameters_b%cusl2 = 0.0_4
    parameters_b%clsl = 0.0_4
    parameters_b%ks = 0.0_4
    parameters_b%ds = 0.0_4
    parameters_b%dsm = 0.0_4
    parameters_b%ws = 0.0_4
    states_b%husl1 = 0.0_4
    states_b%husl2 = 0.0_4
    states_b%hlsl = 0.0_4
  ELSE IF (branch .EQ. 4) THEN
    CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, &
&                2))
    CALL POPREAL4ARRAY(states%hft, SIZE(states%hft, 1)*SIZE(states%hft, &
&                2))
    CALL POPREAL4ARRAY(states%hp, SIZE(states%hp, 1)*SIZE(states%hp, 2))
    parameters_b%cp = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%lr = 0.0_4
    states_b%hp = 0.0_4
    states_b%hft = 0.0_4
    states_b%hlr = 0.0_4
    output_b%qsim_domain = 0.0_4
    CALL GR_D_FORWARD_B(setup, mesh, input_data, parameters, &
&                 parameters_b, states, states_b, output, output_b)
    parameters_b%ci = 0.0_4
    parameters_b%cst = 0.0_4
    parameters_b%exc = 0.0_4
    parameters_b%b = 0.0_4
    parameters_b%cusl1 = 0.0_4
    parameters_b%cusl2 = 0.0_4
    parameters_b%clsl = 0.0_4
    parameters_b%ks = 0.0_4
    parameters_b%ds = 0.0_4
    parameters_b%dsm = 0.0_4
    parameters_b%ws = 0.0_4
    states_b%hi = 0.0_4
    states_b%hst = 0.0_4
    states_b%husl1 = 0.0_4
    states_b%husl2 = 0.0_4
    states_b%hlsl = 0.0_4
  ELSE
    CALL POPREAL4ARRAY(states%hlr, SIZE(states%hlr, 1)*SIZE(states%hlr, &
&                2))
    CALL POPREAL4ARRAY(states%hlsl, SIZE(states%hlsl, 1)*SIZE(states%&
&                hlsl, 2))
    CALL POPREAL4ARRAY(states%husl2, SIZE(states%husl2, 1)*SIZE(states%&
&                husl2, 2))
    CALL POPREAL4ARRAY(states%husl1, SIZE(states%husl1, 1)*SIZE(states%&
&                husl1, 2))
    parameters_b%b = 0.0_4
    parameters_b%cusl1 = 0.0_4
    parameters_b%cusl2 = 0.0_4
    parameters_b%clsl = 0.0_4
    parameters_b%ks = 0.0_4
    parameters_b%ds = 0.0_4
    parameters_b%dsm = 0.0_4
    parameters_b%ws = 0.0_4
    parameters_b%lr = 0.0_4
    states_b%husl1 = 0.0_4
    states_b%husl2 = 0.0_4
    states_b%hlsl = 0.0_4
    states_b%hlr = 0.0_4
    output_b%qsim_domain = 0.0_4
    CALL VIC_A_FORWARD_B(setup, mesh, input_data, parameters, &
&                  parameters_b, states, states_b, output, output_b)
    parameters_b%ci = 0.0_4
    parameters_b%cp = 0.0_4
    parameters_b%cft = 0.0_4
    parameters_b%cst = 0.0_4
    parameters_b%exc = 0.0_4
    states_b%hi = 0.0_4
    states_b%hp = 0.0_4
    states_b%hft = 0.0_4
    states_b%hst = 0.0_4
  END IF
  CALL HYPER_STATES_TO_STATES_B(hyper_states, hyper_states_b, states, &
&                         states_b, setup, mesh, input_data)
  CALL HYPER_PARAMETERS_TO_PARAMETERS_B(hyper_parameters, &
&                                 hyper_parameters_b, parameters, &
&                                 parameters_b, setup, mesh, input_data)
END SUBROUTINE BASE_HYPER_FORWARD_B

SUBROUTINE BASE_HYPER_FORWARD_NODIFF(setup, mesh, input_data, parameters&
& , hyper_parameters, hyper_parameters_bgd, states, hyper_states, &
& hyper_states_bgd, output, cost)
!% only: sp
  USE MD_CONSTANT
!% only: SetupDT
  USE MWD_SETUP
!% only: MeshDT
  USE MWD_MESH
!% only: Input_DataDT
  USE MWD_INPUT_DATA
!% only: Hyper_ParametersDT
  USE MWD_PARAMETERS_DIFF
!% only: Hyper_StatesDT
  USE MWD_STATES_DIFF
!% only: OutputDT
  USE MWD_OUTPUT_DIFF
!% only: compute_hyper_cost
  USE MWD_COST_DIFF
!% only: gr_a_forward, gr_b_forward, gr_c_forward, gr_d_forward, vic_a_forward
  USE MD_FORWARD_STRUCTURE_DIFF
!% only: hyper_parameters_to_parameters
  USE MWD_PARAMETERS_MANIPULATION_DIFF
!% only: hyper_states_to_states
  USE MWD_STATES_MANIPULATION_DIFF
  IMPLICIT NONE
!% =================================================================================================================== %!
!%   Derived Type Variables (shared)
!% =================================================================================================================== %!
  TYPE(SETUPDT), INTENT(IN) :: setup
  TYPE(MESHDT), INTENT(IN) :: mesh
  TYPE(INPUT_DATADT), INTENT(INOUT) :: input_data
  TYPE(PARAMETERSDT), INTENT(INOUT) :: parameters
  TYPE(HYPER_PARAMETERSDT), INTENT(IN) :: hyper_parameters, &
& hyper_parameters_bgd
  TYPE(STATESDT), INTENT(INOUT) :: states
  TYPE(HYPER_STATESDT), INTENT(IN) :: hyper_states, hyper_states_bgd
  TYPE(OUTPUTDT), INTENT(INOUT) :: output
  REAL(sp), INTENT(INOUT) :: cost
  INTRINSIC TRIM
!% =================================================================================================================== %!
!%   Local Variables (private)
!% =================================================================================================================== %!
  CALL HYPER_PARAMETERS_TO_PARAMETERS(hyper_parameters, parameters, &
&                               setup, mesh, input_data)
  CALL HYPER_STATES_TO_STATES(hyper_states, states, setup, mesh, &
&                       input_data)
  SELECT CASE  (TRIM(setup%structure)) 
  CASE ('gr-a') 
    CALL GR_A_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-b') 
    CALL GR_B_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-c') 
    CALL GR_C_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('gr-d') 
    CALL GR_D_FORWARD(setup, mesh, input_data, parameters, states, &
&               output)
  CASE ('vic-a') 
    CALL VIC_A_FORWARD(setup, mesh, input_data, parameters, states, &
&                output)
  END SELECT
!% =================================================================================================================== %!
!%   Store states at final time step and reset states
!% =================================================================================================================== %!
  output%fstates = states
!% =================================================================================================================== %!
!%   Compute J
!% =================================================================================================================== %!
  CALL HYPER_COMPUTE_COST(setup, mesh, input_data, hyper_parameters, &
&                   hyper_parameters_bgd, hyper_states, hyper_states_bgd&
&                   , output, cost)
END SUBROUTINE BASE_HYPER_FORWARD_NODIFF

